{"version":3,"names":[],"sources":["../src/types.ts"],"sourcesContent":["import type { SourceType } from \"./options.ts\";\nimport type { Token } from \"./tokenizer/index.ts\";\nimport type { SourceLocation } from \"./util/location.ts\";\nimport type { PlaceholderTypes } from \"./plugins/placeholders.ts\";\nimport type { ParseError } from \"./parse-error.ts\";\n\n/*\n * If making any changes to the AST, update:\n * - This repository:\n *   - This file (including the `Node` alias at the bottom)\n *   - packages/babel-types/src/definitions\n *   - packages/babel-generators/src/generators\n */\n\ninterface CommentBase {\n  type: \"CommentBlock\" | \"CommentLine\";\n  value: string;\n  start: number;\n  end: number;\n  loc: SourceLocation;\n}\n\nexport interface CommentBlock extends CommentBase {\n  type: \"CommentBlock\";\n}\n\nexport interface CommentLine extends CommentBase {\n  type: \"CommentLine\";\n}\n\nexport type Comment = CommentBlock | CommentLine;\n\n// A whitespace containing comments\nexport interface CommentWhitespace {\n  start: number;\n  end: number;\n  comments: Array<Comment>;\n  leadingNode: Node | null;\n  trailingNode: Node | null;\n  containerNode: Node | null;\n}\n\nexport interface NodeBase {\n  start: number;\n  end: number;\n  loc: SourceLocation;\n  range?: [number, number];\n  leadingComments?: Array<Comment>;\n  trailingComments?: Array<Comment>;\n  innerComments?: Array<Comment>;\n  extra?: {\n    [key: string]: any;\n  };\n}\n\ntype NodeAny<T extends string, KnownProps = object> = NodeBase & {\n  type: T;\n  [key: string]: any;\n} & KnownProps;\nexport type Expression =\n  | ArrayExpression\n  | AssignmentExpression\n  | BinaryExpression\n  | CallExpression\n  | ConditionalExpression\n  | FunctionExpression\n  | Identifier\n  | StringLiteral\n  | NumericLiteral\n  | NullLiteral\n  | BooleanLiteral\n  | RegExpLiteral\n  | LogicalExpression\n  | MemberExpression\n  | NewExpression\n  | ObjectExpression\n  | SequenceExpression\n  | ParenthesizedExpression\n  | ThisExpression\n  | UnaryExpression\n  | UpdateExpression\n  | ArrowFunctionExpression\n  | ClassExpression\n  | ImportExpression\n  | MetaProperty\n  | Super\n  | TaggedTemplateExpression\n  | TemplateLiteral\n  | YieldExpression\n  | AwaitExpression\n  | Import\n  | BigIntLiteral\n  | OptionalMemberExpression\n  | OptionalCallExpression\n  | TypeCastExpression\n  | JSXElement\n  | JSXFragment\n  | BindExpression\n  | DoExpression\n  | RecordExpression\n  | TupleExpression\n  | DecimalLiteral\n  | ModuleExpression\n  | TopicReference\n  | PipelineTopicExpression\n  | PipelineBareFunction\n  | PipelinePrimaryTopicReference\n  | TsInstantiationExpression\n  | TsAsExpression\n  | TsSatisfiesExpression\n  | TsTypeAssertion\n  | TsTypeCastExpression\n  | TsNonNullExpression\n  | EstreeChainExpression\n  | EstreeLiteral;\nexport type Statement =\n  | BlockStatement\n  | BreakStatement\n  | ContinueStatement\n  | DebuggerStatement\n  | DoWhileStatement\n  | EmptyStatement\n  | ExpressionStatement\n  | ForInStatement\n  | ForStatement\n  | FunctionDeclaration\n  | IfStatement\n  | LabeledStatement\n  | ReturnStatement\n  | SwitchStatement\n  | ThrowStatement\n  | TryStatement\n  | VariableDeclaration\n  | WhileStatement\n  | WithStatement\n  | ClassDeclaration\n  | ExportAllDeclaration\n  | ExportDefaultDeclaration\n  | ExportNamedDeclaration\n  | ForOfStatement\n  | ImportDeclaration\n  | FlowDeclareClass\n  | FlowDeclareFunction\n  | FlowDeclareInterface\n  | FlowDeclareModule\n  | FlowDeclareModuleExports\n  | FlowDeclareTypeAlias\n  | FlowDeclareOpaqueType\n  | FlowDeclareVariable\n  | FlowDeclareExportDeclaration\n  | FlowEnumDeclaration\n  | FlowInterface\n  | FlowOpaqueType\n  | FlowTypeAlias\n  | TSDeclareFunction\n  | TsInterfaceDeclaration\n  | TsTypeAliasDeclaration\n  | TsEnumDeclaration\n  | TsModuleDeclaration\n  | TsImportEqualsDeclaration\n  | TsExportAssignment\n  | TsNamespaceExportDeclaration;\nexport type Pattern =\n  | Identifier\n  | ObjectPattern\n  | ArrayPattern\n  | RestElement\n  | AssignmentPattern;\n//| Placeholder<\"Pattern\">;\nexport type Declaration =\n  | VariableDeclaration\n  | ClassDeclaration\n  | FunctionDeclaration\n  | TsImportEqualsDeclaration\n  | TsInterfaceDeclaration\n  | TsTypeAliasDeclaration\n  | TsEnumDeclaration\n  | TsModuleDeclaration;\n// | Placeholder<\"Declaration\">;\n\nexport interface DeclarationBase extends NodeBase {\n  // TypeScript allows declarations to be prefixed by `declare`.\n  //TODO: a FunctionDeclaration is never \"declare\", because it's a TSDeclareFunction instead.\n  declare?: true;\n}\n\n// TODO: Not in spec\nexport interface HasDecorators extends NodeBase {\n  decorators?: Decorator[];\n}\n\nexport interface InterpreterDirective extends NodeBase {\n  type: \"InterpreterDirective\";\n  value: string;\n}\n\nexport interface Identifier extends PatternBase {\n  type: \"Identifier\";\n  name: string;\n  // @deprecated\n  __clone(): Identifier;\n  // TypeScript only. Used in case of an optional parameter.\n  optional?: true | null;\n}\n// | Placeholder<\"Identifier\">;\n\nexport interface PrivateName extends NodeBase {\n  type: \"PrivateName\";\n  id: Identifier;\n}\n\n// Literals\n\nexport type Literal =\n  | RegExpLiteral\n  | NullLiteral\n  | StringLiteral\n  | BooleanLiteral\n  | NumericLiteral\n  | BigIntLiteral\n  | DecimalLiteral;\n\ntype RegExpFlag = \"g\" | \"i\" | \"m\" | \"u\" | \"s\" | \"y\" | \"v\";\n\nexport interface RegExpLiteral extends NodeBase {\n  type: \"RegExpLiteral\";\n  pattern: string;\n  flags: RegExpFlag[];\n}\n\nexport interface NullLiteral extends NodeBase {\n  type: \"NullLiteral\";\n}\n\nexport interface StringLiteral extends NodeBase {\n  type: \"StringLiteral\";\n  value: string;\n}\n\nexport interface BooleanLiteral extends NodeBase {\n  type: \"BooleanLiteral\";\n  value: boolean;\n}\n\nexport interface NumericLiteral extends NodeBase {\n  type: \"NumericLiteral\";\n  value: number;\n}\n\nexport interface BigIntLiteral extends NodeBase {\n  type: \"BigIntLiteral\";\n  value: number;\n}\n\nexport interface DecimalLiteral extends NodeBase {\n  type: \"DecimalLiteral\";\n  value: number;\n}\n\nexport interface ParserOutput {\n  comments: Comment[];\n  errors: Array<ParseError<any>>;\n  tokens?: Array<Token | Comment>;\n}\n// Programs\n\nexport type BlockStatementLike = Program | BlockStatement;\n\nexport interface File extends NodeBase, ParserOutput {\n  type: \"File\";\n  program: Program;\n}\n\nexport interface Program extends NodeBase {\n  type: \"Program\";\n  sourceType: SourceType;\n  body: Array<Statement | ModuleDeclaration>; // TODO: $ReadOnlyArray,\n  directives: Directive[]; // TODO: Not in spec,\n  interpreter: InterpreterDirective | null;\n}\n\n// Functions\n\nexport type Function =\n  | NormalFunction\n  | ArrowFunctionExpression\n  | ObjectMethod\n  | ClassMethod;\n\nexport type NormalFunction = FunctionDeclaration | FunctionExpression;\n\nexport interface BodilessFunctionOrMethodBase extends HasDecorators {\n  // TODO: Remove this. Should not assign \"id\" to methods.\n  // https://github.com/babel/babylon/issues/535\n  id: Identifier | undefined | null;\n  params: Array<Pattern | TSParameterProperty>;\n  generator: boolean;\n  async: boolean;\n  // TODO: All not in spec\n  expression: boolean;\n  typeParameters?: TypeParameterDeclarationBase | null;\n  returnType?: TypeAnnotationBase | null;\n}\n\nexport interface FunctionBase extends BodilessFunctionOrMethodBase {\n  body: BlockStatement;\n}\n\n// Statements\n\nexport interface ExpressionStatement extends NodeBase {\n  type: \"ExpressionStatement\";\n  expression: Expression;\n}\n\nexport interface BlockStatement extends NodeBase {\n  type: \"BlockStatement\";\n  body: Array<Statement>; // TODO: $ReadOnlyArray,\n  directives: Directive[];\n}\n// | Placeholder<\"BlockStatement\">;\n\nexport interface EmptyStatement extends NodeBase {\n  type: \"EmptyStatement\";\n}\n\nexport interface DebuggerStatement extends NodeBase {\n  type: \"DebuggerStatement\";\n}\n\nexport interface WithStatement extends NodeBase {\n  type: \"WithStatement\";\n  object: Expression;\n  body: Statement;\n}\n\nexport interface ReturnStatement extends NodeBase {\n  type: \"ReturnStatement\";\n  argument: Expression | undefined | null;\n}\n\nexport interface LabeledStatement extends NodeBase {\n  type: \"LabeledStatement\";\n  label: Identifier;\n  body: Statement;\n}\n\nexport interface BreakStatement extends NodeBase {\n  type: \"BreakStatement\";\n  label: Identifier | undefined | null;\n}\n\nexport interface ContinueStatement extends NodeBase {\n  type: \"ContinueStatement\";\n  label: Identifier | undefined | null;\n}\n\n// Choice\n\nexport interface IfStatement extends NodeBase {\n  type: \"IfStatement\";\n  test: Expression;\n  consequent: Statement;\n  alternate: Statement | undefined | null;\n}\n\nexport interface SwitchStatement extends NodeBase {\n  type: \"SwitchStatement\";\n  discriminant: Expression;\n  cases: SwitchCase[];\n}\n\nexport interface SwitchCase extends NodeBase {\n  type: \"SwitchCase\";\n  test: Expression | undefined | null;\n  consequent: Statement[];\n}\n\n// Exceptions\n\nexport interface ThrowStatement extends NodeBase {\n  type: \"ThrowStatement\";\n  argument: Expression;\n}\n\nexport interface TryStatement extends NodeBase {\n  type: \"TryStatement\";\n  block: BlockStatement;\n  handler: CatchClause | null;\n  finalizer: BlockStatement | null;\n}\n\nexport interface CatchClause extends NodeBase {\n  type: \"CatchClause\";\n  param: Pattern;\n  body: BlockStatement;\n}\n\n// Loops\n\nexport interface WhileStatement extends NodeBase {\n  type: \"WhileStatement\";\n  test: Expression;\n  body: Statement;\n}\n\nexport interface DoWhileStatement extends NodeBase {\n  type: \"DoWhileStatement\";\n  body: Statement;\n  test: Expression;\n}\n\nexport type ForLike = ForStatement | ForInOf;\n\nexport interface ForStatement extends NodeBase {\n  type: \"ForStatement\";\n  init: VariableDeclaration | Expression | undefined | null;\n  test: Expression | undefined | null;\n  update: Expression | undefined | null;\n  body: Statement;\n}\n\nexport type ForInOf = ForInStatement | ForOfStatement;\n\ninterface ForInOfBase extends NodeBase {\n  left: VariableDeclaration | Assignable;\n  right: Expression;\n  body: Statement;\n}\n\nexport interface ForInStatement extends ForInOfBase {\n  type: \"ForInStatement\";\n  // TODO: Shouldn't be here, but have to declare it because it's assigned to a ForInOf unconditionally.\n  await: boolean;\n}\n\nexport interface ForOfStatement extends ForInOfBase {\n  type: \"ForOfStatement\";\n  await: boolean;\n}\n\n// Declarations\n\nexport interface OptFunctionDeclaration extends FunctionBase, DeclarationBase {\n  type: \"FunctionDeclaration\";\n}\n\nexport interface FunctionDeclaration extends OptFunctionDeclaration {\n  id: Identifier;\n}\n\nexport interface VariableDeclaration extends DeclarationBase, HasDecorators {\n  type: \"VariableDeclaration\";\n  declarations: VariableDeclarator[];\n  kind: \"var\" | \"let\" | \"const\" | \"using\" | \"await using\";\n}\n\nexport interface VariableDeclarator extends NodeBase {\n  type: \"VariableDeclarator\";\n  id: Pattern;\n  init: Expression | undefined | null;\n  // TypeScript only:\n  definite?: true;\n}\n\n// Misc\n\nexport interface ArgumentPlaceholder extends NodeBase {\n  type: \"ArgumentPlaceholder\";\n}\n\nexport interface Decorator extends NodeBase {\n  type: \"Decorator\";\n  expression: Expression;\n  arguments?: Array<Expression | SpreadElement>;\n}\n\nexport interface Directive extends NodeBase {\n  type: \"Directive\";\n  value: DirectiveLiteral;\n}\n\nexport interface DirectiveLiteral extends NodeBase {\n  type: \"DirectiveLiteral\";\n  value: string;\n}\n\nexport interface ImportAttribute extends NodeBase {\n  type: \"ImportAttribute\";\n  key: Identifier | StringLiteral;\n  value: StringLiteral;\n}\n\n// Expressions\n\nexport interface Super extends NodeBase {\n  type: \"Super\";\n}\n\nexport interface Import extends NodeBase {\n  type: \"Import\";\n}\n\nexport interface ThisExpression extends NodeBase {\n  type: \"ThisExpression\";\n}\n\nexport interface ArrowFunctionExpression extends BodilessFunctionOrMethodBase {\n  type: \"ArrowFunctionExpression\";\n  body: BlockStatement | Expression;\n}\n\nexport interface YieldExpression extends NodeBase {\n  type: \"YieldExpression\";\n  argument: Expression | undefined | null;\n  delegate: boolean;\n}\n\nexport interface AwaitExpression extends NodeBase {\n  type: \"AwaitExpression\";\n  argument: Expression;\n}\n\nexport interface ArrayExpression extends NodeBase {\n  type: \"ArrayExpression\";\n  elements: Array<Expression | SpreadElement | undefined | null>;\n}\n\nexport interface DoExpression extends NodeBase {\n  type: \"DoExpression\";\n  body: BlockStatement | undefined | null;\n  async: boolean;\n}\n\nexport interface TupleExpression extends NodeBase {\n  type: \"TupleExpression\";\n  elements: Array<Expression | SpreadElement | undefined | null>;\n}\n\nexport interface ObjectExpression extends NodeBase {\n  type: \"ObjectExpression\";\n  properties: Array<ObjectProperty | ObjectMethod | SpreadElement>;\n}\nexport interface RecordExpression extends NodeBase {\n  type: \"RecordExpression\";\n  properties: Array<ObjectProperty | ObjectMethod | SpreadElement>;\n}\n\nexport type ObjectOrClassMember = ClassMethod | ClassProperty | ObjectMember;\n\nexport type ObjectMember = ObjectProperty | ObjectMethod;\n\nexport interface ObjectMemberBase extends NodeBase {\n  computed: boolean;\n  value: Expression | Pattern;\n  decorators?: Decorator[];\n  kind?: \"get\" | \"set\" | \"method\";\n  method: boolean; // TODO: Not in spec,\n  typeParameters?: TypeParameterDeclarationBase | null; // TODO: Not in spec,\n  variance?: FlowVariance | null; // TODO: Not in spec\n}\n\nexport interface ObjectProperty extends ObjectMemberBase {\n  type: \"ObjectProperty\";\n  shorthand: boolean;\n  key: Expression | PrivateName; // For private destructuring\n  value: Expression | Pattern;\n}\n\nexport interface ObjectMethod extends ObjectMemberBase, FunctionBase {\n  type: \"ObjectMethod\";\n  kind: \"get\" | \"set\" | \"method\"; // Never \"constructor\"\n  key: Expression;\n  value: Expression;\n}\n\nexport interface FunctionExpression extends FunctionBase {\n  kind?: void; // never set,\n  type: \"FunctionExpression\";\n}\n\n// Unary operations\n\nexport interface UnaryExpression extends NodeBase {\n  type: \"UnaryExpression\";\n  operator: UnaryOperator;\n  prefix: boolean;\n  argument: Expression;\n}\n\nexport type UnaryOperator =\n  | \"-\"\n  | \"+\"\n  | \"!\"\n  | \"~\"\n  | \"typeof\"\n  | \"void\"\n  | \"delete\"\n  | \"throw\";\n\nexport interface UpdateExpression extends NodeBase {\n  type: \"UpdateExpression\";\n  operator: UpdateOperator;\n  argument: Expression;\n  prefix: boolean;\n}\n\nexport type UpdateOperator = \"++\" | \"--\";\n\n// Binary operations\n\nexport interface BinaryExpression extends NodeBase {\n  type: \"BinaryExpression\";\n  operator: BinaryOperator;\n  left: Expression | PrivateName;\n  right: Expression;\n}\n\nexport type BinaryOperator =\n  | \"==\"\n  | \"!=\"\n  | \"===\"\n  | \"!==\"\n  | \"<\"\n  | \"<=\"\n  | \">\"\n  | \">=\"\n  | \"<<\"\n  | \">>\"\n  | \">>>\"\n  | \"+\"\n  | \"-\"\n  | \"*\"\n  | \"/\"\n  | \"%\"\n  | \"|\"\n  | \"^\"\n  | \"&\"\n  | \"in\"\n  | \"instanceof\";\n\nexport type Assignable =\n  | Pattern\n  | MemberExpression\n  | ParenthesizedExpression\n  | TsTypeCastExpression\n  | TypeCastExpression;\n\nexport interface AssignmentExpression extends NodeBase {\n  type: \"AssignmentExpression\";\n  operator: AssignmentOperator;\n  left: Assignable;\n  right: Expression;\n}\n\nexport type AssignmentOperator =\n  | \"=\"\n  | \"+=\"\n  | \"-=\"\n  | \"*=\"\n  | \"/=\"\n  | \"%=\"\n  | \"<<=\"\n  | \">>=\"\n  | \">>>=\"\n  | \"|=\"\n  | \"^=\"\n  | \"&=\";\n\nexport interface LogicalExpression extends NodeBase {\n  type: \"LogicalExpression\";\n  operator: LogicalOperator;\n  left: Expression;\n  right: Expression;\n}\n\nexport type LogicalOperator = \"||\" | \"&&\";\n\nexport interface SpreadElement extends NodeBase {\n  type: \"SpreadElement\";\n  argument: Expression;\n}\n\nexport interface MemberExpression extends NodeBase {\n  type: \"MemberExpression\";\n  object: Expression | Super;\n  property: Expression | PrivateName;\n  computed: boolean;\n}\n\nexport interface OptionalMemberExpression extends NodeBase {\n  type: \"OptionalMemberExpression\";\n  object: Expression | Super;\n  property: Expression | PrivateName;\n  computed: boolean;\n  optional: boolean;\n}\n\nexport interface OptionalCallExpression extends CallOrNewBase {\n  type: \"OptionalCallExpression\";\n  optional: boolean;\n}\nexport interface BindExpression extends NodeBase {\n  type: \"BindExpression\";\n  object: Expression | undefined | null;\n  callee: Expression;\n}\n\nexport interface ConditionalExpression extends NodeBase {\n  type: \"ConditionalExpression\";\n  test: Expression;\n  alternate: Expression;\n  consequent: Expression;\n}\n\nexport interface CallOrNewBase extends NodeBase {\n  callee: Expression | Super | Import;\n  arguments: Array<Expression | SpreadElement>; // TODO: $ReadOnlyArray,\n  typeArguments: TypeParameterInstantiationBase | undefined | null;\n  /**\n   * @deprecated\n   */\n  typeParameters?: TypeParameterInstantiationBase | null; // TODO: Not in spec\n}\n\nexport interface CallExpression extends CallOrNewBase {\n  type: \"CallExpression\";\n}\n\nexport interface NewExpression extends CallOrNewBase {\n  type: \"NewExpression\";\n  optional?: boolean; // TODO: Not in spec\n}\n\nexport interface ImportExpression extends NodeBase {\n  type: \"ImportExpression\";\n  source: Expression;\n  phase?: null | \"source\" | \"defer\";\n  options: Expression | null;\n}\n\nexport interface SequenceExpression extends NodeBase {\n  type: \"SequenceExpression\";\n  expressions: Expression[];\n}\n\nexport interface ParenthesizedExpression extends NodeBase {\n  type: \"ParenthesizedExpression\";\n  expression: Expression;\n}\n\n// Hack pipe operator\n\nexport interface TopicReference extends NodeBase {\n  type: \"TopicReference\";\n}\n\n// Smart-mix pipe operator\n\nexport interface PipelineBody extends NodeBase {\n  type: \"PipelineBody\";\n}\n\nexport interface PipelineBareFunctionBody extends NodeBase {\n  type: \"PipelineBareFunctionBody\";\n  callee: Expression;\n}\n\nexport interface PipelineBareConstructorBody extends NodeBase {\n  type: \"PipelineBareConstructorBody\";\n  callee: Expression;\n}\n\nexport interface PipelineBareAwaitedFunctionBody extends NodeBase {\n  type: \"PipelineBareAwaitedFunctionBody\";\n  callee: Expression;\n}\n\nexport interface PipelineTopicBody extends NodeBase {\n  type: \"PipelineTopicBody\";\n  expression: Expression;\n}\n\nexport type PipelineStyle =\n  | \"PipelineBareFunction\"\n  | \"PipelineBareConstructor\"\n  | \"PipelineBareAwaitedFunction\"\n  | \"PipelineTopicExpression\";\n\nexport interface PipelinePrimaryTopicReference extends NodeBase {\n  type: \"PipelinePrimaryTopicReference\";\n}\n\n// Template Literals\n\nexport interface TemplateLiteral extends NodeBase {\n  type: \"TemplateLiteral\";\n  quasis: TemplateElement[];\n  expressions: Expression[] | TsType[];\n}\n\nexport interface TaggedTemplateExpression extends NodeBase {\n  type: \"TaggedTemplateExpression\";\n  tag: Expression;\n  quasi: TemplateLiteral;\n  typeArguments?: TypeParameterInstantiationBase | null; // TODO: Not in spec\n  /**\n   * @deprecated\n   */\n  typeParameters?: TypeParameterInstantiationBase | null; // TODO: Not in spec\n}\n\nexport interface TemplateElement extends NodeBase {\n  type: \"TemplateElement\";\n  tail: boolean;\n  value: {\n    cooked: string;\n    raw: string;\n  };\n}\n\nexport interface ModuleExpression extends NodeBase {\n  type: \"ModuleExpression\";\n  body: Program;\n}\n\n// Patterns\n\n// TypeScript access modifiers\nexport type Accessibility = \"public\" | \"protected\" | \"private\";\n\nexport type VarianceAnnotations = \"in\" | \"out\";\n\nexport interface PatternBase extends HasDecorators {\n  // TODO: All not in spec\n  // Flow/TypeScript only:\n  typeAnnotation?: TypeAnnotationBase | null;\n}\n\nexport interface AssignmentProperty extends ObjectProperty {\n  value: Pattern;\n}\n\nexport interface ObjectPattern extends PatternBase {\n  type: \"ObjectPattern\";\n  properties: (AssignmentProperty | RestElement)[];\n}\n\nexport interface ArrayPattern extends PatternBase {\n  type: \"ArrayPattern\";\n  elements: (Pattern | undefined | null)[];\n}\n\nexport interface RestElement extends PatternBase {\n  type: \"RestElement\";\n  argument: Pattern;\n}\n\nexport interface AssignmentPattern extends PatternBase {\n  type: \"AssignmentPattern\";\n  left: Pattern;\n  right: Expression;\n}\n\n// Classes\n\nexport type Class = ClassDeclaration | ClassExpression;\n\nexport interface ClassBase extends HasDecorators {\n  id: Identifier | undefined | null;\n  superClass: Expression | undefined | null;\n  body: ClassBody;\n  decorators?: Decorator[];\n  // TODO: All not in spec\n  typeParameters?: TypeParameterDeclarationBase | null;\n  superTypeParameters?: TypeParameterInstantiationBase | null; // babel 7\n  superTypeArguments?: TypeParameterInstantiationBase | null; // babel 8\n  abstract?: boolean;\n  implements?: TSClassImplements[] | undefined | null | FlowClassImplements[];\n}\n\nexport interface ClassBody extends NodeBase {\n  type: \"ClassBody\";\n  body: Array<ClassMember | StaticBlock | TsIndexSignature>; // TODO: $ReadOnlyArray\n}\n// | Placeholder<\"ClassBody\">;\n\nexport interface ClassMemberBase extends NodeBase, HasDecorators {\n  static: boolean;\n  computed: boolean;\n  // TypeScript only:\n  accessibility?: Accessibility | null;\n  override?: true | null;\n  abstract?: true | null;\n  optional?: true | null;\n}\n\nexport interface StaticBlock extends NodeBase {\n  type: \"StaticBlock\";\n  body: Array<Statement>;\n}\n\nexport type ClassMember =\n  | ClassMethod\n  | ClassPrivateMethod\n  | ClassProperty\n  | ClassPrivateProperty\n  | ClassAccessorProperty;\n\nexport type MethodLike =\n  | ObjectMethod\n  | FunctionExpression\n  | ClassMethod\n  | ClassPrivateMethod\n  | TSDeclareMethod;\n\ninterface MethodBase extends FunctionBase {\n  kind: MethodKind;\n}\n\nexport type MethodKind = \"constructor\" | \"method\" | \"get\" | \"set\";\n\nexport interface ClassMethodOrDeclareMethodCommon extends ClassMemberBase {\n  key: Expression | PrivateName;\n  kind: MethodKind;\n  static: boolean;\n  decorators?: Decorator[];\n}\n\nexport interface ClassMethod\n  extends MethodBase,\n    ClassMethodOrDeclareMethodCommon {\n  type: \"ClassMethod\";\n  variance?: FlowVariance | null; // TODO: Not in spec\n}\n\nexport interface ClassPrivateMethod\n  extends NodeBase,\n    ClassMethodOrDeclareMethodCommon,\n    MethodBase {\n  type: \"ClassPrivateMethod\";\n  key: PrivateName;\n  computed: false;\n  variance?: FlowVariance | null; // TODO: Not in spec\n}\n\nexport interface ClassProperty extends ClassMemberBase, DeclarationBase {\n  type: \"ClassProperty\";\n  key: Expression;\n  value: Expression | undefined | null; // TODO: Not in spec that this is nullable.,\n  typeAnnotation?: TypeAnnotationBase | null; // TODO: Not in spec,\n  // Flow only:\n  variance?: FlowVariance | null; // TODO: Not in spec,\n  // TypeScript only: (TODO: Not in spec)\n  readonly?: true;\n  definite?: true;\n}\n\nexport interface ClassPrivateProperty extends NodeBase {\n  type: \"ClassPrivateProperty\";\n  key: PrivateName;\n  value: Expression | undefined | null; // TODO: Not in spec that this is nullable.,\n  static: boolean;\n  computed: false;\n  // Flow and Typescript\n  typeAnnotation?: TypeAnnotationBase | null;\n  // TypeScript only\n  optional?: true;\n  definite?: true;\n  readonly?: true;\n  override?: true;\n  // For error recovery\n  abstract?: null;\n  accessibility?: null;\n  // Flow only\n  variance?: FlowVariance | null;\n}\n\nexport interface ClassAccessorProperty\n  extends ClassMemberBase,\n    DeclarationBase {\n  type: \"ClassAccessorProperty\";\n  key: Expression | PrivateName;\n  value: Expression | undefined | null;\n  typeAnnotation?: TypeAnnotationBase | null; // TODO: Not in spec,\n  variance?: FlowVariance | null; // TODO: Not in spec,\n  // TypeScript only: (TODO: Not in spec)\n  readonly?: true;\n  definite?: true;\n}\n\nexport interface OptClassDeclaration\n  extends ClassBase,\n    DeclarationBase,\n    HasDecorators {\n  type: \"ClassDeclaration\";\n  // TypeScript only\n  abstract?: true | null;\n}\n\nexport interface ClassDeclaration extends OptClassDeclaration {\n  id: Identifier;\n}\n\nexport interface ClassExpression extends ClassBase {\n  type: \"ClassExpression\";\n}\n\nexport interface MetaProperty extends NodeBase {\n  type: \"MetaProperty\";\n  meta: Identifier;\n  property: Identifier;\n}\n\n// Modules\n\nexport type ModuleDeclaration = AnyImport | AnyExport;\n\nexport type AnyImport = ImportDeclaration | TsImportEqualsDeclaration;\n\nexport type AnyExport =\n  | ExportNamedDeclaration\n  | ExportDefaultDeclaration\n  | ExportAllDeclaration\n  | TsExportAssignment\n  | TsImportEqualsDeclaration\n  | TsNamespaceExportDeclaration;\n\ninterface ModuleSpecifier extends NodeBase {\n  local: Identifier;\n}\n\n// Imports\n\nexport interface ImportDeclaration extends NodeBase {\n  type: \"ImportDeclaration\";\n  // TODO: $ReadOnlyArray\n  specifiers: Array<\n    ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier\n  >;\n  source: Literal;\n  importKind?: \"type\" | \"typeof\" | \"value\"; // TODO: Not in spec,\n  phase?: null | \"source\" | \"defer\";\n  attributes?: ImportAttribute[];\n  // @deprecated\n  assertions?: ImportAttribute[];\n  module?: boolean;\n}\n\nexport interface ImportSpecifier extends ModuleSpecifier {\n  type: \"ImportSpecifier\";\n  imported: Identifier | StringLiteral;\n  importKind?: \"type\" | \"value\";\n}\n\nexport interface ImportDefaultSpecifier extends ModuleSpecifier {\n  type: \"ImportDefaultSpecifier\";\n}\n\nexport interface ImportNamespaceSpecifier extends ModuleSpecifier {\n  type: \"ImportNamespaceSpecifier\";\n}\n\n// Exports\n\nexport interface ExportNamedDeclaration extends NodeBase {\n  type: \"ExportNamedDeclaration\";\n  declaration: Declaration | undefined | null;\n  specifiers: Array<\n    ExportSpecifier | ExportDefaultSpecifier | ExportNamespaceSpecifier\n  >;\n  source: Literal | undefined | null;\n  exportKind?: \"type\" | \"value\"; // TODO: Not in spec,\n  attributes?: ImportAttribute[];\n  // @deprecated\n  assertions?: ImportAttribute[];\n}\n\nexport interface ExportSpecifier extends NodeBase {\n  type: \"ExportSpecifier\";\n  exported: Identifier | StringLiteral;\n  local: Identifier;\n  exportKind?: \"type\" | \"value\";\n}\n\nexport interface ExportDefaultSpecifier extends NodeBase {\n  type: \"ExportDefaultSpecifier\";\n  exported: Identifier;\n}\n\nexport interface ExportNamespaceSpecifier extends NodeBase {\n  type: \"ExportNamespaceSpecifier\";\n  exported: Identifier | StringLiteral;\n}\n\nexport interface ExportDefaultDeclaration extends NodeBase {\n  type: \"ExportDefaultDeclaration\";\n  declaration:\n    | OptFunctionDeclaration\n    | OptTSDeclareFunction\n    | OptClassDeclaration\n    | FlowEnumDeclaration\n    | TsInterfaceDeclaration\n    | Expression;\n}\n\nexport interface ExportAllDeclaration extends NodeBase {\n  type: \"ExportAllDeclaration\";\n  source: Literal;\n  exportKind?: \"type\" | \"value\"; // TODO: Not in spec,\n  assertions?: ImportAttribute[];\n  attributes?: ImportAttribute[];\n}\n\nexport interface PipelineTopicExpression extends NodeBase {\n  type: \"PipelineTopicExpression\";\n  expression: Expression;\n}\n\nexport interface PipelineBareFunction extends NodeBase {\n  type: \"PipelineBareFunction\";\n  callee: Expression;\n}\n\n// JSX (TODO: Not in spec)\n\nexport type JSXIdentifier = NodeAny<\"JSXIdentifier\">;\nexport type JSXNamespacedName = NodeAny<\"JSXNamespacedName\">;\nexport type JSXMemberExpression = NodeAny<\"JSXMemberExpression\">;\nexport type JSXEmptyExpression = NodeAny<\"JSXEmptyExpression\">;\nexport type JSXSpreadChild = NodeAny<\"JSXSpreadChild\">;\nexport type JSXExpressionContainer = NodeAny<\"JSXExpressionContainer\">;\nexport type JSXAttribute = NodeAny<\"JSXAttribute\">;\nexport type JSXSpreadAttribute = NodeAny<\"JSXSpreadAttribute\">;\n\n// add a new type for JSXPropShorthandAttribute\nexport type JSXPropShorthandAttribute = NodeAny<\"JSXPropShorthandAttribute\">;\n\nexport interface JSXOpeningElement extends NodeBase {\n  type: \"JSXOpeningElement\";\n  name: JSXNamespacedName | JSXMemberExpression;\n  typeArguments?: TypeParameterInstantiationBase | null; // TODO: Not in spec,\n  /**\n   * @deprecated\n   */\n  typeParameters?: TypeParameterInstantiationBase | null; // TODO: Not in spec,\n  attributes: (JSXAttribute | JSXSpreadAttribute | JSXPropShorthandAttribute)[];\n  selfClosing: boolean;\n}\nexport type JSXClosingElement = NodeAny<\"JSXClosingElement\">;\nexport type JSXElement = NodeAny<\"JSXElement\">;\nexport type JSXOpeningFragment = NodeAny<\"JSXOpeningFragment\">;\nexport type JSXClosingFragment = NodeAny<\"JSXClosingFragment\">;\nexport type JSXFragment = NodeAny<\"JSXFragment\">;\nexport type JSXElementTag = JSXOpeningElement | JSXClosingElement;\nexport type JSXFragmentTag = JSXOpeningFragment | JSXClosingFragment;\nexport type JSXTag = JSXElementTag | JSXFragmentTag;\nexport type JSXText = NodeAny<\"JSXText\">;\n\n// Flow/TypeScript common (TODO: Not in spec)\n\nexport interface TypeAnnotationBase extends NodeBase {\n  typeAnnotation: Node;\n}\n\nexport interface TypeAnnotation extends NodeBase {\n  type: \"TypeAnnotation\";\n  typeAnnotation: FlowType;\n}\n\nexport interface TsTypeAnnotation extends NodeBase {\n  type: \"TSTypeAnnotation\";\n  typeAnnotation: TsType;\n}\n\nexport interface TypeParameterDeclarationBase extends NodeBase {\n  params: Array<TypeParameter | TsTypeParameter>;\n}\n\nexport interface TypeParameterDeclaration extends TypeParameterDeclarationBase {\n  type: \"TypeParameterDeclaration\";\n  params: TypeParameter[];\n}\n\nexport interface TsTypeParameterDeclaration\n  extends TypeParameterDeclarationBase {\n  type: \"TSTypeParameterDeclaration\";\n  params: TsTypeParameter[];\n}\n\nexport interface TypeParameter extends NodeBase {\n  type: \"TypeParameter\";\n  name: string;\n  default?: TypeAnnotation;\n}\n\nexport interface TsTypeParameter extends NodeBase {\n  type: \"TSTypeParameter\";\n  // TODO(Babel 8): remove string type support\n  name: string | Identifier;\n  in?: boolean;\n  out?: boolean;\n  const?: boolean;\n  constraint?: TsType;\n  default?: TsType;\n}\n\nexport interface TypeParameterInstantiationBase extends NodeBase {\n  params: Node[];\n}\n\nexport interface TypeParameterInstantiation\n  extends TypeParameterInstantiationBase {\n  type: \"TypeParameterInstantiation\";\n  params: FlowType[];\n}\n\nexport interface TsTypeParameterInstantiation\n  extends TypeParameterInstantiationBase {\n  type: \"TSTypeParameterInstantiation\";\n  params: TsType[];\n}\n\n// Flow (TODO: Not in spec)\n\nexport interface TypeCastExpressionBase extends NodeBase {\n  expression: Expression;\n  typeAnnotation: TypeAnnotationBase;\n}\n\nexport interface TypeCastExpression extends NodeBase {\n  type: \"TypeCastExpression\";\n  expression: Expression;\n  typeAnnotation: TypeAnnotation;\n}\n\nexport interface TsTypeCastExpression extends NodeBase {\n  type: \"TSTypeCastExpression\";\n  expression: Expression;\n  typeAnnotation: TsTypeAnnotation;\n}\n\nexport type FlowPredicate =\n  | NodeAny<\"DeclaredPredicate\">\n  | NodeAny<\"InferredPredicate\">;\nexport type FlowDeclare =\n  | FlowDeclareClass\n  | FlowDeclareExportDeclaration\n  | FlowDeclareFunction\n  | FlowDeclareVariable\n  | FlowDeclareModule\n  | FlowDeclareModuleExports\n  | FlowDeclareTypeAlias\n  | FlowDeclareOpaqueType\n  | FlowDeclareInterface;\nexport type FlowDeclareClass = NodeAny<\"DeclareClass\">;\nexport type FlowDeclareExportDeclaration =\n  | NodeAny<\"DeclareExportDeclaration\">\n  | NodeAny<\"DeclareExportDefaultDeclaration\">\n  | NodeAny<\"DeclareExportAllDeclaration\">;\nexport type FlowDeclareFunction = NodeAny<\"DeclareFunction\">;\nexport type FlowDeclareVariable = NodeAny<\"DeclareVariable\">;\nexport type FlowDeclareModule = NodeAny<\"DeclareModule\">;\nexport type FlowDeclareModuleExports = NodeAny<\"DeclareModuleExports\">;\nexport type FlowDeclareTypeAlias = NodeAny<\"DeclareTypeAlias\">;\nexport type FlowDeclareOpaqueType = NodeAny<\"DeclareOpaqueType\">;\nexport type FlowDeclareInterface = NodeAny<\"DeclareInterface\">;\nexport type FlowInterface = NodeAny<\"InterfaceDeclaration\">;\nexport type FlowInterfaceExtends = NodeAny<\"InterfaceExtends\">;\nexport type FlowTypeAlias = NodeAny<\"TypeAlias\">;\nexport type FlowOpaqueType = NodeAny<\"OpaqueType\">;\nexport type FlowObjectTypeIndexer = NodeAny<\"ObjectTypeIndexer\">;\nexport type FlowObjectTypeInternalSlot = NodeAny<\"ObjectTypeInternalSlot\">;\nexport type FlowEnumDeclaration = NodeAny<\"EnumDeclaration\">;\nexport type FlowEnumBody = NodeAny<\n  \"EnumBooleanBody\" | \"EnumNumberBody\" | \"EnumStringBody\" | \"EnumSymbolBody\"\n>;\nexport type FlowEnumMember =\n  | NodeAny<\"EnumBooleanMember\">\n  | NodeAny<\"EnumNumberMember\">\n  | NodeAny<\"EnumStringMember\">\n  | NodeAny<\"EnumDefaultedMember\">;\nexport type FlowFunctionTypeAnnotation = NodeAny<\"FunctionTypeAnnotation\">;\nexport type FlowObjectTypeProperty = NodeAny<\"ObjectTypeProperty\">;\nexport type FlowObjectTypeSpreadProperty = NodeAny<\"ObjectTypeSpreadProperty\">;\nexport type FlowObjectTypeCallProperty = NodeAny<\"ObjectTypeCallProperty\">;\nexport type FlowObjectTypeAnnotation = NodeAny<\"ObjectTypeAnnotation\">;\nexport type FlowQualifiedTypeIdentifier = NodeAny<\"QualifiedTypeIdentifier\">;\nexport type FlowGenericTypeAnnotation = NodeAny<\"GenericTypeAnnotation\">;\nexport type FlowTypeofTypeAnnotation = NodeAny<\"TypeofTypeAnnotation\">;\nexport type FlowTupleTypeAnnotation = NodeAny<\"TupleTypeAnnotation\">;\nexport type FlowFunctionTypeParam = NodeAny<\"FunctionTypeParam\">;\nexport type FlowOtherTypeAnnotation = NodeAny<\n  | \"AnyTypeAnnotation\"\n  | \"BooleanTypeAnnotation\"\n  | \"MixedTypeAnnotation\"\n  | \"EmptyTypeAnnotation\"\n  | \"ExistsTypeAnnotation\"\n  | \"NumberTypeAnnotation\"\n  | \"StringTypeAnnotation\"\n  | \"SymbolTypeAnnotation\"\n  | \"NullLiteralTypeAnnotation\"\n  | \"VoidTypeAnnotation\"\n  | \"ThisTypeAnnotation\"\n  | \"ArrayTypeAnnotation\"\n  | \"NullableTypeAnnotation\"\n  | \"IntersectionTypeAnnotation\"\n  | \"UnionTypeAnnotation\"\n>;\nexport type FlowType =\n  | FlowFunctionTypeAnnotation\n  | FlowObjectTypeAnnotation\n  | FlowGenericTypeAnnotation\n  | FlowTypeofTypeAnnotation\n  | FlowTupleTypeAnnotation\n  | FlowInterfaceType\n  | FlowIndexedAccessType\n  | FlowOptionalIndexedAccessType\n  | FlowOtherTypeAnnotation\n  | StringLiteralTypeAnnotation\n  | BooleanLiteralTypeAnnotation\n  | NumberLiteralTypeAnnotation\n  | BigIntLiteralTypeAnnotation\n  | Identifier;\nexport type FlowVariance = NodeAny<\"Variance\">;\nexport type FlowClassImplements = NodeAny<\"ClassImplements\">;\n\nexport interface FlowInterfaceType extends NodeBase {\n  type: \"InterfaceTypeAnnotation\";\n  extends: FlowInterfaceExtends[];\n  body: FlowObjectTypeAnnotation;\n}\n\nexport interface FlowIndexedAccessType extends NodeBase {\n  type: \"IndexedAccessType\";\n  objectType: FlowType;\n  indexType: FlowType;\n}\n\nexport interface FlowOptionalIndexedAccessType extends NodeBase {\n  type: \"OptionalIndexedAccessType\";\n  objectType: FlowType;\n  indexType: FlowType;\n  optional: boolean;\n}\n\nexport interface StringLiteralTypeAnnotation extends NodeBase {\n  type: \"StringLiteralTypeAnnotation\";\n  value: string;\n}\n\nexport interface BooleanLiteralTypeAnnotation extends NodeBase {\n  type: \"BooleanLiteralTypeAnnotation\";\n  value: boolean;\n}\nexport interface NumberLiteralTypeAnnotation extends NodeBase {\n  type: \"NumberLiteralTypeAnnotation\";\n  value: number;\n}\n\nexport interface BigIntLiteralTypeAnnotation extends NodeBase {\n  type: \"BigIntLiteralTypeAnnotation\";\n  //todo(flow): use bigint when Flow supports BigInt\n  value: number;\n}\n\n// ESTree\nexport interface EstreeLiteral extends NodeBase {\n  type: \"Literal\";\n  value: any;\n  decimal?: string;\n}\n\ninterface EstreeRegExpLiteralRegex {\n  pattern: string;\n  flags: string;\n}\n\nexport interface EstreeRegExpLiteral extends EstreeLiteral {\n  regex: EstreeRegExpLiteralRegex;\n}\n\nexport interface EstreeBigIntLiteral extends EstreeLiteral {\n  value: number | null;\n  bigint: string;\n}\n\nexport interface EstreeProperty extends NodeBase {\n  type: \"Property\";\n  method: boolean;\n  shorthand: boolean;\n  key: Expression | EstreePrivateIdentifier;\n  computed: boolean;\n  value: Expression;\n  decorators: Decorator[];\n  kind?: \"get\" | \"set\" | \"init\";\n  variance?: FlowVariance | null;\n}\n\ninterface EstreeMethodDefinitionBase extends NodeBase {\n  static: boolean;\n  key: Expression;\n  computed: boolean;\n  decorators: Decorator[];\n  kind?: \"get\" | \"set\" | \"method\";\n}\n\nexport interface EstreeMethodDefinition extends EstreeMethodDefinitionBase {\n  type: \"MethodDefinition\";\n  value: FunctionExpression;\n  variance?: FlowVariance | null;\n}\n\nexport interface EstreeImportExpression extends NodeBase {\n  type: \"ImportExpression\";\n  source: Expression;\n  options?: Expression | null;\n  /**\n   * @deprecated Use options instead\n   */\n  attributes?: Expression | null;\n}\n\nexport interface EstreePrivateIdentifier extends NodeBase {\n  type: \"PrivateIdentifier\";\n  name: string;\n}\n\ninterface EstreePropertyDefinitionBase extends NodeBase {\n  static: boolean;\n  key: Expression | EstreePrivateIdentifier;\n  computed: boolean;\n}\n\nexport interface EstreePropertyDefinition extends EstreePropertyDefinitionBase {\n  type: \"PropertyDefinition\";\n  value: Expression;\n}\n\nexport interface EstreeChainExpression extends NodeBase {\n  type: \"ChainExpression\";\n  expression: Expression;\n}\n\n// === === === ===\n// TypeScript\n// === === === ===\n\n// Note: A type named `TsFoo` is based on TypeScript's `FooNode` type,\n// defined in https://github.com/Microsoft/TypeScript/blob/master/src/compiler/types.ts\n// Differences:\n// * Change `NodeArray<T>` to just `$T[]`.\n// * Don't give nodes a \"modifiers\" list; use boolean flags instead,\n//   and only allow modifiers that are not considered errors.\n// * A property named `type` must be renamed to `typeAnnotation` to avoid conflict with the node's type.\n// * Sometimes TypeScript allows to parse something which will be a grammar error later;\n//   in @babel/parser these cause exceptions, so the AST format is stricter.\n\n// ================\n// Misc\n// ================\n\nexport interface TSParameterProperty extends HasDecorators {\n  // Note: This has decorators instead of its parameter.\n  type: \"TSParameterProperty\";\n  // At least one of `accessibility` or `readonly` must be set.\n  accessibility?: Accessibility | null;\n  readonly?: true | null;\n  override?: true | null;\n  parameter: Identifier | AssignmentPattern;\n}\n\nexport interface OptTSDeclareFunction extends FunctionBase, DeclarationBase {\n  type: \"TSDeclareFunction\";\n}\n\nexport interface TSDeclareFunction extends OptTSDeclareFunction {\n  id: Identifier;\n}\n\nexport interface TSDeclareMethod\n  extends FunctionBase,\n    ClassMethodOrDeclareMethodCommon {\n  type: \"TSDeclareMethod\";\n  kind: MethodKind;\n}\n\nexport interface TsQualifiedName extends NodeBase {\n  type: \"TSQualifiedName\";\n  left: TsEntityName;\n  right: Identifier;\n}\n\nexport type TsEntityName = Identifier | ThisExpression | TsQualifiedName;\n\nexport type TsSignatureDeclaration =\n  | TsCallSignatureDeclaration\n  | TsConstructSignatureDeclaration\n  | TsMethodSignature\n  | TsFunctionType\n  | TsConstructorType;\n\nexport interface TsSignatureDeclarationOrIndexSignatureBase extends NodeBase {\n  // Not using TypeScript's \"ParameterDeclaration\" here, since it's inconsistent with regular functions.\n  params: Array<Identifier | RestElement | ObjectPattern | ArrayPattern>;\n  returnType: TsTypeAnnotation | undefined | null;\n  // TODO(Babel 8): Remove\n  parameters: Array<Identifier | RestElement | ObjectPattern | ArrayPattern>;\n  typeAnnotation: TsTypeAnnotation | undefined | null;\n}\n\nexport interface TsSignatureDeclarationBase\n  extends TsSignatureDeclarationOrIndexSignatureBase {\n  typeParameters: TsTypeParameterDeclaration | undefined | null;\n}\n\n// ================\n// TypeScript type members (for type literal / interface / class)\n// ================\n\nexport type TsTypeElement =\n  | TsCallSignatureDeclaration\n  | TsConstructSignatureDeclaration\n  | TsPropertySignature\n  | TsMethodSignature\n  | TsIndexSignature;\n\nexport interface TsCallSignatureDeclaration extends TsSignatureDeclarationBase {\n  type: \"TSCallSignatureDeclaration\";\n}\n\nexport interface TsConstructSignatureDeclaration\n  extends TsSignatureDeclarationBase {\n  type: \"TSConstructSignatureDeclaration\";\n}\n\nexport interface TsNamedTypeElementBase extends NodeBase {\n  // Not using TypeScript's `PropertyName` here since we don't have a `ComputedPropertyName` node type.\n  // This is usually an Identifier but may be e.g. `Symbol.iterator` if `computed` is true.\n  key: Expression;\n  computed: boolean;\n  optional?: true;\n}\n\nexport interface TsPropertySignature extends TsNamedTypeElementBase {\n  type: \"TSPropertySignature\";\n  readonly?: true;\n  typeAnnotation?: TsTypeAnnotation;\n}\n\nexport interface TsMethodSignature\n  extends TsSignatureDeclarationBase,\n    TsNamedTypeElementBase {\n  type: \"TSMethodSignature\";\n  kind: \"method\" | \"get\" | \"set\";\n}\n\n// *Not* a ClassMemberBase: Can't have accessibility, can't be abstract, can't be optional.\nexport interface TsIndexSignature\n  extends TsSignatureDeclarationOrIndexSignatureBase {\n  readonly?: true;\n  static?: true;\n  type: \"TSIndexSignature\";\n  // Note: parameters.length must be 1.\n}\n\nexport interface EstreeTSEmptyBodyFunctionExpression extends NodeBase {\n  type: \"TSEmptyBodyFunctionExpression\";\n}\n\nexport interface EstreeTSAbstractMethodDefinition\n  extends EstreeMethodDefinitionBase {\n  type: \"TSAbstractMethodDefinition\";\n  value: EstreeTSEmptyBodyFunctionExpression;\n}\n\nexport interface EstreeTSAbstractPropertyDefinition\n  extends EstreePropertyDefinitionBase {\n  type: \"TSAbstractPropertyDefinition\";\n  value: null;\n}\n\n// ================\n// TypeScript types\n// ================\n\nexport type TsType =\n  | TsKeywordType\n  | TsThisType\n  | TsFunctionOrConstructorType\n  | TsTypeReference\n  | TsTypeQuery\n  | TsTypeLiteral\n  | TsArrayType\n  | TsTupleType\n  | TsOptionalType\n  | TsRestType\n  | TsUnionOrIntersectionType\n  | TsConditionalType\n  | TsInferType\n  | TsParenthesizedType\n  | TsTypeOperator\n  | TsIndexedAccessType\n  | TsMappedType\n  | TsLiteralType // TODO: This probably shouldn't be included here.\n  | TsTemplateLiteralType\n  | TsImportType\n  | TsTypePredicate;\n\nexport type TsTypeBase = NodeBase;\n\nexport type TsKeywordTypeType =\n  | \"TSAnyKeyword\"\n  | \"TSUnknownKeyword\"\n  | \"TSNumberKeyword\"\n  | \"TSObjectKeyword\"\n  | \"TSBooleanKeyword\"\n  | \"TSBigIntKeyword\"\n  | \"TSStringKeyword\"\n  | \"TSSymbolKeyword\"\n  | \"TSVoidKeyword\"\n  | \"TSUndefinedKeyword\"\n  | \"TSNullKeyword\"\n  | \"TSNeverKeyword\"\n  | \"TSIntrinsicKeyword\";\nexport interface TsKeywordType extends TsTypeBase {\n  type: TsKeywordTypeType;\n}\n\nexport interface TsThisType extends TsTypeBase {\n  type: \"TSThisType\";\n}\n\nexport type TsFunctionOrConstructorType = TsFunctionType | TsConstructorType;\n\nexport interface TsFunctionType extends TsTypeBase, TsSignatureDeclarationBase {\n  type: \"TSFunctionType\";\n  typeAnnotation: TsTypeAnnotation; // not optional\n}\n\nexport interface TsConstructorType\n  extends TsTypeBase,\n    TsSignatureDeclarationBase {\n  type: \"TSConstructorType\";\n  typeAnnotation: TsTypeAnnotation;\n  abstract: boolean;\n}\n\nexport interface TsTypeReference extends TsTypeBase {\n  type: \"TSTypeReference\";\n  typeName: TsEntityName;\n  typeArguments?: TsTypeParameterInstantiation;\n  /**\n   * @deprecated\n   */\n  typeParameters?: TsTypeParameterInstantiation;\n}\n\nexport interface TsTypePredicate extends TsTypeBase {\n  type: \"TSTypePredicate\";\n  parameterName: Identifier | TsThisType;\n  typeAnnotation: TsTypeAnnotation | null;\n  asserts: boolean;\n}\n\n// `typeof` operator\nexport interface TsTypeQuery extends TsTypeBase {\n  type: \"TSTypeQuery\";\n  exprName: TsEntityName | TsImportType;\n  typeArguments?: TsTypeParameterInstantiation;\n  /**\n   * @deprecated\n   */\n  typeParameters?: TsTypeParameterInstantiation;\n}\n\nexport interface TsTypeLiteral extends TsTypeBase {\n  type: \"TSTypeLiteral\";\n  members: TsTypeElement[];\n}\n\nexport interface TsArrayType extends TsTypeBase {\n  type: \"TSArrayType\";\n  elementType: TsType;\n}\n\nexport interface TsTupleType extends TsTypeBase {\n  type: \"TSTupleType\";\n  elementTypes: Array<TsType | TsNamedTupleMember>;\n}\n\nexport interface TsNamedTupleMember extends TsTypeBase {\n  type: \"TSNamedTupleMember\";\n  label: Identifier;\n  optional: boolean;\n  elementType: TsType;\n}\n\nexport interface TsOptionalType extends TsTypeBase {\n  type: \"TSOptionalType\";\n  typeAnnotation: TsType;\n}\n\nexport interface TsRestType extends TsTypeBase {\n  type: \"TSRestType\";\n  typeAnnotation: TsType | TsNamedTupleMember;\n}\n\nexport type TsUnionOrIntersectionType = TsUnionType | TsIntersectionType;\n\nexport interface TsUnionOrIntersectionTypeBase extends TsTypeBase {\n  types: TsType[];\n}\n\nexport interface TsUnionType extends TsUnionOrIntersectionTypeBase {\n  type: \"TSUnionType\";\n}\n\nexport interface TsIntersectionType extends TsUnionOrIntersectionTypeBase {\n  type: \"TSIntersectionType\";\n}\n\nexport interface TsConditionalType extends TsTypeBase {\n  type: \"TSConditionalType\";\n  checkType: TsType;\n  extendsType: TsType;\n  trueType: TsType;\n  falseType: TsType;\n}\n\nexport interface TsInferType extends TsTypeBase {\n  type: \"TSInferType\";\n  typeParameter: TsTypeParameter;\n}\n\nexport interface TsParenthesizedType extends TsTypeBase {\n  type: \"TSParenthesizedType\";\n  typeAnnotation: TsType;\n}\n\nexport interface TsTypeOperator extends TsTypeBase {\n  type: \"TSTypeOperator\";\n  operator: \"keyof\" | \"unique\" | \"readonly\";\n  typeAnnotation: TsType;\n}\n\nexport interface TsIndexedAccessType extends TsTypeBase {\n  type: \"TSIndexedAccessType\";\n  objectType: TsType;\n  indexType: TsType;\n}\n\nexport interface TsMappedType extends TsTypeBase {\n  type: \"TSMappedType\";\n  key: Identifier;\n  constraint: TsType;\n  readonly?: true | \"+\" | \"-\";\n  optional?: true | \"+\" | \"-\";\n  typeAnnotation: TsType | undefined | null;\n  nameType: TsType | undefined | null;\n}\n\nexport interface TsTemplateLiteralType extends TsTypeBase {\n  type: \"TSTemplateLiteralType\";\n  quasis: TemplateElement[];\n  types: TsType[];\n}\n\nexport interface TsLiteralType extends TsTypeBase {\n  type: \"TSLiteralType\";\n  literal: NumericLiteral | StringLiteral | BooleanLiteral | TemplateLiteral;\n}\n\nexport interface TsImportType extends TsTypeBase {\n  type: \"TSImportType\";\n  argument: TsLiteralType;\n  qualifier?: TsEntityName;\n  typeArguments?: TsTypeParameterInstantiation;\n  /**\n   * @deprecated\n   */\n  typeParameters?: TsTypeParameterInstantiation;\n  options?: Expression | null;\n}\n\n// ================\n// TypeScript declarations\n// ================\n\nexport interface TsInterfaceDeclaration extends DeclarationBase {\n  type: \"TSInterfaceDeclaration\";\n  id: Identifier | undefined | null;\n  typeParameters: TsTypeParameterDeclaration | undefined | null;\n  extends?: TSInterfaceHeritage[];\n  body: TSInterfaceBody;\n}\n\nexport interface TSInterfaceBody extends NodeBase {\n  type: \"TSInterfaceBody\";\n  body: TsTypeElement[];\n}\n\nexport interface TSHeritageBase extends NodeBase {\n  expression: Expression;\n  typeArguments?: TsTypeParameterInstantiation;\n}\n\nexport interface TSClassImplements extends TSHeritageBase {\n  type: \"TSClassImplements\";\n}\n\nexport interface TSInterfaceHeritage extends TSHeritageBase {\n  type: \"TSInterfaceHeritage\";\n}\n\nexport interface TsTypeAliasDeclaration extends DeclarationBase {\n  type: \"TSTypeAliasDeclaration\";\n  id: Identifier;\n  typeParameters: TsTypeParameterDeclaration | undefined | null;\n  typeAnnotation: TsType;\n}\n\nexport interface TsEnumDeclaration extends DeclarationBase {\n  type: \"TSEnumDeclaration\";\n  const?: true;\n  id: Identifier;\n  body: TsEnumBody;\n  /**\n   * @deprecated\n   */\n  members?: TsEnumMember[];\n}\n\nexport interface TsEnumBody extends NodeBase {\n  type: \"TSEnumBody\";\n  members: TsEnumMember[];\n}\n\nexport interface TsEnumMember extends NodeBase {\n  type: \"TSEnumMember\";\n  id: Identifier | StringLiteral;\n  initializer?: Expression;\n}\n\nexport interface TsModuleDeclaration extends DeclarationBase {\n  type: \"TSModuleDeclaration\";\n  kind: \"global\" | \"module\" | \"namespace\";\n  global?: true; // In TypeScript, this is only available through `node.flags`.,\n  id: TsModuleName;\n  body: TsNamespaceBody;\n}\n\n// `namespace A.B { }` is a namespace named `A` with another TsNamespaceDeclaration as its body.\nexport type TsNamespaceBody = TsModuleBlock | TsNamespaceDeclaration;\n\nexport interface TsModuleBlock extends NodeBase {\n  type: \"TSModuleBlock\";\n  body: Statement[];\n}\n\nexport interface TsNamespaceDeclaration extends TsModuleDeclaration {\n  id: Identifier;\n  body: TsNamespaceBody;\n}\n\nexport type TsModuleName = TsEntityName | StringLiteral;\n\nexport interface TsImportEqualsDeclaration extends NodeBase {\n  type: \"TSImportEqualsDeclaration\";\n  id: Identifier;\n  importKind: \"type\" | \"value\";\n  moduleReference: TsModuleReference;\n  /** @deprecated */\n  isExport: boolean;\n}\n\nexport type TsModuleReference = TsEntityName | TsExternalModuleReference;\n\nexport interface TsExternalModuleReference extends NodeBase {\n  type: \"TSExternalModuleReference\";\n  expression: StringLiteral;\n}\n\n// TypeScript's own parser uses ExportAssignment for both `export default` and `export =`.\n// But for @babel/parser, `export default` is an ExportDefaultDeclaration,\n// so a TsExportAssignment is always `export =`.\nexport interface TsExportAssignment extends NodeBase {\n  type: \"TSExportAssignment\";\n  expression: Expression;\n}\n\nexport interface TsNamespaceExportDeclaration extends NodeBase {\n  type: \"TSNamespaceExportDeclaration\";\n  id: Identifier;\n}\n\n// ================\n// TypeScript expressions\n// ================\n\nexport interface TsTypeAssertionLikeBase extends NodeBase {\n  expression: Expression;\n  typeAnnotation: TsType;\n}\n\nexport interface TsAsExpression extends TsTypeAssertionLikeBase {\n  type: \"TSAsExpression\";\n}\n\nexport interface TsTypeAssertion extends TsTypeAssertionLikeBase {\n  type: \"TSTypeAssertion\";\n}\n\nexport type TsSatisfiesExpression = TsTypeAssertionLikeBase & {\n  type: \"TSSatisfiesExpression\";\n};\n\nexport interface TsNonNullExpression extends NodeBase {\n  type: \"TSNonNullExpression\";\n  expression: Expression;\n}\n\nexport interface TsInstantiationExpression extends NodeBase {\n  type: \"TSInstantiationExpression\";\n  expression: Expression;\n  typeArguments?: TsTypeParameterInstantiation;\n  /**\n   * @deprecated\n   */\n  typeParameters?: TsTypeParameterInstantiation;\n}\n\n// ================\n// Babel placeholders %%foo%%\n// ================\n\nexport interface Placeholder<N extends PlaceholderTypes = PlaceholderTypes>\n  extends NodeBase {\n  type: \"Placeholder\";\n  name: Identifier;\n  expectedNode: N;\n}\n\n// ================\n// Other\n// ================\n\nexport interface ParseSubscriptState {\n  optionalChainMember: boolean;\n  maybeAsyncArrow: boolean;\n  stop: boolean;\n}\n\nexport interface ParseClassMemberState {\n  hadConstructor: boolean;\n  hadSuperClass: boolean;\n}\n\nexport type Node =\n  | ArgumentPlaceholder\n  | ArrayExpression\n  | ArrayPattern\n  | ArrowFunctionExpression\n  | AssignmentExpression\n  | AssignmentPattern\n  | AwaitExpression\n  | BigIntLiteral\n  | BigIntLiteralTypeAnnotation\n  | BinaryExpression\n  | BindExpression\n  | BlockStatement\n  | BooleanLiteral\n  | BooleanLiteralTypeAnnotation\n  | BreakStatement\n  | CallExpression\n  | CatchClause\n  | ClassAccessorProperty\n  | ClassBody\n  | ClassDeclaration\n  | ClassExpression\n  | ClassMethod\n  | ClassPrivateMethod\n  | ClassPrivateProperty\n  | ClassProperty\n  | ConditionalExpression\n  | ContinueStatement\n  | DebuggerStatement\n  | DecimalLiteral\n  | Decorator\n  | Directive\n  | DirectiveLiteral\n  | DoExpression\n  | DoWhileStatement\n  | EmptyStatement\n  | EstreeChainExpression\n  | EstreeLiteral\n  | EstreeMethodDefinition\n  | EstreePrivateIdentifier\n  | EstreeProperty\n  | EstreePropertyDefinition\n  | EstreeTSAbstractMethodDefinition\n  | EstreeTSAbstractPropertyDefinition\n  | EstreeTSEmptyBodyFunctionExpression\n  | ExportAllDeclaration\n  | ExportDefaultDeclaration\n  | ExportDefaultSpecifier\n  | ExportNamedDeclaration\n  | ExportNamespaceSpecifier\n  | ExportSpecifier\n  | ExpressionStatement\n  | File\n  | FlowClassImplements\n  | FlowDeclareClass\n  | FlowDeclareExportDeclaration\n  | FlowDeclareFunction\n  | FlowDeclareInterface\n  | FlowDeclareModule\n  | FlowDeclareModuleExports\n  | FlowDeclareOpaqueType\n  | FlowDeclareTypeAlias\n  | FlowDeclareVariable\n  | FlowEnumBody\n  | FlowEnumDeclaration\n  | FlowEnumMember\n  | FlowFunctionTypeAnnotation\n  | FlowFunctionTypeParam\n  | FlowGenericTypeAnnotation\n  | FlowIndexedAccessType\n  | FlowInterface\n  | FlowInterfaceExtends\n  | FlowInterfaceType\n  | FlowObjectTypeAnnotation\n  | FlowObjectTypeCallProperty\n  | FlowObjectTypeIndexer\n  | FlowObjectTypeInternalSlot\n  | FlowObjectTypeProperty\n  | FlowObjectTypeSpreadProperty\n  | FlowOpaqueType\n  | FlowOptionalIndexedAccessType\n  | FlowOtherTypeAnnotation\n  | FlowPredicate\n  | FlowPredicate\n  | FlowQualifiedTypeIdentifier\n  | FlowTupleTypeAnnotation\n  | FlowTypeAlias\n  | FlowTypeofTypeAnnotation\n  | FlowVariance\n  | ForInStatement\n  | ForOfStatement\n  | ForStatement\n  | FunctionDeclaration\n  | FunctionExpression\n  | Identifier\n  | IfStatement\n  | Import\n  | ImportAttribute\n  | ImportDeclaration\n  | ImportDefaultSpecifier\n  | ImportExpression\n  | ImportExpression\n  | ImportNamespaceSpecifier\n  | ImportSpecifier\n  | InterpreterDirective\n  | JSXAttribute\n  | JSXPropShorthandAttribute\n  | JSXClosingElement\n  | JSXClosingFragment\n  | JSXElement\n  | JSXEmptyExpression\n  | JSXExpressionContainer\n  | JSXFragment\n  | JSXIdentifier\n  | JSXMemberExpression\n  | JSXNamespacedName\n  | JSXOpeningElement\n  | JSXOpeningFragment\n  | JSXSpreadAttribute\n  | JSXSpreadChild\n  | JSXText\n  | LabeledStatement\n  | Literal\n  | LogicalExpression\n  | MemberExpression\n  | MetaProperty\n  | ModuleExpression\n  | NewExpression\n  | NullLiteral\n  | NumberLiteralTypeAnnotation\n  | NumericLiteral\n  | ObjectExpression\n  | ObjectMethod\n  | ObjectPattern\n  | ObjectProperty\n  | OptionalCallExpression\n  | OptionalMemberExpression\n  | ParenthesizedExpression\n  | PipelineBareAwaitedFunctionBody\n  | PipelineBareConstructorBody\n  | PipelineBareFunction\n  | PipelineBareFunctionBody\n  | PipelineBody\n  | PipelinePrimaryTopicReference\n  | PipelineTopicBody\n  | PipelineTopicExpression\n  | Placeholder\n  | PrivateName\n  | Program\n  | RecordExpression\n  | RegExpLiteral\n  | RestElement\n  | ReturnStatement\n  | SequenceExpression\n  | SpreadElement\n  | StaticBlock\n  | StringLiteral\n  | StringLiteralTypeAnnotation\n  | Super\n  | SwitchCase\n  | SwitchStatement\n  | TSDeclareFunction\n  | TSDeclareMethod\n  | TSInterfaceBody\n  | TSParameterProperty\n  | TaggedTemplateExpression\n  | TemplateElement\n  | TemplateLiteral\n  | ThisExpression\n  | ThrowStatement\n  | TopicReference\n  | TryStatement\n  | TsArrayType\n  | TsAsExpression\n  | TsCallSignatureDeclaration\n  | TsConditionalType\n  | TsConstructSignatureDeclaration\n  | TsConstructorType\n  | TsEnumDeclaration\n  | TsEnumBody\n  | TsEnumMember\n  | TsExportAssignment\n  | TSClassImplements\n  | TSInterfaceHeritage\n  | TsExternalModuleReference\n  | TsFunctionType\n  | TsImportEqualsDeclaration\n  | TsImportType\n  | TsIndexSignature\n  | TsIndexedAccessType\n  | TsInferType\n  | TsInstantiationExpression\n  | TsInterfaceDeclaration\n  | TsIntersectionType\n  | TsKeywordType\n  | TsLiteralType\n  | TsMappedType\n  | TsMethodSignature\n  | TsModuleBlock\n  | TsModuleDeclaration\n  | TsNamedTupleMember\n  | TsNamespaceExportDeclaration\n  | TsNonNullExpression\n  | TsOptionalType\n  | TsParenthesizedType\n  | TsPropertySignature\n  | TsQualifiedName\n  | TsRestType\n  | TsSatisfiesExpression\n  | TsTemplateLiteralType\n  | TsThisType\n  | TsTupleType\n  | TsTypeAliasDeclaration\n  | TsTypeAnnotation\n  | TsTypeAssertion\n  | TsTypeCastExpression\n  | TsTypeLiteral\n  | TsTypeOperator\n  | TsTypeParameter\n  | TsTypeParameterDeclaration\n  | TsTypeParameterInstantiation\n  | TsTypePredicate\n  | TsTypeQuery\n  | TsTypeReference\n  | TsUnionType\n  | TupleExpression\n  | TypeAnnotation\n  | TypeCastExpression\n  | TypeParameter\n  | TypeParameterDeclaration\n  | TypeParameterInstantiation\n  | UnaryExpression\n  | UpdateExpression\n  | VariableDeclaration\n  | VariableDeclarator\n  | WhileStatement\n  | WithStatement\n  | YieldExpression;\n"],"mappings":"","ignoreList":[]}