{"version":3,"names":["_location","require","_moduleErrors","_standardErrors","_strictModeErrors","_pipelineOperatorErrors","_excluded","_objectWithoutPropertiesLoose","r","e","t","n","hasOwnProperty","call","indexOf","defineHidden","obj","key","value","Object","defineProperty","enumerable","configurable","toParseErrorConstructor","toMessage","code","reasonCode","syntaxPlugin","hasMissingPlugin","process","env","BABEL_8_BREAKING","oldReasonCodes","AccessorCannotDeclareThisParameter","AccessorCannotHaveTypeParameters","ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference","SetAccessorCannotHaveOptionalParameter","SetAccessorCannotHaveRestParameter","SetAccessorCannotHaveReturnType","constructor","loc","details","error","SyntaxError","pos","index","missingPlugin","clone","overrides","line","column","Position","assign","get","message","set","writable","ParseErrorEnum","argument","Array","isArray","parseErrorTemplates","ParseErrorConstructors","keys","template","_ref","rest","Errors","exports","ModuleErrors","StandardErrors","StrictModeErrors","PipelineOperatorErrors"],"sources":["../src/parse-error.ts"],"sourcesContent":["import { Position } from \"./util/location.ts\";\n\ntype SyntaxPlugin =\n  | \"flow\"\n  | \"typescript\"\n  | \"jsx\"\n  | \"pipelineOperator\"\n  | \"placeholders\";\n\ntype ParseErrorCode =\n  | \"BABEL_PARSER_SYNTAX_ERROR\"\n  | \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\";\n\n// Babel uses \"normal\" SyntaxErrors for it's errors, but adds some extra\n// functionality. This functionality is defined in the\n// `ParseErrorSpecification` interface below. We may choose to change to someday\n// give our errors their own full-blown class, but until then this allow us to\n// keep all the desirable properties of SyntaxErrors (like their name in stack\n// traces, etc.), and also allows us to punt on any publicly facing\n// class-hierarchy decisions until Babel 8.\ninterface ParseErrorSpecification<ErrorDetails> {\n  // Look, these *could* be readonly, but then Flow complains when we initially\n  // set them. We could do a whole dance and make a special interface that's not\n  // readonly for when we create the error, then cast it to the readonly\n  // interface for public use, but the previous implementation didn't have them\n  // as readonly, so let's just not worry about it for now.\n  code: ParseErrorCode;\n  reasonCode: string;\n  syntaxPlugin?: SyntaxPlugin;\n  missingPlugin?: string | string[];\n  loc: Position;\n  details: ErrorDetails;\n\n  // We should consider removing this as it now just contains the same\n  // information as `loc.index`.\n  pos: number;\n}\n\nexport type ParseError<ErrorDetails> = SyntaxError &\n  ParseErrorSpecification<ErrorDetails>;\n\n// By `ParseErrorConstructor`, we mean something like the new-less style\n// `ErrorConstructor`[1], since `ParseError`'s are not themselves actually\n// separate classes from `SyntaxError`'s.\n//\n// 1. https://github.com/microsoft/TypeScript/blob/v4.5.5/lib/lib.es5.d.ts#L1027\nexport type ParseErrorConstructor<ErrorDetails> = (\n  loc: Position,\n  details: ErrorDetails,\n) => ParseError<ErrorDetails>;\n\ntype ToMessage<ErrorDetails> = (self: ErrorDetails) => string;\n\ntype ParseErrorCredentials<ErrorDetails> = {\n  code: string;\n  reasonCode: string;\n  syntaxPlugin?: SyntaxPlugin;\n  toMessage: ToMessage<ErrorDetails>;\n};\n\nfunction defineHidden(obj: object, key: string, value: unknown) {\n  Object.defineProperty(obj, key, {\n    enumerable: false,\n    configurable: true,\n    value,\n  });\n}\n\nfunction toParseErrorConstructor<ErrorDetails extends object>({\n  toMessage,\n  code,\n  reasonCode,\n  syntaxPlugin,\n}: ParseErrorCredentials<ErrorDetails>): ParseErrorConstructor<ErrorDetails> {\n  const hasMissingPlugin =\n    reasonCode === \"MissingPlugin\" || reasonCode === \"MissingOneOfPlugins\";\n\n  if (!process.env.BABEL_8_BREAKING) {\n    const oldReasonCodes: Record<string, string> = {\n      AccessorCannotDeclareThisParameter: \"AccesorCannotDeclareThisParameter\",\n      AccessorCannotHaveTypeParameters: \"AccesorCannotHaveTypeParameters\",\n      ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference:\n        \"ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference\",\n      SetAccessorCannotHaveOptionalParameter:\n        \"SetAccesorCannotHaveOptionalParameter\",\n      SetAccessorCannotHaveRestParameter: \"SetAccesorCannotHaveRestParameter\",\n      SetAccessorCannotHaveReturnType: \"SetAccesorCannotHaveReturnType\",\n    };\n    if (oldReasonCodes[reasonCode]) {\n      reasonCode = oldReasonCodes[reasonCode];\n    }\n  }\n\n  return function constructor(loc: Position, details: ErrorDetails) {\n    const error: ParseError<ErrorDetails> = new SyntaxError() as any;\n\n    error.code = code as ParseErrorCode;\n    error.reasonCode = reasonCode;\n    error.loc = loc;\n    error.pos = loc.index;\n\n    error.syntaxPlugin = syntaxPlugin;\n    if (hasMissingPlugin) {\n      error.missingPlugin = (details as any).missingPlugin;\n    }\n\n    type Overrides = {\n      loc?: Position;\n      details?: ErrorDetails;\n    };\n    defineHidden(error, \"clone\", function clone(overrides: Overrides = {}) {\n      const { line, column, index } = overrides.loc ?? loc;\n      return constructor(new Position(line, column, index), {\n        ...details,\n        ...overrides.details,\n      });\n    });\n\n    defineHidden(error, \"details\", details);\n\n    Object.defineProperty(error, \"message\", {\n      configurable: true,\n      get(this: ParseError<ErrorDetails>): string {\n        const message = `${toMessage(details)} (${loc.line}:${loc.column})`;\n        this.message = message;\n        return message;\n      },\n      set(value: string) {\n        Object.defineProperty(this, \"message\", { value, writable: true });\n      },\n    });\n\n    return error;\n  };\n}\n\ntype ParseErrorTemplate =\n  | string\n  | ToMessage<any>\n  | { message: string | ToMessage<any>; code?: ParseErrorCode };\n\nexport type ParseErrorTemplates = { [reasonCode: string]: ParseErrorTemplate };\n\n// This is the templated form of `ParseErrorEnum`.\n//\n// Note: We could factor out the return type calculation into something like\n// `ParseErrorConstructor<T extends ParseErrorTemplates>`, and then we could\n// reuse it in the non-templated form of `ParseErrorEnum`, but TypeScript\n// doesn't seem to drill down that far when showing you the computed type of\n// an object in an editor, so we'll leave it inlined for now.\nexport function ParseErrorEnum(a: TemplateStringsArray): <\n  T extends ParseErrorTemplates,\n>(\n  parseErrorTemplates: T,\n) => {\n  [K in keyof T]: ParseErrorConstructor<\n    T[K] extends { message: string | ToMessage<any> }\n      ? T[K][\"message\"] extends ToMessage<any>\n        ? Parameters<T[K][\"message\"]>[0]\n        : object\n      : T[K] extends ToMessage<any>\n        ? Parameters<T[K]>[0]\n        : object\n  >;\n};\n\nexport function ParseErrorEnum<T extends ParseErrorTemplates>(\n  parseErrorTemplates: T,\n  syntaxPlugin?: SyntaxPlugin,\n): {\n  [K in keyof T]: ParseErrorConstructor<\n    T[K] extends { message: string | ToMessage<any> }\n      ? T[K][\"message\"] extends ToMessage<any>\n        ? Parameters<T[K][\"message\"]>[0]\n        : object\n      : T[K] extends ToMessage<any>\n        ? Parameters<T[K]>[0]\n        : object\n  >;\n};\n\n// You call `ParseErrorEnum` with a mapping from `ReasonCode`'s to either:\n//\n// 1. a static error message,\n// 2. `toMessage` functions that define additional necessary `details` needed by\n//    the `ParseError`, or\n// 3. Objects that contain a `message` of one of the above and overridden `code`\n//    and/or `reasonCode`:\n//\n// ParseErrorEnum `optionalSyntaxPlugin` ({\n//   ErrorWithStaticMessage: \"message\",\n//   ErrorWithDynamicMessage: ({ type } : { type: string }) => `${type}`),\n//   ErrorWithOverriddenCodeAndOrReasonCode: {\n//     message: ({ type }: { type: string }) => `${type}`),\n//     code: \"AN_ERROR_CODE\",\n//     ...(BABEL_8_BREAKING ? { } : { reasonCode: \"CustomErrorReasonCode\" })\n//   }\n// });\n//\nexport function ParseErrorEnum(\n  argument: TemplateStringsArray | ParseErrorTemplates,\n  syntaxPlugin?: SyntaxPlugin,\n) {\n  // If the first parameter is an array, that means we were called with a tagged\n  // template literal. Extract the syntaxPlugin from this, and call again in\n  // the \"normalized\" form.\n  if (Array.isArray(argument)) {\n    return (parseErrorTemplates: ParseErrorTemplates) =>\n      ParseErrorEnum(parseErrorTemplates, argument[0]);\n  }\n\n  const ParseErrorConstructors = {} as Record<\n    string,\n    ParseErrorConstructor<unknown>\n  >;\n\n  for (const reasonCode of Object.keys(argument)) {\n    const template = (argument as ParseErrorTemplates)[reasonCode];\n    const { message, ...rest } =\n      typeof template === \"string\"\n        ? { message: () => template }\n        : typeof template === \"function\"\n          ? { message: template }\n          : template;\n    const toMessage = typeof message === \"string\" ? () => message : message;\n\n    ParseErrorConstructors[reasonCode] = toParseErrorConstructor({\n      code: \"BABEL_PARSER_SYNTAX_ERROR\",\n      reasonCode,\n      toMessage,\n      ...(syntaxPlugin ? { syntaxPlugin } : {}),\n      ...rest,\n    });\n  }\n\n  return ParseErrorConstructors;\n}\n\nimport ModuleErrors from \"./parse-error/module-errors.ts\";\nimport StandardErrors from \"./parse-error/standard-errors.ts\";\nimport StrictModeErrors from \"./parse-error/strict-mode-errors.ts\";\nimport PipelineOperatorErrors from \"./parse-error/pipeline-operator-errors.ts\";\n\nexport const Errors = {\n  ...ParseErrorEnum(ModuleErrors),\n  ...ParseErrorEnum(StandardErrors),\n  ...ParseErrorEnum(StrictModeErrors),\n  ...ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors),\n};\n\nexport type { LValAncestor } from \"./parse-error/standard-errors.ts\";\n"],"mappings":"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","ignoreList":[]}