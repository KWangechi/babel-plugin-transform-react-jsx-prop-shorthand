{"version":3,"names":["_pluginUtils","require","_index","_types","parse","input","options","sourceType","Object","assign","parser","getParser","ast","sawUnambiguousESM","ambiguousScriptDifferentAst","program","moduleError","parseExpression","strictMode","state","strict","getExpression","generateExportedTokenTypes","internalTokenTypes","tokenTypes","typeName","keys","getExportedToken","tokTypes","exports","cls","Parser","pluginsMap","Map","plugins","plugin","name","opts","has","set","validatePlugins","getParserClass","parserClassCache","pluginList","mixinPluginNames","push","key","join","get","mixinPlugins"],"sources":["../src/index.ts"],"sourcesContent":["import type { Options } from \"./options.ts\";\nimport {\n  validatePlugins,\n  mixinPluginNames,\n  mixinPlugins,\n} from \"./plugin-utils.ts\";\nexport type {\n  PluginConfig as ParserPlugin,\n  DecoratorsPluginOptions,\n  FlowPluginOptions,\n  PipelineOperatorPluginOptions,\n  RecordAndTuplePluginOptions,\n  TypeScriptPluginOptions,\n} from \"./typings.ts\";\nimport Parser, { type PluginsMap } from \"./parser/index.ts\";\n\nimport type { ExportedTokenType } from \"./tokenizer/types.ts\";\nimport {\n  getExportedToken,\n  tt as internalTokenTypes,\n  type InternalTokenTypes,\n} from \"./tokenizer/types.ts\";\nexport type { Token } from \"./tokenizer/index.ts\";\n\n// TODO: Rather than type-casting the internal AST definitions to the\n// @babel/types one, we should actually unify them.\nimport type { Expression, File } from \"@babel/types\";\nexport type { Expression, File };\n\nexport type ParserOptions = Partial<Options>;\n\nexport interface ParseError {\n  code: string;\n  reasonCode: string;\n}\nexport type ParseResult<Result extends File | Expression = File> = Result & {\n  errors: null | ParseError[];\n};\n\n/**\n * Parse the provided code as an entire ECMAScript program.\n */\nexport function parse(\n  input: string,\n  options?: ParserOptions,\n): ParseResult<File> {\n  if (options?.sourceType === \"unambiguous\") {\n    options = {\n      ...options,\n    };\n    try {\n      options.sourceType = \"module\";\n      const parser = getParser(options, input);\n      const ast = parser.parse();\n\n      if (parser.sawUnambiguousESM) {\n        return ast as unknown as ParseResult<File>;\n      }\n\n      if (parser.ambiguousScriptDifferentAst) {\n        // Top level await introduces code which can be both a valid script and\n        // a valid module, but which produces different ASTs:\n        //    await\n        //    0\n        // can be parsed either as an AwaitExpression, or as two ExpressionStatements.\n        try {\n          options.sourceType = \"script\";\n          return getParser(\n            options,\n            input,\n          ).parse() as unknown as ParseResult<File>;\n        } catch {}\n      } else {\n        // This is both a valid module and a valid script, but\n        // we parse it as a script by default\n        ast.program.sourceType = \"script\";\n      }\n\n      return ast as unknown as ParseResult<File>;\n    } catch (moduleError) {\n      try {\n        options.sourceType = \"script\";\n        return getParser(\n          options,\n          input,\n        ).parse() as unknown as ParseResult<File>;\n      } catch {}\n\n      throw moduleError;\n    }\n  } else {\n    return getParser(options, input).parse() as unknown as ParseResult<File>;\n  }\n}\n\nexport function parseExpression(\n  input: string,\n  options?: ParserOptions,\n): ParseResult<Expression> {\n  const parser = getParser(options, input);\n  if (parser.options.strictMode) {\n    parser.state.strict = true;\n  }\n  return parser.getExpression() as unknown as ParseResult<Expression>;\n}\n\nfunction generateExportedTokenTypes(\n  internalTokenTypes: InternalTokenTypes,\n): Record<string, ExportedTokenType> {\n  const tokenTypes: Record<string, ExportedTokenType> = {};\n  for (const typeName of Object.keys(\n    internalTokenTypes,\n  ) as (keyof InternalTokenTypes)[]) {\n    tokenTypes[typeName] = getExportedToken(internalTokenTypes[typeName]);\n  }\n  return tokenTypes;\n}\n\nexport const tokTypes = generateExportedTokenTypes(internalTokenTypes);\n\nfunction getParser(options: Options | undefined | null, input: string): Parser {\n  let cls = Parser;\n  const pluginsMap: PluginsMap = new Map();\n  if (options?.plugins) {\n    for (const plugin of options.plugins) {\n      let name, opts;\n      if (typeof plugin === \"string\") {\n        name = plugin;\n      } else {\n        [name, opts] = plugin;\n      }\n      if (!pluginsMap.has(name)) {\n        pluginsMap.set(name, opts || {});\n      }\n    }\n    validatePlugins(pluginsMap);\n    cls = getParserClass(pluginsMap);\n  }\n\n  return new cls(options, input, pluginsMap);\n}\n\nconst parserClassCache = new Map<string, new (...args: any) => Parser>();\n\n/** Get a Parser class with plugins applied. */\nfunction getParserClass(\n  pluginsMap: Map<string, any>,\n): new (...args: any) => Parser {\n  const pluginList = [];\n  for (const name of mixinPluginNames) {\n    if (pluginsMap.has(name)) {\n      pluginList.push(name);\n    }\n  }\n  const key = pluginList.join(\"|\");\n  let cls = parserClassCache.get(key);\n  if (!cls) {\n    cls = Parser;\n    for (const plugin of pluginList) {\n      // @ts-expect-error todo(flow->ts)\n      cls = mixinPlugins[plugin](cls);\n    }\n    parserClassCache.set(key, cls);\n  }\n  return cls;\n}\n"],"mappings":"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","ignoreList":[]}