{"version":3,"names":["_scopeflags","require","_parseError","NameType","exports","Var","Lexical","Function","Scope","flags","names","Map","firstLexicalName","constructor","ScopeHandler","parser","scopeStack","inModule","undefinedExports","inTopLevel","currentScope","ScopeFlag","PROGRAM","inFunction","currentVarScopeFlags","FUNCTION","allowSuper","currentThisScopeFlags","SUPER","allowDirectSuper","DIRECT_SUPER","inClass","CLASS","inClassAndNotInNonArrowFunction","inStaticBlock","i","length","STATIC_BLOCK","VAR","inNonArrowFunction","treatFunctionsAsVar","treatFunctionsAsVarInScope","createScope","enter","push","exit","scope","pop","declareName","name","bindingType","loc","BindingFlag","SCOPE_LEXICAL","SCOPE_FUNCTION","checkRedeclarationInScope","type","get","set","maybeExportDefined","SCOPE_VAR","delete","isRedeclaredInScope","raise","Errors","VarRedeclaration","identifierName","KIND_VALUE","has","SIMPLE_CATCH","checkLocalExport","id","topLevelScope","start","ARROW","default"],"sources":["../../src/util/scope.ts"],"sourcesContent":["import { ScopeFlag, BindingFlag } from \"./scopeflags.ts\";\nimport type { Position } from \"./location.ts\";\nimport type * as N from \"../types.ts\";\nimport { Errors } from \"../parse-error.ts\";\nimport type Tokenizer from \"../tokenizer/index.ts\";\n\nexport const enum NameType {\n  // var-declared names in the current lexical scope\n  Var = 1 << 0,\n  // lexically-declared names in the current lexical scope\n  Lexical = 1 << 1,\n  // lexically-declared FunctionDeclaration names in the current lexical scope\n  Function = 1 << 2,\n}\n\n// Start an AST node, attaching a start offset.\nexport class Scope {\n  flags: ScopeFlag = 0;\n  names: Map<string, NameType> = new Map();\n  firstLexicalName = \"\";\n\n  constructor(flags: ScopeFlag) {\n    this.flags = flags;\n  }\n}\n\n// The functions in this module keep track of declared variables in the\n// current scope in order to detect duplicate variable names.\nexport default class ScopeHandler<IScope extends Scope = Scope> {\n  parser: Tokenizer;\n  scopeStack: Array<IScope> = [];\n  inModule: boolean;\n  undefinedExports: Map<string, Position> = new Map();\n\n  constructor(parser: Tokenizer, inModule: boolean) {\n    this.parser = parser;\n    this.inModule = inModule;\n  }\n\n  get inTopLevel() {\n    return (this.currentScope().flags & ScopeFlag.PROGRAM) > 0;\n  }\n  get inFunction() {\n    return (this.currentVarScopeFlags() & ScopeFlag.FUNCTION) > 0;\n  }\n  get allowSuper() {\n    return (this.currentThisScopeFlags() & ScopeFlag.SUPER) > 0;\n  }\n  get allowDirectSuper() {\n    return (this.currentThisScopeFlags() & ScopeFlag.DIRECT_SUPER) > 0;\n  }\n  get inClass() {\n    return (this.currentThisScopeFlags() & ScopeFlag.CLASS) > 0;\n  }\n  get inClassAndNotInNonArrowFunction() {\n    const flags = this.currentThisScopeFlags();\n    return (flags & ScopeFlag.CLASS) > 0 && (flags & ScopeFlag.FUNCTION) === 0;\n  }\n  get inStaticBlock() {\n    for (let i = this.scopeStack.length - 1; ; i--) {\n      const { flags } = this.scopeStack[i];\n      if (flags & ScopeFlag.STATIC_BLOCK) {\n        return true;\n      }\n      if (flags & (ScopeFlag.VAR | ScopeFlag.CLASS)) {\n        // function body, module body, class property initializers\n        return false;\n      }\n    }\n  }\n  get inNonArrowFunction() {\n    return (this.currentThisScopeFlags() & ScopeFlag.FUNCTION) > 0;\n  }\n  get treatFunctionsAsVar() {\n    return this.treatFunctionsAsVarInScope(this.currentScope());\n  }\n\n  createScope(flags: ScopeFlag): Scope {\n    return new Scope(flags);\n  }\n\n  enter(flags: ScopeFlag) {\n    /*:: +createScope: (flags:ScopeFlag) => IScope; */\n    // @ts-expect-error This method will be overwritten by subclasses\n    this.scopeStack.push(this.createScope(flags));\n  }\n\n  exit(): ScopeFlag {\n    const scope = this.scopeStack.pop();\n    return scope.flags;\n  }\n\n  // The spec says:\n  // > At the top level of a function, or script, function declarations are\n  // > treated like var declarations rather than like lexical declarations.\n  treatFunctionsAsVarInScope(scope: IScope): boolean {\n    return !!(\n      scope.flags & (ScopeFlag.FUNCTION | ScopeFlag.STATIC_BLOCK) ||\n      (!this.parser.inModule && scope.flags & ScopeFlag.PROGRAM)\n    );\n  }\n\n  declareName(name: string, bindingType: BindingFlag, loc: Position) {\n    let scope = this.currentScope();\n    if (\n      bindingType & BindingFlag.SCOPE_LEXICAL ||\n      bindingType & BindingFlag.SCOPE_FUNCTION\n    ) {\n      this.checkRedeclarationInScope(scope, name, bindingType, loc);\n\n      let type = scope.names.get(name) || 0;\n\n      if (bindingType & BindingFlag.SCOPE_FUNCTION) {\n        type = type | NameType.Function;\n      } else {\n        if (!scope.firstLexicalName) {\n          scope.firstLexicalName = name;\n        }\n        type = type | NameType.Lexical;\n      }\n\n      scope.names.set(name, type);\n\n      if (bindingType & BindingFlag.SCOPE_LEXICAL) {\n        this.maybeExportDefined(scope, name);\n      }\n    } else if (bindingType & BindingFlag.SCOPE_VAR) {\n      for (let i = this.scopeStack.length - 1; i >= 0; --i) {\n        scope = this.scopeStack[i];\n        this.checkRedeclarationInScope(scope, name, bindingType, loc);\n        scope.names.set(name, (scope.names.get(name) || 0) | NameType.Var);\n        this.maybeExportDefined(scope, name);\n\n        if (scope.flags & ScopeFlag.VAR) break;\n      }\n    }\n    if (this.parser.inModule && scope.flags & ScopeFlag.PROGRAM) {\n      this.undefinedExports.delete(name);\n    }\n  }\n\n  maybeExportDefined(scope: IScope, name: string) {\n    if (this.parser.inModule && scope.flags & ScopeFlag.PROGRAM) {\n      this.undefinedExports.delete(name);\n    }\n  }\n\n  checkRedeclarationInScope(\n    scope: IScope,\n    name: string,\n    bindingType: BindingFlag,\n    loc: Position,\n  ) {\n    if (this.isRedeclaredInScope(scope, name, bindingType)) {\n      this.parser.raise(Errors.VarRedeclaration, loc, {\n        identifierName: name,\n      });\n    }\n  }\n\n  isRedeclaredInScope(\n    scope: IScope,\n    name: string,\n    bindingType: BindingFlag,\n  ): boolean {\n    if (!(bindingType & BindingFlag.KIND_VALUE)) return false;\n\n    if (bindingType & BindingFlag.SCOPE_LEXICAL) {\n      return scope.names.has(name);\n    }\n\n    const type = scope.names.get(name);\n\n    if (bindingType & BindingFlag.SCOPE_FUNCTION) {\n      return (\n        (type & NameType.Lexical) > 0 ||\n        (!this.treatFunctionsAsVarInScope(scope) && (type & NameType.Var) > 0)\n      );\n    }\n\n    return (\n      ((type & NameType.Lexical) > 0 &&\n        // Annex B.3.4\n        // https://tc39.es/ecma262/#sec-variablestatements-in-catch-blocks\n        !(\n          scope.flags & ScopeFlag.SIMPLE_CATCH &&\n          scope.firstLexicalName === name\n        )) ||\n      (!this.treatFunctionsAsVarInScope(scope) &&\n        (type & NameType.Function) > 0)\n    );\n  }\n\n  checkLocalExport(id: N.Identifier) {\n    const { name } = id;\n    const topLevelScope = this.scopeStack[0];\n    if (!topLevelScope.names.has(name)) {\n      this.undefinedExports.set(name, id.loc.start);\n    }\n  }\n\n  currentScope(): IScope {\n    return this.scopeStack[this.scopeStack.length - 1];\n  }\n\n  currentVarScopeFlags(): ScopeFlag {\n    for (let i = this.scopeStack.length - 1; ; i--) {\n      const { flags } = this.scopeStack[i];\n      if (flags & ScopeFlag.VAR) {\n        return flags;\n      }\n    }\n  }\n\n  // Could be useful for `arguments`, `this`, `new.target`, `super()`, `super.property`, and `super[property]`.\n  currentThisScopeFlags(): ScopeFlag {\n    for (let i = this.scopeStack.length - 1; ; i--) {\n      const { flags } = this.scopeStack[i];\n      if (\n        flags & (ScopeFlag.VAR | ScopeFlag.CLASS) &&\n        !(flags & ScopeFlag.ARROW)\n      ) {\n        return flags;\n      }\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]}