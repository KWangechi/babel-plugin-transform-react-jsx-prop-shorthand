{"version":3,"names":["_types","require","_index","_whitespace","_identifier","_classScope","_expressionScope","_scopeflags","_productionParameter","_parseError","UtilParser","Tokenizer","addExtra","node","key","value","enumerable","extra","Object","defineProperty","isContextual","token","state","type","containsEsc","isUnparsedContextual","nameStart","name","nameEnd","length","input","slice","nextCh","charCodeAt","isIdentifierChar","isLookaheadContextual","next","nextTokenStart","eatContextual","expectContextual","toParseError","raise","startLoc","unexpected","canInsertSemicolon","match","hasPrecedingLineBreak","hasNewLine","offsetToSourcePos","lastTokEndLoc","index","start","hasFollowingLineBreak","end","isLineTerminator","eat","semicolon","allowAsi","Errors","MissingSemicolon","expect","loc","tryParse","fn","oldState","clone","abortSignal","errors","failState","tokensLength","error","thrown","aborted","SyntaxError","checkExpressionErrors","refExpressionErrors","andThrow","shorthandAssignLoc","doubleProtoLoc","privateKeyLoc","optionalParametersLoc","hasErrors","InvalidCoverInitializedName","DuplicateProto","UnexpectedPrivateField","isLiteralPropertyName","tokenIsLiteralPropertyName","isPrivateName","getPrivateNameSV","id","hasPropertyAsPrivateName","property","isObjectProperty","isObjectMethod","initializeScopes","inModule","options","sourceType","oldLabels","labels","oldExportedIdentifiers","exportedIdentifiers","Set","oldInModule","oldScope","scope","ScopeHandler","getScopeHandler","oldProdParam","prodParam","ProductionParameterHandler","oldClassScope","classScope","ClassScopeHandler","oldExpressionScope","expressionScope","ExpressionScopeHandler","enterInitialScopes","paramFlags","ParamKind","PARAM","PARAM_AWAIT","enter","ScopeFlag","PROGRAM","checkDestructuringPrivate","expectPlugin","exports","default","ExpressionErrors"],"sources":["../../src/parser/util.ts"],"sourcesContent":["import type { Position } from \"../util/location.ts\";\nimport {\n  tokenIsLiteralPropertyName,\n  tt,\n  type TokenType,\n} from \"../tokenizer/types.ts\";\nimport Tokenizer from \"../tokenizer/index.ts\";\nimport type State from \"../tokenizer/state.ts\";\nimport type {\n  EstreePropertyDefinition,\n  Node,\n  ObjectMethod,\n  ObjectProperty,\n  PrivateName,\n} from \"../types.d.ts\";\nimport { hasNewLine } from \"../util/whitespace.ts\";\nimport { isIdentifierChar } from \"../util/identifier.ts\";\nimport ClassScopeHandler from \"../util/class-scope.ts\";\nimport ExpressionScopeHandler from \"../util/expression-scope.ts\";\nimport { ScopeFlag } from \"../util/scopeflags.ts\";\nimport ProductionParameterHandler, {\n  ParamKind,\n} from \"../util/production-parameter.ts\";\nimport {\n  Errors,\n  type ParseError,\n  type ParseErrorConstructor,\n} from \"../parse-error.ts\";\nimport type Parser from \"./index.ts\";\n\nimport type ScopeHandler from \"../util/scope.ts\";\n\ntype TryParse<Node, Error, Thrown, Aborted, FailState> = {\n  node: Node;\n  error: Error;\n  thrown: Thrown;\n  aborted: Aborted;\n  failState: FailState;\n};\n\n// ## Parser utilities\n\nexport default abstract class UtilParser extends Tokenizer {\n  // Forward-declaration: defined in parser/index.js\n  abstract getScopeHandler(): new (...args: any) => ScopeHandler;\n\n  addExtra(\n    node: Partial<Node>,\n    key: string,\n    value: any,\n    enumerable: boolean = true,\n  ): void {\n    if (!node) return;\n\n    let { extra } = node;\n    if (extra == null) {\n      extra = {};\n      node.extra = extra;\n    }\n\n    if (enumerable) {\n      extra[key] = value;\n    } else {\n      Object.defineProperty(extra, key, { enumerable, value });\n    }\n  }\n\n  // Tests whether parsed token is a contextual keyword.\n\n  isContextual(token: TokenType): boolean {\n    return this.state.type === token && !this.state.containsEsc;\n  }\n\n  isUnparsedContextual(nameStart: number, name: string): boolean {\n    const nameEnd = nameStart + name.length;\n    if (this.input.slice(nameStart, nameEnd) === name) {\n      const nextCh = this.input.charCodeAt(nameEnd);\n      return !(\n        isIdentifierChar(nextCh) ||\n        // check if `nextCh is between 0xd800 - 0xdbff,\n        // if `nextCh` is NaN, `NaN & 0xfc00` is 0, the function\n        // returns true\n        (nextCh & 0xfc00) === 0xd800\n      );\n    }\n    return false;\n  }\n\n  isLookaheadContextual(name: string): boolean {\n    const next = this.nextTokenStart();\n    return this.isUnparsedContextual(next, name);\n  }\n\n  // Consumes contextual keyword if possible.\n\n  eatContextual(token: TokenType): boolean {\n    if (this.isContextual(token)) {\n      this.next();\n      return true;\n    }\n    return false;\n  }\n\n  // Asserts that following token is given contextual keyword.\n\n  expectContextual(\n    token: TokenType,\n    toParseError?: ParseErrorConstructor<any>,\n  ): void {\n    if (!this.eatContextual(token)) {\n      if (toParseError != null) {\n        throw this.raise(toParseError, this.state.startLoc);\n      }\n      this.unexpected(null, token);\n    }\n  }\n\n  // Test whether a semicolon can be inserted at the current position.\n\n  canInsertSemicolon(): boolean {\n    return (\n      this.match(tt.eof) ||\n      this.match(tt.braceR) ||\n      this.hasPrecedingLineBreak()\n    );\n  }\n\n  hasPrecedingLineBreak(): boolean {\n    return hasNewLine(\n      this.input,\n      this.offsetToSourcePos(this.state.lastTokEndLoc.index),\n      this.state.start,\n    );\n  }\n\n  hasFollowingLineBreak(): boolean {\n    return hasNewLine(this.input, this.state.end, this.nextTokenStart());\n  }\n\n  isLineTerminator(): boolean {\n    return this.eat(tt.semi) || this.canInsertSemicolon();\n  }\n\n  // Consume a semicolon, or, failing that, see if we are allowed to\n  // pretend that there is a semicolon at this position.\n\n  semicolon(allowAsi: boolean = true): void {\n    if (allowAsi ? this.isLineTerminator() : this.eat(tt.semi)) return;\n    this.raise(Errors.MissingSemicolon, this.state.lastTokEndLoc);\n  }\n\n  // Expect a token of a given type. If found, consume it, otherwise,\n  // raise an unexpected token error at given pos.\n\n  expect(type: TokenType, loc?: Position | null): void {\n    if (!this.eat(type)) {\n      this.unexpected(loc, type);\n    }\n  }\n\n  // tryParse will clone parser state.\n  // It is expensive and should be used with cautions\n  tryParse<T extends Node | ReadonlyArray<Node>>(\n    fn: (abort: (node?: T) => never) => T,\n    oldState: State = this.state.clone(),\n  ):\n    | TryParse<T, null, false, false, null>\n    | TryParse<T | null, ParseError<any>, boolean, false, State>\n    | TryParse<T | null, null, false, true, State> {\n    const abortSignal: {\n      node: T | null;\n    } = { node: null };\n    try {\n      const node = fn((node = null) => {\n        abortSignal.node = node;\n        // eslint-disable-next-line @typescript-eslint/only-throw-error\n        throw abortSignal;\n      });\n      if (this.state.errors.length > oldState.errors.length) {\n        const failState = this.state;\n        this.state = oldState;\n        // tokensLength should be preserved during error recovery mode\n        // since the parser does not halt and will instead parse the\n        // remaining tokens\n        this.state.tokensLength = failState.tokensLength;\n        return {\n          node,\n          error: failState.errors[oldState.errors.length],\n          thrown: false,\n          aborted: false,\n          failState,\n        };\n      }\n\n      return {\n        node,\n        error: null,\n        thrown: false,\n        aborted: false,\n        failState: null,\n      };\n    } catch (error) {\n      const failState = this.state;\n      this.state = oldState;\n      if (error instanceof SyntaxError) {\n        // @ts-expect-error casting general syntax error to parse error\n        return { node: null, error, thrown: true, aborted: false, failState };\n      }\n      if (error === abortSignal) {\n        return {\n          node: abortSignal.node,\n          error: null,\n          thrown: false,\n          aborted: true,\n          failState,\n        };\n      }\n\n      throw error;\n    }\n  }\n\n  checkExpressionErrors(\n    refExpressionErrors: ExpressionErrors | undefined | null,\n    andThrow: boolean,\n  ) {\n    if (!refExpressionErrors) return false;\n    const {\n      shorthandAssignLoc,\n      doubleProtoLoc,\n      privateKeyLoc,\n      optionalParametersLoc,\n    } = refExpressionErrors;\n\n    const hasErrors =\n      !!shorthandAssignLoc ||\n      !!doubleProtoLoc ||\n      !!optionalParametersLoc ||\n      !!privateKeyLoc;\n\n    if (!andThrow) {\n      return hasErrors;\n    }\n\n    if (shorthandAssignLoc != null) {\n      this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);\n    }\n\n    if (doubleProtoLoc != null) {\n      this.raise(Errors.DuplicateProto, doubleProtoLoc);\n    }\n\n    if (privateKeyLoc != null) {\n      this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);\n    }\n\n    if (optionalParametersLoc != null) {\n      this.unexpected(optionalParametersLoc);\n    }\n  }\n\n  /**\n   * Test if current token is a literal property name\n   * https://tc39.es/ecma262/#prod-LiteralPropertyName\n   * LiteralPropertyName:\n   *   IdentifierName\n   *   StringLiteral\n   *   NumericLiteral\n   *   BigIntLiteral\n   */\n  isLiteralPropertyName(): boolean {\n    return tokenIsLiteralPropertyName(this.state.type);\n  }\n\n  /**\n   * Test if given node is a PrivateName\n   * will be overridden in ESTree plugin\n   */\n  isPrivateName(node: Node): node is PrivateName {\n    return node.type === \"PrivateName\";\n  }\n\n  /**\n   * Return the string value of a given private name\n   * WITHOUT `#`\n   * @see {@link https://tc39.es/ecma262/#sec-static-semantics-stringvalue}\n   */\n  getPrivateNameSV(node: PrivateName): string {\n    return node.id.name;\n  }\n\n  /**\n   * Return whether the given node is a member/optional chain that\n   * contains a private name as its property\n   * It is overridden in ESTree plugin\n   */\n  hasPropertyAsPrivateName(node: Node): boolean {\n    return (\n      (node.type === \"MemberExpression\" ||\n        node.type === \"OptionalMemberExpression\") &&\n      this.isPrivateName(node.property)\n    );\n  }\n\n  isObjectProperty(\n    node: Node,\n  ): node is ObjectProperty | EstreePropertyDefinition {\n    return node.type === \"ObjectProperty\";\n  }\n\n  isObjectMethod(node: Node): node is ObjectMethod {\n    return node.type === \"ObjectMethod\";\n  }\n\n  initializeScopes(\n    this: Parser,\n    inModule: boolean = this.options.sourceType === \"module\",\n  ): () => void {\n    // Initialize state\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n\n    const oldExportedIdentifiers = this.exportedIdentifiers;\n    this.exportedIdentifiers = new Set();\n\n    // initialize scopes\n    const oldInModule = this.inModule;\n    this.inModule = inModule;\n\n    const oldScope = this.scope;\n    const ScopeHandler = this.getScopeHandler();\n    this.scope = new ScopeHandler(this, inModule);\n\n    const oldProdParam = this.prodParam;\n    this.prodParam = new ProductionParameterHandler();\n\n    const oldClassScope = this.classScope;\n    this.classScope = new ClassScopeHandler(this);\n\n    const oldExpressionScope = this.expressionScope;\n    this.expressionScope = new ExpressionScopeHandler(this);\n\n    return () => {\n      // Revert state\n      this.state.labels = oldLabels;\n      this.exportedIdentifiers = oldExportedIdentifiers;\n\n      // Revert scopes\n      this.inModule = oldInModule;\n      this.scope = oldScope;\n      this.prodParam = oldProdParam;\n      this.classScope = oldClassScope;\n      this.expressionScope = oldExpressionScope;\n    };\n  }\n\n  enterInitialScopes() {\n    let paramFlags = ParamKind.PARAM;\n    if (this.inModule) {\n      paramFlags |= ParamKind.PARAM_AWAIT;\n    }\n    this.scope.enter(ScopeFlag.PROGRAM);\n    this.prodParam.enter(paramFlags);\n  }\n\n  checkDestructuringPrivate(refExpressionErrors: ExpressionErrors) {\n    const { privateKeyLoc } = refExpressionErrors;\n    if (privateKeyLoc !== null) {\n      this.expectPlugin(\"destructuringPrivate\", privateKeyLoc);\n    }\n  }\n}\n\n/**\n * The ExpressionErrors is a context struct used to track ambiguous patterns\n * When we are sure the parsed pattern is a RHS, which means it is not a pattern,\n * we will throw on this position on invalid assign syntax, otherwise it will be reset to null\n *\n * Types of ExpressionErrors:\n *\n * - **shorthandAssignLoc**: track initializer `=` position\n * - **doubleProtoLoc**: track the duplicate `__proto__` key position\n * - **privateKeyLoc**: track private key `#p` position\n * - **optionalParametersLoc**: track the optional parameter (`?`).\n *   It's only used by typescript and flow plugins\n */\nexport class ExpressionErrors {\n  shorthandAssignLoc: Position | undefined | null = null;\n  doubleProtoLoc: Position | undefined | null = null;\n  privateKeyLoc: Position | undefined | null = null;\n  optionalParametersLoc: Position | undefined | null = null;\n}\n"],"mappings":"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","ignoreList":[]}