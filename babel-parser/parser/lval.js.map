{"version":3,"names":["_types","require","_identifier","_node","_scopeflags","_parseError","unwrapParenthesizedExpression","node","type","expression","ParseBindingListFlags","exports","ALLOW_EMPTY","IS_FUNCTION_PARAMS","IS_CONSTRUCTOR_PARAMS","LValParser","NodeUtils","toAssignable","isLHS","parenthesized","undefined","extra","expressionScope","recordArrowParameterBindingError","Errors","InvalidParenthesizedAssignment","isOptionalMemberExpression","raise","i","length","properties","last","prop","isLast","toAssignableObjectExpressionProp","trailingCommaLoc","RestTrailingComma","key","value","isPrivateName","classScope","usePrivateName","getPrivateNameSV","loc","start","Error","toAssignableList","elements","operator","MissingEqInAssignment","left","end","kind","PatternHasAccessor","PatternHasMethod","arg","argument","checkToRestConversion","exprList","elt","toAssignableListItem","index","isAssignable","isBinding","every","element","toReferencedList","isParenthesizedExpr","toReferencedListDeep","expr","parseSpread","refExpressionErrors","startNode","next","parseMaybeAssignAllowIn","finishNode","parseRestBinding","parseBindingAtom","state","parseBindingList","parseObjectLike","parseIdentifier","close","closeCharCode","flags","allowEmpty","elts","first","eat","expect","match","push","rest","process","env","BABEL_8_BREAKING","hasPlugin","parseFunctionParamType","checkCommaAfterRest","decorators","UnsupportedParameterDecorator","startLoc","parseDecorator","parseBindingElement","parseBindingRestProperty","parseBindingProperty","expectPlugin","parsePrivateName","parsePropertyName","method","parseObjPropValue","parseMaybeDefault","param","startNodeAt","right","isValidLVal","isUnparenthesizedInAssign","binding","checkLVal","ancestor","BindingFlag","TYPE_NONE","checkClashes","strictModeChanged","hasParenthesizedAncestor","isObjectMethod","InvalidLhsOptionalChaining","InvalidPropertyBindingPattern","checkIdentifier","name","has","ParamDupe","add","validity","ParseErrorClass","InvalidLhs","InvalidLhsBinding","isParenthesizedExpression","nextAncestor","val","Array","isArray","child","at","bindingType","strict","isStrictBindReservedWord","inModule","isStrictBindOnlyReservedWord","StrictEvalArguments","referenceName","StrictEvalArgumentsBinding","bindingName","FLAG_NO_LET_IN_LEXICAL","LetInLexicalBinding","declareNameFromIdentifier","identifier","scope","declareName","allowPattern","InvalidRestAssignmentPattern","lookaheadCharCode","ElementAfterRest","default"],"sources":["../../src/parser/lval.ts"],"sourcesContent":["import * as charCodes from \"charcodes\";\nimport { tt, type TokenType } from \"../tokenizer/types.ts\";\nimport type {\n  AssignmentPattern,\n  TSParameterProperty,\n  Decorator,\n  Expression,\n  Identifier,\n  Node,\n  Pattern,\n  RestElement,\n  SpreadElement,\n  ObjectOrClassMember,\n  ClassMember,\n  ObjectMember,\n  TsNamedTypeElementBase,\n  PrivateName,\n  ObjectExpression,\n  ObjectPattern,\n  ArrayPattern,\n  AssignmentProperty,\n  Assignable,\n} from \"../types.ts\";\nimport type { Position } from \"../util/location.ts\";\nimport {\n  isStrictBindOnlyReservedWord,\n  isStrictBindReservedWord,\n} from \"../util/identifier.ts\";\nimport { NodeUtils, type Undone } from \"./node.ts\";\nimport { BindingFlag } from \"../util/scopeflags.ts\";\nimport type { ExpressionErrors } from \"./util.ts\";\nimport { Errors, type LValAncestor } from \"../parse-error.ts\";\nimport type Parser from \"./index.ts\";\n\nconst unwrapParenthesizedExpression = (node: Node): Node => {\n  return node.type === \"ParenthesizedExpression\"\n    ? unwrapParenthesizedExpression(node.expression)\n    : node;\n};\n\nexport const enum ParseBindingListFlags {\n  ALLOW_EMPTY = 1 << 0,\n  IS_FUNCTION_PARAMS = 1 << 1,\n  IS_CONSTRUCTOR_PARAMS = 1 << 2,\n}\n\nexport default abstract class LValParser extends NodeUtils {\n  // Forward-declaration: defined in expression.js\n  abstract parseIdentifier(liberal?: boolean): Identifier;\n  abstract parseMaybeAssign(\n    refExpressionErrors?: ExpressionErrors | null,\n    afterLeftParse?: Function,\n  ): Expression;\n\n  abstract parseMaybeAssignAllowIn(\n    refExpressionErrors?: ExpressionErrors | null,\n    afterLeftParse?: Function,\n  ): Expression;\n\n  abstract parseObjectLike<T extends ObjectPattern | ObjectExpression>(\n    close: TokenType,\n    isPattern: boolean,\n    isRecord?: boolean,\n    refExpressionErrors?: ExpressionErrors,\n  ): T;\n  abstract parseObjPropValue(\n    prop: any,\n    startLoc: Position | null,\n    isGenerator: boolean,\n    isAsync: boolean,\n    isPattern: boolean,\n    isAccessor: boolean,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): void;\n  abstract parsePropertyName(\n    prop: ObjectOrClassMember | ClassMember | TsNamedTypeElementBase,\n  ): void;\n  abstract parsePrivateName(): PrivateName;\n  // Forward-declaration: defined in statement.js\n  abstract parseDecorator(): Decorator;\n\n  /**\n   * Convert existing expression atom to assignable pattern\n   * if possible. Also checks invalid destructuring targets:\n   *\n   * - Parenthesized Destructuring patterns\n   * - RestElement is not the last element\n   * - Missing `=` in assignment pattern\n   *\n   * NOTE: There is a corresponding \"isAssignable\" method.\n   * When this one is updated, please check if also that one needs to be updated.\n   *\n   * @param node The expression atom\n   * @param isLHS Whether we are parsing a LeftHandSideExpression.\n   *              If isLHS is `true`, the following cases are allowed: `[(a)] = [0]`, `[(a.b)] = [0]`\n   *              If isLHS is `false`, we are in an arrow function parameters list.\n   */\n  toAssignable(node: Node, isLHS: boolean = false): asserts node is Assignable {\n    let parenthesized = undefined;\n    if (node.type === \"ParenthesizedExpression\" || node.extra?.parenthesized) {\n      parenthesized = unwrapParenthesizedExpression(node);\n      if (isLHS) {\n        // an LHS can be reinterpreted to a binding pattern but not vice versa.\n        // therefore a parenthesized identifier is ambiguous until we are sure it is an assignment expression\n        // i.e. `([(a) = []] = []) => {}`\n        // see also `recordArrowParameterBindingError` signature in packages/babel-parser/src/util/expression-scope.js\n        if (parenthesized.type === \"Identifier\") {\n          this.expressionScope.recordArrowParameterBindingError(\n            Errors.InvalidParenthesizedAssignment,\n            node,\n          );\n        } else if (\n          parenthesized.type !== \"MemberExpression\" &&\n          !this.isOptionalMemberExpression(parenthesized)\n        ) {\n          // A parenthesized member expression can be in LHS but not in pattern.\n          // If the LHS is later interpreted as a pattern, `checkLVal` will throw for member expression binding\n          // i.e. `([(a.b) = []] = []) => {}`\n          this.raise(Errors.InvalidParenthesizedAssignment, node);\n        }\n      } else {\n        this.raise(Errors.InvalidParenthesizedAssignment, node);\n      }\n    }\n\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n      case \"RestElement\":\n        break;\n\n      case \"ObjectExpression\":\n        (node as Node).type = \"ObjectPattern\";\n        for (\n          let i = 0, length = node.properties.length, last = length - 1;\n          i < length;\n          i++\n        ) {\n          const prop = node.properties[i];\n          const isLast = i === last;\n          this.toAssignableObjectExpressionProp(prop, isLast, isLHS);\n\n          if (\n            isLast &&\n            (prop as Node).type === \"RestElement\" &&\n            node.extra?.trailingCommaLoc\n          ) {\n            this.raise(Errors.RestTrailingComma, node.extra.trailingCommaLoc);\n          }\n        }\n        break;\n\n      case \"ObjectProperty\": {\n        const { key, value } = node;\n        if (this.isPrivateName(key)) {\n          this.classScope.usePrivateName(\n            this.getPrivateNameSV(key),\n            key.loc.start,\n          );\n        }\n        this.toAssignable(value, isLHS);\n        break;\n      }\n\n      case \"SpreadElement\": {\n        throw new Error(\n          \"Internal @babel/parser error (this is a bug, please report it).\" +\n            \" SpreadElement should be converted by .toAssignable's caller.\",\n        );\n      }\n\n      case \"ArrayExpression\":\n        (node as Node).type = \"ArrayPattern\";\n        this.toAssignableList(\n          node.elements,\n          node.extra?.trailingCommaLoc,\n          isLHS,\n        );\n        break;\n\n      case \"AssignmentExpression\":\n        if (node.operator !== \"=\") {\n          this.raise(Errors.MissingEqInAssignment, node.left.loc.end);\n        }\n\n        (node as Node).type = \"AssignmentPattern\";\n        delete node.operator;\n        this.toAssignable(node.left, isLHS);\n        break;\n\n      case \"ParenthesizedExpression\":\n        /*::invariant (parenthesized !== undefined) */\n        this.toAssignable(parenthesized, isLHS);\n        break;\n\n      default:\n      // We don't know how to deal with this node. It will\n      // be reported by a later call to checkLVal\n    }\n  }\n\n  toAssignableObjectExpressionProp(\n    prop: Node,\n    isLast: boolean,\n    isLHS: boolean,\n  ) {\n    if (prop.type === \"ObjectMethod\") {\n      this.raise(\n        prop.kind === \"get\" || prop.kind === \"set\"\n          ? Errors.PatternHasAccessor\n          : Errors.PatternHasMethod,\n        prop.key,\n      );\n    } else if (prop.type === \"SpreadElement\") {\n      (prop as Node).type = \"RestElement\";\n      const arg = prop.argument;\n      this.checkToRestConversion(arg, /* allowPattern */ false);\n      this.toAssignable(arg, isLHS);\n\n      if (!isLast) {\n        this.raise(Errors.RestTrailingComma, prop);\n      }\n    } else {\n      this.toAssignable(prop, isLHS);\n    }\n  }\n\n  // Convert list of expression atoms to binding list.\n\n  toAssignableList(\n    exprList: (Expression | SpreadElement | RestElement | null)[],\n    trailingCommaLoc: Position | undefined | null,\n    isLHS: boolean,\n  ): void {\n    const end = exprList.length - 1;\n\n    for (let i = 0; i <= end; i++) {\n      const elt = exprList[i];\n      if (!elt) continue;\n\n      this.toAssignableListItem(exprList, i, isLHS);\n\n      if (elt.type === \"RestElement\") {\n        if (i < end) {\n          this.raise(Errors.RestTrailingComma, elt);\n        } else if (trailingCommaLoc) {\n          this.raise(Errors.RestTrailingComma, trailingCommaLoc);\n        }\n      }\n    }\n  }\n\n  toAssignableListItem(\n    exprList: (Expression | SpreadElement | RestElement)[],\n    index: number,\n    isLHS: boolean,\n  ): void {\n    const node = exprList[index];\n    if (node.type === \"SpreadElement\") {\n      (node as unknown as RestElement).type = \"RestElement\";\n      const arg = node.argument;\n      this.checkToRestConversion(arg, /* allowPattern */ true);\n      this.toAssignable(arg, isLHS);\n    } else {\n      this.toAssignable(node, isLHS);\n    }\n  }\n\n  isAssignable(node: Node, isBinding?: boolean): boolean {\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n      case \"RestElement\":\n        return true;\n\n      case \"ObjectExpression\": {\n        const last = node.properties.length - 1;\n        return node.properties.every((prop, i) => {\n          return (\n            prop.type !== \"ObjectMethod\" &&\n            (i === last || prop.type !== \"SpreadElement\") &&\n            this.isAssignable(prop)\n          );\n        });\n      }\n\n      case \"ObjectProperty\":\n        return this.isAssignable(node.value);\n\n      case \"SpreadElement\":\n        return this.isAssignable(node.argument);\n\n      case \"ArrayExpression\":\n        return node.elements.every(\n          element => element === null || this.isAssignable(element),\n        );\n\n      case \"AssignmentExpression\":\n        return node.operator === \"=\";\n\n      case \"ParenthesizedExpression\":\n        return this.isAssignable(node.expression);\n\n      case \"MemberExpression\":\n      case \"OptionalMemberExpression\":\n        return !isBinding;\n\n      default:\n        return false;\n    }\n  }\n\n  // Convert list of expression atoms to a list of\n\n  toReferencedList(\n    exprList:\n      | ReadonlyArray<Expression | SpreadElement>\n      | ReadonlyArray<Expression | RestElement>,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    isParenthesizedExpr?: boolean,\n  ):\n    | ReadonlyArray<Expression | SpreadElement>\n    | ReadonlyArray<Expression | RestElement> {\n    return exprList;\n  }\n\n  toReferencedListDeep(\n    exprList:\n      | ReadonlyArray<Expression | SpreadElement>\n      | ReadonlyArray<Expression | RestElement>,\n    isParenthesizedExpr?: boolean,\n  ): void {\n    this.toReferencedList(exprList, isParenthesizedExpr);\n\n    for (const expr of exprList) {\n      if (expr?.type === \"ArrayExpression\") {\n        this.toReferencedListDeep(expr.elements);\n      }\n    }\n  }\n\n  // Parses spread element.\n\n  parseSpread(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): SpreadElement {\n    const node = this.startNode<SpreadElement>();\n    this.next();\n    node.argument = this.parseMaybeAssignAllowIn(\n      refExpressionErrors,\n      undefined,\n    );\n    return this.finishNode(node, \"SpreadElement\");\n  }\n\n  // https://tc39.es/ecma262/#prod-BindingRestProperty\n  // https://tc39.es/ecma262/#prod-BindingRestElement\n  parseRestBinding(this: Parser): RestElement {\n    const node = this.startNode<RestElement>();\n    this.next(); // eat `...`\n    node.argument = this.parseBindingAtom();\n    return this.finishNode(node, \"RestElement\");\n  }\n\n  // Parses lvalue (assignable) atom.\n  parseBindingAtom(this: Parser): Pattern {\n    // https://tc39.es/ecma262/#prod-BindingPattern\n    switch (this.state.type) {\n      case tt.bracketL: {\n        const node = this.startNode<ArrayPattern>();\n        this.next();\n        // @ts-expect-error: Fixme: TSParameterProperty can not be assigned to node.elements\n        node.elements = this.parseBindingList(\n          tt.bracketR,\n          charCodes.rightSquareBracket,\n          ParseBindingListFlags.ALLOW_EMPTY,\n        );\n        return this.finishNode(node, \"ArrayPattern\");\n      }\n\n      case tt.braceL:\n        return this.parseObjectLike(tt.braceR, true);\n    }\n\n    // https://tc39.es/ecma262/#prod-BindingIdentifier\n    return this.parseIdentifier();\n  }\n\n  // https://tc39.es/ecma262/#prod-BindingElementList\n  parseBindingList(\n    this: Parser,\n    close: TokenType,\n    closeCharCode: (typeof charCodes)[keyof typeof charCodes],\n    flags: ParseBindingListFlags,\n  ): Array<Pattern | TSParameterProperty> {\n    const allowEmpty = flags & ParseBindingListFlags.ALLOW_EMPTY;\n\n    const elts: Array<Pattern | TSParameterProperty> = [];\n    let first = true;\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(tt.comma);\n      }\n      if (allowEmpty && this.match(tt.comma)) {\n        elts.push(null);\n      } else if (this.eat(close)) {\n        break;\n      } else if (this.match(tt.ellipsis)) {\n        let rest: Pattern = this.parseRestBinding();\n        if (\n          (!process.env.BABEL_8_BREAKING && this.hasPlugin(\"flow\")) ||\n          flags & ParseBindingListFlags.IS_FUNCTION_PARAMS\n        ) {\n          rest = this.parseFunctionParamType(rest);\n        }\n        elts.push(rest);\n        if (!this.checkCommaAfterRest(closeCharCode)) {\n          this.expect(close);\n          break;\n        }\n      } else {\n        const decorators = [];\n        if (flags & ParseBindingListFlags.IS_FUNCTION_PARAMS) {\n          if (this.match(tt.at) && this.hasPlugin(\"decorators\")) {\n            this.raise(\n              Errors.UnsupportedParameterDecorator,\n              this.state.startLoc,\n            );\n          }\n          // invariant: hasPlugin(\"decorators-legacy\")\n          while (this.match(tt.at)) {\n            decorators.push(this.parseDecorator());\n          }\n        }\n        elts.push(this.parseBindingElement(flags, decorators));\n      }\n    }\n    return elts;\n  }\n\n  // https://tc39.es/ecma262/#prod-BindingRestProperty\n  parseBindingRestProperty(\n    this: Parser,\n    prop: Undone<RestElement>,\n  ): RestElement {\n    this.next(); // eat '...'\n    // Don't use parseRestBinding() as we only allow Identifier here.\n    prop.argument = this.parseIdentifier();\n    this.checkCommaAfterRest(charCodes.rightCurlyBrace);\n    return this.finishNode(prop, \"RestElement\");\n  }\n\n  // https://tc39.es/ecma262/#prod-BindingProperty\n  parseBindingProperty(this: Parser): AssignmentProperty | RestElement {\n    const { type, startLoc } = this.state;\n    if (type === tt.ellipsis) {\n      return this.parseBindingRestProperty(this.startNode());\n    }\n\n    const prop = this.startNode<AssignmentProperty>();\n    if (type === tt.privateName) {\n      this.expectPlugin(\"destructuringPrivate\", startLoc);\n      this.classScope.usePrivateName(this.state.value, startLoc);\n      prop.key = this.parsePrivateName();\n    } else {\n      this.parsePropertyName(prop);\n    }\n    prop.method = false;\n    return this.parseObjPropValue(\n      prop,\n      startLoc,\n      false /* isGenerator */,\n      false /* isAsync */,\n      true /* isPattern */,\n      false /* isAccessor */,\n    );\n  }\n\n  // https://tc39.es/ecma262/#prod-BindingElement\n  parseBindingElement(\n    this: Parser,\n    flags: ParseBindingListFlags,\n    decorators: Decorator[],\n  ): Pattern | TSParameterProperty {\n    const left = this.parseMaybeDefault();\n    if (\n      (!process.env.BABEL_8_BREAKING && this.hasPlugin(\"flow\")) ||\n      flags & ParseBindingListFlags.IS_FUNCTION_PARAMS\n    ) {\n      this.parseFunctionParamType(left);\n    }\n    const elt = this.parseMaybeDefault(left.loc.start, left);\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n    return elt;\n  }\n\n  // Used by flow/typescript plugin to add type annotations to binding elements\n  parseFunctionParamType(param: Pattern): Pattern {\n    return param;\n  }\n\n  // Parses assignment pattern around given atom if possible.\n  // https://tc39.es/ecma262/#prod-BindingElement\n  parseMaybeDefault(\n    this: Parser,\n    startLoc?: Position | null,\n    left?: Pattern | null,\n  ): Pattern {\n    startLoc ??= this.state.startLoc;\n    left = left ?? this.parseBindingAtom();\n    if (!this.eat(tt.eq)) return left;\n\n    const node = this.startNodeAt<AssignmentPattern>(startLoc);\n    node.left = left;\n    node.right = this.parseMaybeAssignAllowIn();\n    return this.finishNode(node, \"AssignmentPattern\");\n  }\n  /**\n   * Return information use in determining whether a Node of a given type is an LVal,\n   * possibly given certain additional context information.\n   *\n   * Subclasser notes: This method has kind of a lot of mixed, but related,\n   * responsibilities. If we can definitively determine with the information\n   * provided that this either *is* or *isn't* a valid `LVal`, then the return\n   * value is easy: just return `true` or `false`. However, if it is a valid\n   * LVal *ancestor*, and thus its descendants must be subsequently visited to\n   * continue the \"investigation\", then this method should return the relevant\n   * child key as a `string`. In some special cases, you additionally want to\n   * convey that this node should be treated as if it were parenthesized. In\n   * that case, a tuple of [key: string, parenthesized: boolean] is returned.\n   * The `string`-only return option is actually just a shorthand for:\n   * `[key: string, parenthesized: false]`.\n   *\n   * @param type A Node `type` string\n   * @param isUnparenthesizedInAssign\n   *        Whether the node in question is unparenthesized and its parent\n   *        is either an assignment pattern or an assignment expression.\n   * @param binding\n   *        The binding operation that is being considered for this potential\n   *        LVal.\n   * @returns `true` or `false` if we can immediately determine whether the node\n   *          type in question can be treated as an `LVal`.\n   *          A `string` key to traverse if we must check this child.\n   *          A `[string, boolean]` tuple if we need to check this child and\n   *          treat is as parenthesized.\n   */\n  isValidLVal(\n    type: string,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    isUnparenthesizedInAssign: boolean,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    binding: BindingFlag,\n  ): string | boolean | [string, boolean] {\n    switch (type) {\n      case \"AssignmentPattern\":\n        return \"left\";\n      case \"RestElement\":\n        return \"argument\";\n      case \"ObjectProperty\":\n        return \"value\";\n      case \"ParenthesizedExpression\":\n        return \"expression\";\n      case \"ArrayPattern\":\n        return \"elements\";\n      case \"ObjectPattern\":\n        return \"properties\";\n    }\n    return false;\n  }\n\n  // Overridden by the estree plugin\n  isOptionalMemberExpression(expression: Node): boolean {\n    return expression.type === \"OptionalMemberExpression\";\n  }\n\n  /**\n   * Verify that a target expression is an lval (something that can be assigned to).\n   *\n   * @param expression The expression in question to check.\n   * @param ancestor\n   *        The relevant ancestor to provide context information for the error\n   *        if the check fails.\n   * @param binding\n   *        The desired binding type. If the given expression is an identifier\n   *        and `binding` is not `BindingFlag.TYPE_NONE`, `checkLVal` will register binding\n   *        to the parser scope See also `src/util/scopeflags.js`\n   * @param checkClashes\n   *        An optional string set to check if an identifier name is included.\n   *        `checkLVal` will add checked identifier name to `checkClashes` It is\n   *        used in tracking duplicates in function parameter lists. If it is\n   *        false, `checkLVal` will skip duplicate checks\n   * @param strictModeChanged\n   *        Whether an identifier has been parsed in a sloppy context but should\n   *        be reinterpreted as strict-mode. e.g. `(arguments) => { \"use strict \"}`\n   * @param hasParenthesizedAncestor\n   *        This is only used internally during recursive calls, and you should\n   *        not have to set it yourself.\n   */\n\n  checkLVal(\n    expression:\n      | Expression\n      | ObjectMember\n      | RestElement\n      | Pattern\n      | TSParameterProperty,\n    ancestor: LValAncestor,\n    binding: BindingFlag = BindingFlag.TYPE_NONE,\n    checkClashes: Set<string> | false = false,\n    strictModeChanged: boolean = false,\n    hasParenthesizedAncestor: boolean = false,\n  ): void {\n    const type = expression.type;\n\n    // If we find here an ObjectMethod, it's because this was originally\n    // an ObjectExpression which has then been converted.\n    // toAssignable already reported this error with a nicer message.\n    if (this.isObjectMethod(expression)) return;\n\n    const isOptionalMemberExpression =\n      this.isOptionalMemberExpression(expression);\n\n    if (isOptionalMemberExpression || type === \"MemberExpression\") {\n      if (isOptionalMemberExpression) {\n        this.expectPlugin(\"optionalChainingAssign\", expression.loc.start);\n        if (ancestor.type !== \"AssignmentExpression\") {\n          this.raise(Errors.InvalidLhsOptionalChaining, expression, {\n            ancestor,\n          });\n        }\n      }\n\n      if (binding !== BindingFlag.TYPE_NONE) {\n        this.raise(Errors.InvalidPropertyBindingPattern, expression);\n      }\n      return;\n    }\n\n    if (type === \"Identifier\") {\n      this.checkIdentifier(expression, binding, strictModeChanged);\n\n      const { name } = expression;\n\n      if (checkClashes) {\n        if (checkClashes.has(name)) {\n          this.raise(Errors.ParamDupe, expression);\n        } else {\n          checkClashes.add(name);\n        }\n      }\n\n      return;\n    }\n\n    const validity = this.isValidLVal(\n      type,\n      !(hasParenthesizedAncestor || expression.extra?.parenthesized) &&\n        ancestor.type === \"AssignmentExpression\",\n      binding,\n    );\n\n    if (validity === true) return;\n    if (validity === false) {\n      const ParseErrorClass =\n        binding === BindingFlag.TYPE_NONE\n          ? Errors.InvalidLhs\n          : Errors.InvalidLhsBinding;\n\n      this.raise(ParseErrorClass, expression, { ancestor });\n      return;\n    }\n\n    let key: string, isParenthesizedExpression: boolean;\n    if (typeof validity === \"string\") {\n      key = validity;\n      isParenthesizedExpression = type === \"ParenthesizedExpression\";\n    } else {\n      [key, isParenthesizedExpression] = validity;\n    }\n\n    const nextAncestor =\n      type === \"ArrayPattern\" || type === \"ObjectPattern\"\n        ? ({ type } as const)\n        : ancestor;\n\n    // @ts-expect-error key may not index expression.\n    const val = expression[key];\n    if (Array.isArray(val)) {\n      for (const child of val) {\n        if (child) {\n          this.checkLVal(\n            child,\n            nextAncestor,\n            binding,\n            checkClashes,\n            strictModeChanged,\n            isParenthesizedExpression,\n          );\n        }\n      }\n    } else if (val) {\n      this.checkLVal(\n        val,\n        nextAncestor,\n        binding,\n        checkClashes,\n        strictModeChanged,\n        isParenthesizedExpression,\n      );\n    }\n  }\n\n  checkIdentifier(\n    at: Identifier,\n    bindingType: BindingFlag,\n    strictModeChanged: boolean = false,\n  ) {\n    if (\n      this.state.strict &&\n      (strictModeChanged\n        ? isStrictBindReservedWord(at.name, this.inModule)\n        : isStrictBindOnlyReservedWord(at.name))\n    ) {\n      if (bindingType === BindingFlag.TYPE_NONE) {\n        this.raise(Errors.StrictEvalArguments, at, { referenceName: at.name });\n      } else {\n        this.raise(Errors.StrictEvalArgumentsBinding, at, {\n          bindingName: at.name,\n        });\n      }\n    }\n\n    if (bindingType & BindingFlag.FLAG_NO_LET_IN_LEXICAL && at.name === \"let\") {\n      this.raise(Errors.LetInLexicalBinding, at);\n    }\n\n    if (!(bindingType & BindingFlag.TYPE_NONE)) {\n      this.declareNameFromIdentifier(at, bindingType);\n    }\n  }\n\n  declareNameFromIdentifier(identifier: Identifier, binding: BindingFlag) {\n    this.scope.declareName(identifier.name, binding, identifier.loc.start);\n  }\n\n  checkToRestConversion(node: Node, allowPattern: boolean): void {\n    switch (node.type) {\n      case \"ParenthesizedExpression\":\n        this.checkToRestConversion(node.expression, allowPattern);\n        break;\n      case \"Identifier\":\n      case \"MemberExpression\":\n        break;\n      case \"ArrayExpression\":\n      case \"ObjectExpression\":\n        if (allowPattern) break;\n      /* falls through */\n      default:\n        this.raise(Errors.InvalidRestAssignmentPattern, node);\n    }\n  }\n\n  checkCommaAfterRest(\n    close: (typeof charCodes)[keyof typeof charCodes],\n  ): boolean {\n    if (!this.match(tt.comma)) {\n      return false;\n    }\n\n    this.raise(\n      this.lookaheadCharCode() === close\n        ? Errors.RestTrailingComma\n        : Errors.ElementAfterRest,\n      this.state.startLoc,\n    );\n\n    return true;\n  }\n}\n"],"mappings":"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","ignoreList":[]}