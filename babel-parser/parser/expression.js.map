{"version":3,"names":["_types","require","_lval","_identifier","_location","_scopeflags","_util","_productionParameter","_expressionScope","_parseError","_pipelineOperatorErrors","_comments","_node","_options","ExpressionParser","LValParser","checkProto","prop","isRecord","sawProto","refExpressionErrors","type","isObjectMethod","computed","shorthand","key","name","value","raise","Errors","RecordNoProto","doubleProtoLoc","loc","start","DuplicateProto","shouldExitDescending","expr","potentialArrowAt","offsetToSourcePos","getExpression","enterInitialScopes","nextToken","parseExpression","match","unexpected","finalizeRemainingComments","comments","errors","state","optionFlags","OptionFlags","Tokens","tokens","disallowIn","disallowInAnd","parseExpressionBase","allowInAnd","startLoc","parseMaybeAssign","node","startNodeAt","expressions","eat","push","toReferencedList","finishNode","parseMaybeAssignDisallowIn","afterLeftParse","parseMaybeAssignAllowIn","setOptionalParametersError","optionalParametersLoc","isContextual","prodParam","hasYield","left","parseYield","call","ownExpressionErrors","ExpressionErrors","tokenIsIdentifier","parseMaybeConditional","tokenIsAssignment","operator","toAssignable","startIndex","index","shorthandAssignLoc","privateKeyLoc","checkDestructuringPrivate","next","right","checkLVal","checkExpressionErrors","parseExprOps","parseConditional","test","consequent","expect","alternate","parseMaybeUnaryOrPrivate","parsePrivateName","parseMaybeUnary","parseExprOp","leftStartLoc","minPrec","isPrivateName","getPrivateNameSV","tokenOperatorPrecedence","hasIn","PrivateInExpectedIn","identifierName","classScope","usePrivateName","op","tokenIsOperator","prec","expectPlugin","inFSharpPipelineDirectBody","checkPipelineAtInfixOperator","logical","coalesce","process","env","BABEL_8_BREAKING","hasPlugin","proposal","hasAwait","UnexpectedAwaitAfterPipelineBody","parseExprOpRightExpr","finishedNode","nextOp","MixingCoalesceWithLogical","getPluginOption","withTopicBindingContext","parseHackPipeBody","withSoloAwaitPermittingContext","parseFSharpPipelineBody","PipeBodyIsTighter","parseSmartPipelineBodyInStyle","parseExprOpBaseRightExpr","tokenIsRightAssociative","body","requiredParentheses","UnparenthesizedPipeBodyDescriptions","has","extra","parenthesized","PipeUnparenthesizedBody","topicReferenceWasUsedInCurrentContext","PipeTopicUnused","checkExponentialAfterUnary","UnexpectedTokenUnaryExponentiation","argument","sawUnary","isAwait","recordAwaitIfAllowed","parseAwait","update","startNode","tokenIsPrefix","prefix","isDelete","strict","arg","StrictDelete","hasPropertyAsPrivateName","DeletePrivateField","parseUpdate","startsExpr","tokenCanStartExpression","isAmbiguousAwait","raiseOverwrite","AwaitNotInAsyncContext","updateExpressionNode","parseExprSubscripts","tokenIsPostfix","canInsertSemicolon","parseExprAtom","parseSubscripts","base","noCalls","optionalChainMember","maybeAsyncArrow","atPossibleAsyncArrow","stop","parseSubscript","parseBind","tokenIsTemplate","parseTaggedTemplateExpression","optional","OptionalChainingNoNew","lookaheadCharCode","parseCoverCallAndAsyncArrowHead","parseMember","object","property","SuperPrivateField","parseIdentifier","callee","parseNoCallExpr","oldMaybeInArrowParameters","maybeInArrowParameters","expressionScope","enter","newAsyncArrowScope","arguments","parseCallExpressionArguments","finishCallExpression","shouldParseAsyncArrow","validateAsPattern","exit","parseAsyncArrowFromCallExpression","toReferencedArguments","isParenthesizedExpr","toReferencedListDeep","tag","quasi","parseTemplate","OptionalChainingNoTemplate","lastTokEndLoc","end","length","ImportCallArity","ImportCallSpreadArgument","close","allowPlaceholder","nodeForExtra","elts","first","oldInFSharpPipelineDirectBody","addTrailingCommaExtraToNode","parseExprListItem","resetPreviousNodeTrailingComments","parseArrowExpression","trailingCommaLoc","innerComments","setInnerComments","trailingComments","decorators","parseSuper","parseImportMetaProperty","CreateImportExpressions","parseImportCall","UnsupportedImport","lastTokStartLoc","parseDo","readRegexp","parseRegExpLiteral","parseNumericLiteral","parseBigIntLiteral","parseStringLiteral","parseNullLiteral","parseBooleanLiteral","canBeArrow","parseParenAndDistinguishExpression","parseArrayLike","parseObjectLike","parseFunctionOrFunctionSent","parseDecorators","parseClass","maybeTakeDecorators","parseNewOrNewTarget","UnsupportedBind","parseTopicReferenceThenEqualsSign","parseTopicReference","pipeProposal","lookaheadCh","input","codePointAt","nextTokenStart","isIdentifierStart","expectOnePlugin","parseDecimalLiteral","lookaheadInLineCharCode","parseModuleExpression","containsEsc","id","parseAsyncFunctionExpression","startNodeAtNode","parseAsyncArrowUnaryFunction","topicTokenType","topicTokenValue","pos","endLoc","createPositionWithColumnOffset","tokenType","finishTopicReference","testTopicReferenceConfiguration","topicReferenceIsAllowedInCurrentContext","PipeTopicUnbound","registerTopicReference","PrimaryTopicNotAllowed","PipeTopicUnconfiguredToken","token","tokenLabelName","topicToken","PipeTopicRequiresHackPipes","functionFlags","params","hasPrecedingLineBreak","LineTerminatorBeforeArrow","curPosition","isAsync","async","oldLabels","labels","ParamKind","PARAM_AWAIT","parseBlock","scope","allowDirectSuper","AllowSuperOutsideMethod","SuperNotAllowed","allowSuper","UnexpectedSuper","UnsupportedSuper","createIdentifier","meta","parseMetaProperty","parseFunction","propertyName","UnsupportedMetaProperty","target","onlyValidPropertyName","inModule","ImportMetaOutsideModule","sawUnambiguousESM","isSource","DynamicImportPhaseRequiresImportExpressions","phase","parseLiteralAtNode","addExtra","slice","parseLiteral","pattern","flags","val","newArrowHeadScope","innerStartLoc","exprList","spreadStartLoc","optionalCommaStartLoc","spreadNodeStartLoc","parseParenItem","parseRestBinding","checkCommaAfterRest","innerEndLoc","arrowNode","shouldParseArrow","parseArrow","resetEndLocation","wrapParenthesis","expression","CreateParenthesizedExpressions","takeSurroundingComments","parenExpression","metaProp","inNonArrowFunction","inClass","AllowNewTargetOutsideFunction","UnexpectedNewTarget","parseNew","parseNewCallee","args","parseExprList","isImport","ImportCallNotNewExpression","parseTemplateElement","isTagged","elemStart","elem","InvalidEscapeSequenceTemplate","firstInvalidTemplateEscapePos","isTail","endOffset","elemEnd","raw","replace","cooked","tail","curElt","quasis","substitutions","parseTemplateSubstitution","readTemplateContinuation","isPattern","properties","parseBindingProperty","parsePropertyDefinition","isObjectProperty","InvalidRecordProperty","maybeAsyncOrAccessorProp","isLiteralPropertyName","UnsupportedPropertyDecorator","parseDecorator","isAccessor","parseSpread","method","isGenerator","parsePropertyNamePrefixOperator","parsePropertyName","keyName","kind","AccessorIsGenerator","parseObjPropValue","getGetterSetterExpectedParamCount","getObjectOrClassMethodParams","checkGetterSetterParams","paramCount","BadGetterArity","BadSetterArity","BadSetterRestParameter","parseObjectMethod","finishedProp","parseMethod","parseObjectProperty","parseMaybeDefault","checkReservedWord","cloneIdentifier","InvalidCoverInitializedName","tokenIsKeywordOrIdentifier","UnexpectedPrivateField","initFunction","generator","isConstructor","inClassScope","ScopeFlag","FUNCTION","SUPER","CLASS","DIRECT_SUPER","parseFunctionParams","parseFunctionBodyAndFinish","canBePattern","isTuple","elements","ARROW","PARAM_IN","setArrowFunctionParameters","parseFunctionBody","toAssignableList","isMethod","allowExpression","isExpression","newExpressionScope","checkParams","oldStrict","currentFlags","PARAM_RETURN","hasStrictModeDirective","nonSimple","isSimpleParamList","IllegalLanguageModeDirective","strictModeChanged","checkIdentifier","BindingFlag","TYPE_OUTSIDE","isSimpleParameter","i","len","allowDuplicates","isArrowFunction","checkClashes","Set","formalParameters","param","TYPE_VAR","allowEmpty","elt","UnexpectedToken","UnexpectedArgumentPlaceholder","liberal","parseIdentifierName","tokenIsKeyword","tokenKeywordOrIdentifierIsKeyword","replaceToken","word","checkKeywords","isBinding","canBeReservedWord","isKeyword","UnexpectedKeyword","keyword","reservedTest","isReservedWord","isStrictBindReservedWord","isStrictReservedWord","UnexpectedReservedWord","reservedWord","YieldBindingIdentifier","AwaitBindingIdentifier","inStaticBlock","AwaitBindingIdentifierInStaticBlock","recordAsyncArrowParametersError","inClassAndNotInNonArrowFunction","ArgumentsInClass","isAwaitAllowed","AllowAwaitOutsideFunction","inFunction","hasTopLevelAwait","recordParameterInitializerError","AwaitExpressionFormalParameter","ObsoleteAwaitStar","ambiguousScriptDifferentAst","soloAwait","YieldInParameter","delegating","delegate","source","options","PipelineHeadSequenceExpression","childExpr","isSimpleReference","bodyNode","checkSmartPipeTopicBodyEarlyErrors","PipelineBodyNoArrow","PipelineTopicUnused","callback","outerContextTopicState","topicContext","maxNumOfResolvableTopics","maxTopicIndex","withSmartMixTopicForbiddingContext","outerContextSoloAwaitState","prodParamToSet","prodParamToClear","ret","program","revertScopes","initializeScopes","parseProgram","exports","default"],"sources":["../../src/parser/expression.ts"],"sourcesContent":["// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts — that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\nimport {\n  tokenCanStartExpression,\n  tokenIsAssignment,\n  tokenIsIdentifier,\n  tokenIsKeywordOrIdentifier,\n  tokenIsOperator,\n  tokenIsPostfix,\n  tokenIsPrefix,\n  tokenIsRightAssociative,\n  tokenIsTemplate,\n  tokenKeywordOrIdentifierIsKeyword,\n  tokenLabelName,\n  tokenOperatorPrecedence,\n  tt,\n  type TokenType,\n} from \"../tokenizer/types.ts\";\nimport type * as N from \"../types.ts\";\nimport LValParser from \"./lval.ts\";\nimport {\n  isKeyword,\n  isReservedWord,\n  isStrictReservedWord,\n  isStrictBindReservedWord,\n  isIdentifierStart,\n  canBeReservedWord,\n} from \"../util/identifier.ts\";\nimport {\n  type Position,\n  createPositionWithColumnOffset,\n} from \"../util/location.ts\";\nimport * as charCodes from \"charcodes\";\nimport { ScopeFlag, BindingFlag } from \"../util/scopeflags.ts\";\nimport { ExpressionErrors } from \"./util.ts\";\nimport { ParamKind, functionFlags } from \"../util/production-parameter.ts\";\nimport {\n  newArrowHeadScope,\n  newAsyncArrowScope,\n  newExpressionScope,\n} from \"../util/expression-scope.ts\";\nimport { Errors } from \"../parse-error.ts\";\nimport {\n  UnparenthesizedPipeBodyDescriptions,\n  type UnparenthesizedPipeBodyTypes,\n} from \"../parse-error/pipeline-operator-errors.ts\";\nimport { setInnerComments } from \"./comments.ts\";\nimport { cloneIdentifier, type Undone } from \"./node.ts\";\nimport type Parser from \"./index.ts\";\n\nimport { OptionFlags, type SourceType } from \"../options.ts\";\n\nexport default abstract class ExpressionParser extends LValParser {\n  // Forward-declaration: defined in statement.js\n  abstract parseBlock(\n    allowDirectives?: boolean,\n    createNewLexicalScope?: boolean,\n    afterBlockParse?: (hasStrictModeDirective: boolean) => void,\n  ): N.BlockStatement;\n  abstract parseClass(\n    node: N.Class,\n    isStatement: boolean,\n    optionalId?: boolean,\n  ): N.Class;\n  abstract parseDecorators(allowExport?: boolean): void;\n  abstract parseFunction<T extends N.NormalFunction>(\n    node: T,\n    statement?: number,\n    allowExpressionBody?: boolean,\n    isAsync?: boolean,\n  ): T;\n  abstract parseFunctionParams(node: N.Function, isConstructor?: boolean): void;\n  abstract parseBlockOrModuleBlockBody(\n    body: N.Statement[],\n    directives: N.Directive[] | null | undefined,\n    topLevel: boolean,\n    end: TokenType,\n    afterBlockParse?: (hasStrictModeDirective: boolean) => void,\n  ): void;\n  abstract parseProgram(\n    program: N.Program,\n    end: TokenType,\n    sourceType?: SourceType,\n  ): N.Program;\n\n  // For object literal, check if property __proto__ has been used more than once.\n  // If the expression is a destructuring assignment, then __proto__ may appear\n  // multiple times. Otherwise, __proto__ is a duplicated key.\n\n  // For record expression, check if property __proto__ exists\n\n  checkProto(\n    prop: N.ObjectMember | N.SpreadElement,\n    isRecord: boolean | undefined | null,\n    sawProto: boolean,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): boolean {\n    if (\n      prop.type === \"SpreadElement\" ||\n      this.isObjectMethod(prop) ||\n      prop.computed ||\n      prop.shorthand\n    ) {\n      return sawProto;\n    }\n\n    const key = prop.key as\n      | N.Identifier\n      | N.StringLiteral\n      | N.NumericLiteral\n      | N.BigIntLiteral;\n    // It is either an Identifier or a String/NumericLiteral\n    const name = key.type === \"Identifier\" ? key.name : key.value;\n\n    if (name === \"__proto__\") {\n      if (isRecord) {\n        this.raise(Errors.RecordNoProto, key);\n        return true;\n      }\n      if (sawProto) {\n        if (refExpressionErrors) {\n          // Store the first redefinition's position, otherwise ignore because\n          // we are parsing ambiguous pattern\n          if (refExpressionErrors.doubleProtoLoc === null) {\n            refExpressionErrors.doubleProtoLoc = key.loc.start;\n          }\n        } else {\n          this.raise(Errors.DuplicateProto, key);\n        }\n      }\n\n      return true;\n    }\n\n    return sawProto;\n  }\n\n  shouldExitDescending(\n    expr: N.Expression | N.PrivateName,\n    potentialArrowAt: number,\n  ): expr is N.ArrowFunctionExpression {\n    return (\n      expr.type === \"ArrowFunctionExpression\" &&\n      this.offsetToSourcePos(expr.start) === potentialArrowAt\n    );\n  }\n\n  // Convenience method to parse an Expression only\n  getExpression(this: Parser): N.Expression & N.ParserOutput {\n    this.enterInitialScopes();\n    this.nextToken();\n    const expr = this.parseExpression() as N.Expression & N.ParserOutput;\n    if (!this.match(tt.eof)) {\n      this.unexpected();\n    }\n    // Unlike parseTopLevel, we need to drain remaining commentStacks\n    // because the top level node is _not_ Program.\n    this.finalizeRemainingComments();\n    expr.comments = this.comments;\n    expr.errors = this.state.errors;\n    if (this.optionFlags & OptionFlags.Tokens) {\n      expr.tokens = this.tokens;\n    }\n    return expr;\n  }\n\n  // ### Expression parsing\n\n  // These nest, from the most general expression type at the top to\n  // 'atomic', nondivisible expression types at the bottom. Most of\n  // the functions will simply let the function (s) below them parse,\n  // and, *if* the syntactic construct they handle is present, wrap\n  // the AST node that the inner parser gave them in another node.\n\n  // Parse a full expression.\n  // - `disallowIn`\n  //   is used to forbid the `in` operator (in for loops initialization expressions)\n  //   When `disallowIn` is true, the production parameter [In] is not present.\n\n  // - `refExpressionErrors `\n  //   provides reference for storing '=' operator inside shorthand\n  //   property assignment in contexts where both object expression\n  //   and object pattern might appear (so it's possible to raise\n  //   delayed syntax error at correct position).\n\n  parseExpression(\n    this: Parser,\n    disallowIn?: boolean,\n    refExpressionErrors?: ExpressionErrors,\n  ): N.Expression {\n    if (disallowIn) {\n      return this.disallowInAnd(() =>\n        this.parseExpressionBase(refExpressionErrors),\n      );\n    }\n    return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));\n  }\n\n  // https://tc39.es/ecma262/#prod-Expression\n  parseExpressionBase(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors,\n  ): N.Expression {\n    const startLoc = this.state.startLoc;\n    const expr = this.parseMaybeAssign(refExpressionErrors);\n    if (this.match(tt.comma)) {\n      const node = this.startNodeAt<N.SequenceExpression>(startLoc);\n      node.expressions = [expr];\n      while (this.eat(tt.comma)) {\n        node.expressions.push(this.parseMaybeAssign(refExpressionErrors));\n      }\n      this.toReferencedList(node.expressions);\n      return this.finishNode(node, \"SequenceExpression\");\n    }\n    return expr;\n  }\n\n  // Set [~In] parameter for assignment expression\n  parseMaybeAssignDisallowIn(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors | null,\n    afterLeftParse?: Function,\n  ) {\n    return this.disallowInAnd(() =>\n      this.parseMaybeAssign(refExpressionErrors, afterLeftParse),\n    );\n  }\n\n  // Set [+In] parameter for assignment expression\n  parseMaybeAssignAllowIn(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors | null,\n    afterLeftParse?: Function,\n  ) {\n    return this.allowInAnd(() =>\n      this.parseMaybeAssign(refExpressionErrors, afterLeftParse),\n    );\n  }\n\n  // This method is only used by\n  // the typescript and flow plugins.\n  setOptionalParametersError(refExpressionErrors: ExpressionErrors) {\n    refExpressionErrors.optionalParametersLoc = this.state.startLoc;\n  }\n\n  // Parse an assignment expression. This includes applications of\n  // operators like `+=`.\n  // https://tc39.es/ecma262/#prod-AssignmentExpression\n  parseMaybeAssign(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors | null,\n    afterLeftParse?: Function,\n  ): N.Expression {\n    const startLoc = this.state.startLoc;\n    if (this.isContextual(tt._yield)) {\n      if (this.prodParam.hasYield) {\n        let left = this.parseYield();\n        if (afterLeftParse) {\n          left = afterLeftParse.call(this, left, startLoc);\n        }\n        return left;\n      }\n    }\n\n    let ownExpressionErrors;\n    if (refExpressionErrors) {\n      ownExpressionErrors = false;\n    } else {\n      refExpressionErrors = new ExpressionErrors();\n      ownExpressionErrors = true;\n    }\n    const { type } = this.state;\n\n    if (type === tt.parenL || tokenIsIdentifier(type)) {\n      this.state.potentialArrowAt = this.state.start;\n    }\n\n    let left = this.parseMaybeConditional(refExpressionErrors);\n    if (afterLeftParse) {\n      left = afterLeftParse.call(this, left, startLoc);\n    }\n    if (tokenIsAssignment(this.state.type)) {\n      const node = this.startNodeAt<N.AssignmentExpression>(startLoc);\n      const operator = this.state.value;\n      node.operator = operator;\n\n      if (this.match(tt.eq)) {\n        this.toAssignable(left, /* isLHS */ true);\n        node.left = left;\n\n        const startIndex = startLoc.index;\n        if (\n          refExpressionErrors.doubleProtoLoc != null &&\n          refExpressionErrors.doubleProtoLoc.index >= startIndex\n        ) {\n          refExpressionErrors.doubleProtoLoc = null; // reset because double __proto__ is valid in assignment expression\n        }\n        if (\n          refExpressionErrors.shorthandAssignLoc != null &&\n          refExpressionErrors.shorthandAssignLoc.index >= startIndex\n        ) {\n          refExpressionErrors.shorthandAssignLoc = null; // reset because shorthand default was used correctly\n        }\n        if (\n          refExpressionErrors.privateKeyLoc != null &&\n          refExpressionErrors.privateKeyLoc.index >= startIndex\n        ) {\n          this.checkDestructuringPrivate(refExpressionErrors);\n          refExpressionErrors.privateKeyLoc = null; // reset because `({ #x: x })` is an assignable pattern\n        }\n      } else {\n        node.left = left as unknown as N.Assignable; // checked a few lines further down\n      }\n\n      this.next();\n      node.right = this.parseMaybeAssign();\n      this.checkLVal(left, this.finishNode(node, \"AssignmentExpression\"));\n      // @ts-expect-error todo(flow->ts) improve node types\n      return node;\n    } else if (ownExpressionErrors) {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n\n    return left;\n  }\n\n  // Parse a ternary conditional (`?:`) operator.\n  // https://tc39.es/ecma262/#prod-ConditionalExpression\n\n  parseMaybeConditional(\n    this: Parser,\n    refExpressionErrors: ExpressionErrors,\n  ): N.Expression {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprOps(refExpressionErrors);\n\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n\n    return this.parseConditional(expr, startLoc, refExpressionErrors);\n  }\n\n  parseConditional(\n    this: Parser,\n    expr: N.Expression,\n    startLoc: Position,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.Expression {\n    if (this.eat(tt.question)) {\n      const node = this.startNodeAt<N.ConditionalExpression>(startLoc);\n      node.test = expr;\n      node.consequent = this.parseMaybeAssignAllowIn();\n      this.expect(tt.colon);\n      node.alternate = this.parseMaybeAssign();\n      return this.finishNode(node, \"ConditionalExpression\");\n    }\n    return expr;\n  }\n\n  parseMaybeUnaryOrPrivate(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors,\n  ): N.Expression | N.PrivateName {\n    return this.match(tt.privateName)\n      ? this.parsePrivateName()\n      : this.parseMaybeUnary(refExpressionErrors);\n  }\n\n  // Start the precedence parser.\n  // https://tc39.es/ecma262/#prod-ShortCircuitExpression\n\n  parseExprOps(\n    this: Parser,\n    refExpressionErrors: ExpressionErrors,\n  ): N.Expression {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);\n\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n\n    return this.parseExprOp(expr, startLoc, -1);\n  }\n\n  // Parse binary operators with the operator precedence parsing\n  // algorithm. `left` is the left-hand side of the operator.\n  // `minPrec` provides context that allows the function to stop and\n  // defer further parser to one of its callers when it encounters an\n  // operator that has a lower precedence than the set it is parsing.\n\n  parseExprOp(\n    this: Parser,\n    left: N.Expression | N.PrivateName,\n    leftStartLoc: Position,\n    minPrec: number,\n  ): N.Expression {\n    if (this.isPrivateName(left)) {\n      // https://tc39.es/ecma262/#prod-RelationalExpression\n      // RelationalExpression [In, Yield, Await]\n      //   [+In] PrivateIdentifier in ShiftExpression[?Yield, ?Await]\n\n      const value = this.getPrivateNameSV(left);\n\n      if (\n        minPrec >= tokenOperatorPrecedence(tt._in) ||\n        !this.prodParam.hasIn ||\n        !this.match(tt._in)\n      ) {\n        this.raise(Errors.PrivateInExpectedIn, left, {\n          identifierName: value,\n        });\n      }\n\n      this.classScope.usePrivateName(value, left.loc.start);\n    }\n\n    const op = this.state.type;\n    if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(tt._in))) {\n      let prec = tokenOperatorPrecedence(op);\n      if (prec > minPrec) {\n        if (op === tt.pipeline) {\n          this.expectPlugin(\"pipelineOperator\");\n          if (this.state.inFSharpPipelineDirectBody) {\n            // PrivateName must be followed by `in`, but we have `|>`\n            return left as N.Expression;\n          }\n          this.checkPipelineAtInfixOperator(left as N.Expression, leftStartLoc);\n        }\n        const node = this.startNodeAt<N.LogicalExpression | N.BinaryExpression>(\n          leftStartLoc,\n        );\n        node.left = left;\n        node.operator = this.state.value;\n\n        const logical = op === tt.logicalOR || op === tt.logicalAND;\n        const coalesce = op === tt.nullishCoalescing;\n\n        if (coalesce) {\n          // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.\n          // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.\n          prec = tokenOperatorPrecedence(tt.logicalAND);\n        }\n\n        this.next();\n\n        if (\n          !process.env.BABEL_8_BREAKING &&\n          op === tt.pipeline &&\n          // @ts-expect-error: Only in Babel 7\n          this.hasPlugin([\"pipelineOperator\", { proposal: \"minimal\" }])\n        ) {\n          if (this.state.type === tt._await && this.prodParam.hasAwait) {\n            throw this.raise(\n              Errors.UnexpectedAwaitAfterPipelineBody,\n              this.state.startLoc,\n            );\n          }\n        }\n\n        node.right = this.parseExprOpRightExpr(op, prec);\n        const finishedNode = this.finishNode(\n          node,\n          logical || coalesce ? \"LogicalExpression\" : \"BinaryExpression\",\n        );\n        /* this check is for all ?? operators\n         * a ?? b && c for this example\n         * when op is coalesce and nextOp is logical (&&), throw at the pos of nextOp that it can not be mixed.\n         * Symmetrically it also throws when op is logical and nextOp is coalesce\n         */\n        const nextOp = this.state.type;\n        if (\n          (coalesce && (nextOp === tt.logicalOR || nextOp === tt.logicalAND)) ||\n          (logical && nextOp === tt.nullishCoalescing)\n        ) {\n          throw this.raise(\n            Errors.MixingCoalesceWithLogical,\n            this.state.startLoc,\n          );\n        }\n\n        return this.parseExprOp(finishedNode, leftStartLoc, minPrec);\n      }\n    }\n    // PrivateName is followed by `in` and handled by the previous if statement\n    return left as N.Expression;\n  }\n\n  // Helper function for `parseExprOp`. Parse the right-hand side of binary-\n  // operator expressions, then apply any operator-specific functions.\n\n  parseExprOpRightExpr(\n    this: Parser,\n    op: TokenType,\n    prec: number,\n  ): N.Expression {\n    const startLoc = this.state.startLoc;\n    switch (op) {\n      case tt.pipeline:\n        switch (this.getPluginOption(\"pipelineOperator\", \"proposal\")) {\n          case \"hack\":\n            return this.withTopicBindingContext(() => {\n              return this.parseHackPipeBody();\n            });\n\n          case \"fsharp\":\n            return this.withSoloAwaitPermittingContext(() => {\n              return this.parseFSharpPipelineBody(prec);\n            });\n        }\n\n        if (\n          !process.env.BABEL_8_BREAKING &&\n          // @ts-expect-error: Babel 7 only\n          this.getPluginOption(\"pipelineOperator\", \"proposal\") === \"smart\"\n        ) {\n          return this.withTopicBindingContext(() => {\n            if (this.prodParam.hasYield && this.isContextual(tt._yield)) {\n              throw this.raise(Errors.PipeBodyIsTighter, this.state.startLoc);\n            }\n            return this.parseSmartPipelineBodyInStyle(\n              this.parseExprOpBaseRightExpr(op, prec),\n              startLoc,\n            );\n          });\n        }\n\n      // Falls through.\n      default:\n        return this.parseExprOpBaseRightExpr(op, prec);\n    }\n  }\n\n  // Helper function for `parseExprOpRightExpr`. Parse the right-hand side of\n  // binary-operator expressions without applying any operator-specific functions.\n\n  parseExprOpBaseRightExpr(\n    this: Parser,\n    op: TokenType,\n    prec: number,\n  ): N.Expression {\n    const startLoc = this.state.startLoc;\n\n    return this.parseExprOp(\n      this.parseMaybeUnaryOrPrivate(),\n      startLoc,\n      tokenIsRightAssociative(op) ? prec - 1 : prec,\n    );\n  }\n\n  parseHackPipeBody(this: Parser): N.Expression {\n    const { startLoc } = this.state;\n    const body = this.parseMaybeAssign();\n    const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(\n      // @ts-expect-error TS2345: Argument of type 'string' is not assignable to parameter of type '\"ArrowFunctionExpression\" | \"YieldExpression\" | \"AssignmentExpression\" | \"ConditionalExpression\"'.\n      body.type,\n    );\n\n    // TODO: Check how to handle type casts in Flow and TS once they are supported\n    if (requiredParentheses && !body.extra?.parenthesized) {\n      this.raise(Errors.PipeUnparenthesizedBody, startLoc, {\n        type: body.type as UnparenthesizedPipeBodyTypes,\n      });\n    }\n    if (!this.topicReferenceWasUsedInCurrentContext()) {\n      // A Hack pipe body must use the topic reference at least once.\n      this.raise(Errors.PipeTopicUnused, startLoc);\n    }\n\n    return body;\n  }\n\n  checkExponentialAfterUnary(\n    node: N.AwaitExpression | Undone<N.UnaryExpression>,\n  ) {\n    if (this.match(tt.exponent)) {\n      this.raise(Errors.UnexpectedTokenUnaryExponentiation, node.argument);\n    }\n  }\n\n  // Parse unary operators, both prefix and postfix.\n  // https://tc39.es/ecma262/#prod-UnaryExpression\n  parseMaybeUnary(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors | null,\n    sawUnary?: boolean,\n  ): N.Expression {\n    const startLoc = this.state.startLoc;\n    const isAwait = this.isContextual(tt._await);\n\n    if (isAwait && this.recordAwaitIfAllowed()) {\n      this.next();\n      const expr = this.parseAwait(startLoc);\n      if (!sawUnary) this.checkExponentialAfterUnary(expr);\n      return expr;\n    }\n    const update = this.match(tt.incDec);\n    const node = this.startNode<N.UnaryExpression | N.UpdateExpression>();\n    if (tokenIsPrefix(this.state.type)) {\n      node.operator = this.state.value;\n      node.prefix = true;\n\n      if (this.match(tt._throw)) {\n        this.expectPlugin(\"throwExpressions\");\n      }\n      const isDelete = this.match(tt._delete);\n      this.next();\n\n      node.argument = this.parseMaybeUnary(null, true);\n\n      this.checkExpressionErrors(refExpressionErrors, true);\n\n      if (this.state.strict && isDelete) {\n        const arg = node.argument;\n\n        if (arg.type === \"Identifier\") {\n          this.raise(Errors.StrictDelete, node);\n        } else if (this.hasPropertyAsPrivateName(arg)) {\n          this.raise(Errors.DeletePrivateField, node);\n        }\n      }\n\n      if (!update) {\n        if (!sawUnary) {\n          this.checkExponentialAfterUnary(node as Undone<N.UnaryExpression>);\n        }\n        return this.finishNode(node, \"UnaryExpression\");\n      }\n    }\n\n    const expr = this.parseUpdate(\n      // @ts-expect-error using \"Undone\" node as \"done\"\n      node,\n      update,\n      refExpressionErrors,\n    );\n\n    if (isAwait) {\n      const { type } = this.state;\n      const startsExpr = this.hasPlugin(\"v8intrinsic\")\n        ? tokenCanStartExpression(type)\n        : tokenCanStartExpression(type) && !this.match(tt.modulo);\n      if (startsExpr && !this.isAmbiguousAwait()) {\n        this.raiseOverwrite(Errors.AwaitNotInAsyncContext, startLoc);\n        return this.parseAwait(startLoc);\n      }\n    }\n\n    return expr;\n  }\n\n  // https://tc39.es/ecma262/#prod-UpdateExpression\n  parseUpdate(\n    this: Parser,\n    node: N.Expression,\n    update: boolean,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.Expression {\n    if (update) {\n      const updateExpressionNode = node as Undone<N.UpdateExpression>;\n      this.checkLVal(\n        updateExpressionNode.argument,\n        this.finishNode(updateExpressionNode, \"UpdateExpression\"),\n      );\n      return node;\n    }\n\n    const startLoc = this.state.startLoc;\n    let expr = this.parseExprSubscripts(refExpressionErrors);\n    if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;\n    while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {\n      const node = this.startNodeAt<N.UpdateExpression>(startLoc);\n      node.operator = this.state.value;\n      node.prefix = false;\n      node.argument = expr;\n      this.next();\n      this.checkLVal(expr, (expr = this.finishNode(node, \"UpdateExpression\")));\n    }\n    return expr;\n  }\n\n  // Parse call, dot, and `[]`-subscript expressions.\n  // https://tc39.es/ecma262/#prod-LeftHandSideExpression\n  parseExprSubscripts(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.Expression {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprAtom(refExpressionErrors);\n\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n\n    return this.parseSubscripts(expr, startLoc);\n  }\n\n  parseSubscripts(\n    this: Parser,\n    base: N.Expression,\n    startLoc: Position,\n    noCalls?: boolean | null,\n  ): N.Expression {\n    const state = {\n      optionalChainMember: false,\n      maybeAsyncArrow: this.atPossibleAsyncArrow(base),\n      stop: false,\n    };\n    do {\n      base = this.parseSubscript(base, startLoc, noCalls, state);\n\n      // After parsing a subscript, this isn't \"async\" for sure.\n      state.maybeAsyncArrow = false;\n    } while (!state.stop);\n    return base;\n  }\n\n  /**\n   * @param state Set 'state.stop = true' to indicate that we should stop parsing subscripts.\n   *   state.optionalChainMember to indicate that the member is currently in OptionalChain\n   */\n  parseSubscript(\n    this: Parser,\n    base: N.Expression,\n    startLoc: Position,\n    noCalls: boolean | undefined | null,\n    state: N.ParseSubscriptState,\n  ): N.Expression {\n    const { type } = this.state;\n    if (!noCalls && type === tt.doubleColon) {\n      return this.parseBind(base, startLoc, noCalls, state);\n    } else if (tokenIsTemplate(type)) {\n      return this.parseTaggedTemplateExpression(base, startLoc, state);\n    }\n\n    let optional = false;\n\n    if (type === tt.questionDot) {\n      if (noCalls) {\n        this.raise(Errors.OptionalChainingNoNew, this.state.startLoc);\n        if (this.lookaheadCharCode() === charCodes.leftParenthesis) {\n          // stop at `?.` when parsing `new a?.()`\n          state.stop = true;\n          return base;\n        }\n      }\n      state.optionalChainMember = optional = true;\n      this.next();\n    }\n\n    if (!noCalls && this.match(tt.parenL)) {\n      return this.parseCoverCallAndAsyncArrowHead(\n        base,\n        startLoc,\n        state,\n        optional,\n      );\n    } else {\n      const computed = this.eat(tt.bracketL);\n      if (computed || optional || this.eat(tt.dot)) {\n        return this.parseMember(base, startLoc, state, computed, optional);\n      } else {\n        state.stop = true;\n        return base;\n      }\n    }\n  }\n\n  // base[?Yield, ?Await] [ Expression[+In, ?Yield, ?Await] ]\n  // base[?Yield, ?Await] . IdentifierName\n  // base[?Yield, ?Await] . PrivateIdentifier\n  //   where `base` is one of CallExpression, MemberExpression and OptionalChain\n  parseMember(\n    this: Parser,\n    base: N.Expression,\n    startLoc: Position,\n    state: N.ParseSubscriptState,\n    computed: boolean,\n    optional: boolean,\n  ): N.OptionalMemberExpression | N.MemberExpression {\n    const node = this.startNodeAt<\n      N.OptionalMemberExpression | N.MemberExpression\n    >(startLoc);\n    node.object = base;\n    node.computed = computed;\n    if (computed) {\n      node.property = this.parseExpression();\n      this.expect(tt.bracketR);\n    } else if (this.match(tt.privateName)) {\n      if (base.type === \"Super\") {\n        this.raise(Errors.SuperPrivateField, startLoc);\n      }\n      this.classScope.usePrivateName(this.state.value, this.state.startLoc);\n      node.property = this.parsePrivateName();\n    } else {\n      node.property = this.parseIdentifier(true);\n    }\n\n    if (state.optionalChainMember) {\n      (node as N.OptionalMemberExpression).optional = optional;\n      return this.finishNode(node, \"OptionalMemberExpression\");\n    } else {\n      return this.finishNode(node, \"MemberExpression\");\n    }\n  }\n\n  // https://github.com/tc39/proposal-bind-operator#syntax\n  parseBind(\n    this: Parser,\n    base: N.Expression,\n    startLoc: Position,\n    noCalls: boolean | undefined | null,\n    state: N.ParseSubscriptState,\n  ): N.Expression {\n    const node = this.startNodeAt<N.BindExpression>(startLoc);\n    node.object = base;\n    this.next(); // eat '::'\n    node.callee = this.parseNoCallExpr();\n    state.stop = true;\n    return this.parseSubscripts(\n      this.finishNode(node, \"BindExpression\"),\n      startLoc,\n      noCalls,\n    );\n  }\n\n  // https://tc39.es/ecma262/#prod-CoverCallExpressionAndAsyncArrowHead\n  // CoverCallExpressionAndAsyncArrowHead\n  // CallExpression[?Yield, ?Await] Arguments[?Yield, ?Await]\n  // OptionalChain[?Yield, ?Await] Arguments[?Yield, ?Await]\n  parseCoverCallAndAsyncArrowHead(\n    this: Parser,\n    base: N.Expression,\n    startLoc: Position,\n    state: N.ParseSubscriptState,\n    optional: boolean,\n  ): N.Expression {\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    let refExpressionErrors: ExpressionErrors | null = null;\n\n    this.state.maybeInArrowParameters = true;\n    this.next(); // eat `(`\n\n    const node = this.startNodeAt<N.CallExpression | N.OptionalCallExpression>(\n      startLoc,\n    );\n    node.callee = base;\n    const { maybeAsyncArrow, optionalChainMember } = state;\n\n    if (maybeAsyncArrow) {\n      this.expressionScope.enter(newAsyncArrowScope());\n      refExpressionErrors = new ExpressionErrors();\n    }\n\n    if (optionalChainMember) {\n      // @ts-expect-error when optionalChainMember is true, node must be an optional call\n      node.optional = optional;\n    }\n\n    if (optional) {\n      node.arguments = this.parseCallExpressionArguments(tt.parenR);\n    } else {\n      node.arguments = this.parseCallExpressionArguments(\n        tt.parenR,\n        base.type !== \"Super\",\n        node,\n        refExpressionErrors,\n      );\n    }\n    let finishedNode:\n      | N.CallExpression\n      | N.OptionalCallExpression\n      | N.ArrowFunctionExpression = this.finishCallExpression(\n      node,\n      optionalChainMember,\n    );\n\n    if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {\n      /*:: invariant(refExpressionErrors != null) */\n      state.stop = true;\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      finishedNode = this.parseAsyncArrowFromCallExpression(\n        this.startNodeAt<N.ArrowFunctionExpression>(startLoc),\n        finishedNode as N.CallExpression,\n      );\n    } else {\n      if (maybeAsyncArrow) {\n        this.checkExpressionErrors(refExpressionErrors, true);\n        this.expressionScope.exit();\n      }\n      this.toReferencedArguments(finishedNode);\n    }\n\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n\n    return finishedNode;\n  }\n\n  toReferencedArguments(\n    node: N.CallExpression | N.OptionalCallExpression,\n    isParenthesizedExpr?: boolean,\n  ) {\n    this.toReferencedListDeep(node.arguments, isParenthesizedExpr);\n  }\n\n  // MemberExpression [?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]\n  // CallExpression [?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]\n  parseTaggedTemplateExpression(\n    this: Parser,\n    base: N.Expression,\n    startLoc: Position,\n    state: N.ParseSubscriptState,\n  ): N.TaggedTemplateExpression {\n    const node = this.startNodeAt<N.TaggedTemplateExpression>(startLoc);\n    node.tag = base;\n    node.quasi = this.parseTemplate(true);\n    if (state.optionalChainMember) {\n      this.raise(Errors.OptionalChainingNoTemplate, startLoc);\n    }\n    return this.finishNode(node, \"TaggedTemplateExpression\");\n  }\n\n  atPossibleAsyncArrow(base: N.Expression): boolean {\n    return (\n      base.type === \"Identifier\" &&\n      base.name === \"async\" &&\n      this.state.lastTokEndLoc.index === base.end &&\n      !this.canInsertSemicolon() &&\n      // check there are no escape sequences, such as \\u{61}sync\n      base.end - base.start === 5 &&\n      this.offsetToSourcePos(base.start) === this.state.potentialArrowAt\n    );\n  }\n\n  finishCallExpression<T extends N.CallExpression | N.OptionalCallExpression>(\n    node: Undone<T>,\n    optional: boolean,\n  ): T {\n    if (node.callee.type === \"Import\") {\n      if (node.arguments.length === 0 || node.arguments.length > 2) {\n        this.raise(Errors.ImportCallArity, node);\n      } else {\n        for (const arg of node.arguments) {\n          if (arg.type === \"SpreadElement\") {\n            this.raise(Errors.ImportCallSpreadArgument, arg);\n          }\n        }\n      }\n    }\n    return this.finishNode(\n      node,\n      optional ? \"OptionalCallExpression\" : \"CallExpression\",\n    );\n  }\n\n  parseCallExpressionArguments(\n    this: Parser,\n    close: TokenType,\n    allowPlaceholder?: boolean,\n    nodeForExtra?: Undone<N.Node> | null,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): Array<N.Expression> {\n    const elts: N.Expression[] = [];\n    let first = true;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(tt.comma);\n        if (this.match(close)) {\n          if (nodeForExtra) {\n            this.addTrailingCommaExtraToNode(nodeForExtra);\n          }\n          this.next();\n          break;\n        }\n      }\n\n      elts.push(\n        this.parseExprListItem(false, refExpressionErrors, allowPlaceholder),\n      );\n    }\n\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n\n    return elts;\n  }\n\n  shouldParseAsyncArrow(): boolean {\n    return this.match(tt.arrow) && !this.canInsertSemicolon();\n  }\n\n  parseAsyncArrowFromCallExpression(\n    this: Parser,\n    node: Undone<N.ArrowFunctionExpression>,\n    call: N.CallExpression,\n  ): N.ArrowFunctionExpression {\n    this.resetPreviousNodeTrailingComments(call);\n    this.expect(tt.arrow);\n    this.parseArrowExpression(\n      node,\n      call.arguments,\n      true,\n      call.extra?.trailingCommaLoc,\n    );\n    // mark inner comments of `async()` as inner comments of `async () =>`\n    if (call.innerComments) {\n      setInnerComments(node, call.innerComments);\n    }\n    // mark trailing comments of `async` to be inner comments\n    if (call.callee.trailingComments) {\n      setInnerComments(node, call.callee.trailingComments);\n    }\n    return node as N.ArrowFunctionExpression;\n  }\n\n  // Parse a no-call expression (like argument of `new` or `::` operators).\n  // https://tc39.es/ecma262/#prod-MemberExpression\n  parseNoCallExpr(this: Parser): N.Expression {\n    const startLoc = this.state.startLoc;\n    return this.parseSubscripts(this.parseExprAtom(), startLoc, true);\n  }\n\n  // Parse an atomic expression — either a single token that is an\n  // expression, an expression started by a keyword like `function` or\n  // `new`, or an expression wrapped in punctuation like `()`, `[]`,\n  // or `{}`.\n\n  // https://tc39.es/ecma262/#prod-PrimaryExpression\n  // https://tc39.es/ecma262/#prod-AsyncArrowFunction\n  // PrimaryExpression\n  // Super\n  // Import\n  // AsyncArrowFunction\n\n  parseExprAtom(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.Expression {\n    let node;\n    let decorators: N.Decorator[] | null = null;\n\n    const { type } = this.state;\n    switch (type) {\n      case tt._super:\n        return this.parseSuper();\n\n      case tt._import:\n        node = this.startNode<N.MetaProperty | N.Import | N.ImportExpression>();\n        this.next();\n\n        if (this.match(tt.dot)) {\n          return this.parseImportMetaProperty(node as Undone<N.MetaProperty>);\n        }\n\n        if (this.match(tt.parenL)) {\n          if (this.optionFlags & OptionFlags.CreateImportExpressions) {\n            return this.parseImportCall(node as Undone<N.ImportExpression>);\n          } else {\n            return this.finishNode(node, \"Import\");\n          }\n        } else {\n          this.raise(Errors.UnsupportedImport, this.state.lastTokStartLoc);\n          return this.finishNode(node, \"Import\");\n        }\n\n      case tt._this:\n        node = this.startNode<N.ThisExpression>();\n        this.next();\n        return this.finishNode(node, \"ThisExpression\");\n\n      case tt._do: {\n        return this.parseDo(this.startNode(), false);\n      }\n\n      case tt.slash:\n      case tt.slashAssign: {\n        this.readRegexp();\n        return this.parseRegExpLiteral(this.state.value);\n      }\n\n      case tt.num:\n        return this.parseNumericLiteral(this.state.value);\n\n      case tt.bigint:\n        return this.parseBigIntLiteral(this.state.value);\n\n      case tt.string:\n        return this.parseStringLiteral(this.state.value);\n\n      case tt._null:\n        return this.parseNullLiteral();\n\n      case tt._true:\n        return this.parseBooleanLiteral(true);\n      case tt._false:\n        return this.parseBooleanLiteral(false);\n\n      case tt.parenL: {\n        const canBeArrow = this.state.potentialArrowAt === this.state.start;\n        return this.parseParenAndDistinguishExpression(canBeArrow);\n      }\n\n      case tt.bracketBarL:\n      case tt.bracketHashL: {\n        return this.parseArrayLike(\n          this.state.type === tt.bracketBarL ? tt.bracketBarR : tt.bracketR,\n          /* canBePattern */ false,\n          /* isTuple */ true,\n        );\n      }\n      case tt.bracketL: {\n        return this.parseArrayLike(\n          tt.bracketR,\n          /* canBePattern */ true,\n          /* isTuple */ false,\n          refExpressionErrors,\n        );\n      }\n      case tt.braceBarL:\n      case tt.braceHashL: {\n        return this.parseObjectLike(\n          this.state.type === tt.braceBarL ? tt.braceBarR : tt.braceR,\n          /* isPattern */ false,\n          /* isRecord */ true,\n        );\n      }\n      case tt.braceL: {\n        return this.parseObjectLike(\n          tt.braceR,\n          /* isPattern */ false,\n          /* isRecord */ false,\n          refExpressionErrors,\n        );\n      }\n      case tt._function:\n        return this.parseFunctionOrFunctionSent();\n\n      case tt.at:\n        decorators = this.parseDecorators();\n      // fall through\n      case tt._class:\n        return this.parseClass(\n          this.maybeTakeDecorators(\n            decorators,\n            this.startNode<N.ClassExpression>(),\n          ),\n          false,\n        );\n\n      case tt._new:\n        return this.parseNewOrNewTarget();\n\n      case tt.templateNonTail:\n      case tt.templateTail:\n        return this.parseTemplate(false);\n\n      // BindExpression[Yield]\n      //   :: MemberExpression[?Yield]\n      case tt.doubleColon: {\n        node = this.startNode<N.BindExpression>();\n        this.next();\n        node.object = null;\n        const callee = (node.callee = this.parseNoCallExpr());\n        if (callee.type === \"MemberExpression\") {\n          return this.finishNode(node, \"BindExpression\");\n        } else {\n          throw this.raise(Errors.UnsupportedBind, callee);\n        }\n      }\n\n      case tt.privateName: {\n        // Standalone private names are only allowed in \"#x in obj\"\n        // expressions, and they are directly handled by callers of\n        // parseExprOp. If we reach this, the input is always invalid.\n        // We can throw a better error message and recover, rather than\n        // just throwing \"Unexpected token\" (which is the default\n        // behavior of this big switch statement).\n        this.raise(Errors.PrivateInExpectedIn, this.state.startLoc, {\n          identifierName: this.state.value,\n        });\n        return this.parsePrivateName() as unknown as N.Expression;\n      }\n\n      case tt.moduloAssign: {\n        return this.parseTopicReferenceThenEqualsSign(tt.modulo, \"%\");\n      }\n\n      case tt.xorAssign: {\n        return this.parseTopicReferenceThenEqualsSign(tt.bitwiseXOR, \"^\");\n      }\n\n      case tt.doubleCaret:\n      case tt.doubleAt: {\n        return this.parseTopicReference(\"hack\");\n      }\n\n      case tt.bitwiseXOR:\n      case tt.modulo:\n      case tt.hash: {\n        const pipeProposal = this.getPluginOption(\n          \"pipelineOperator\",\n          \"proposal\",\n        );\n\n        if (pipeProposal) {\n          return this.parseTopicReference(pipeProposal);\n        }\n        this.unexpected();\n        break;\n      }\n\n      case tt.lt: {\n        const lookaheadCh = this.input.codePointAt(this.nextTokenStart());\n        if (\n          isIdentifierStart(lookaheadCh) || // Element/Type Parameter <foo>\n          lookaheadCh === charCodes.greaterThan // Fragment <>\n        ) {\n          this.expectOnePlugin([\"jsx\", \"flow\", \"typescript\"]);\n        } else {\n          this.unexpected();\n        }\n        break;\n      }\n\n      default:\n        if (!process.env.BABEL_8_BREAKING && type === tt.decimal) {\n          return this.parseDecimalLiteral(this.state.value);\n        }\n\n        if (tokenIsIdentifier(type)) {\n          if (\n            this.isContextual(tt._module) &&\n            this.lookaheadInLineCharCode() === charCodes.leftCurlyBrace\n          ) {\n            return this.parseModuleExpression();\n          }\n          const canBeArrow = this.state.potentialArrowAt === this.state.start;\n          const containsEsc = this.state.containsEsc;\n          const id = this.parseIdentifier();\n\n          if (\n            !containsEsc &&\n            id.name === \"async\" &&\n            !this.canInsertSemicolon()\n          ) {\n            const { type } = this.state;\n            if (type === tt._function) {\n              this.resetPreviousNodeTrailingComments(id);\n              this.next();\n              return this.parseAsyncFunctionExpression(\n                this.startNodeAtNode(id),\n              );\n            } else if (tokenIsIdentifier(type)) {\n              // If the next token begins with \"=\", commit to parsing an async\n              // arrow function. (Peeking ahead for \"=\" lets us avoid a more\n              // expensive full-token lookahead on this common path.)\n              if (this.lookaheadCharCode() === charCodes.equalsTo) {\n                // although `id` is not used in async arrow unary function,\n                // we don't need to reset `async`'s trailing comments because\n                // it will be attached to the upcoming async arrow binding identifier\n                return this.parseAsyncArrowUnaryFunction(\n                  this.startNodeAtNode(id),\n                );\n              } else {\n                // Otherwise, treat \"async\" as an identifier and let calling code\n                // deal with the current tt.name token.\n                return id;\n              }\n            } else if (type === tt._do) {\n              this.resetPreviousNodeTrailingComments(id);\n              return this.parseDo(this.startNodeAtNode(id), true);\n            }\n          }\n\n          if (\n            canBeArrow &&\n            this.match(tt.arrow) &&\n            !this.canInsertSemicolon()\n          ) {\n            this.next();\n            return this.parseArrowExpression(\n              this.startNodeAtNode(id),\n              [id],\n              false,\n            );\n          }\n\n          return id;\n        } else {\n          this.unexpected();\n        }\n    }\n  }\n\n  // This helper method should only be called\n  // when the parser has reached a potential Hack pipe topic token\n  // that is followed by an equals sign.\n  // See <https://github.com/js-choi/proposal-hack-pipes>.\n  // If we find ^= or %= in an expression position\n  // (i.e., the tt.moduloAssign or tt.xorAssign token types), and if the\n  // Hack-pipes proposal is active with ^ or % as its topicToken, then the ^ or\n  // % could be the topic token (e.g., in x |> ^==y or x |> ^===y), and so we\n  // reparse the current token as ^ or %.\n  // Otherwise, this throws an unexpected-token error.\n  parseTopicReferenceThenEqualsSign(\n    topicTokenType: TokenType,\n    topicTokenValue: string,\n  ): N.Expression {\n    const pipeProposal = this.getPluginOption(\"pipelineOperator\", \"proposal\");\n\n    if (pipeProposal) {\n      // Set the most-recent token to be a topic token\n      // given by the tokenType and tokenValue.\n      // Now the next readToken() call (in parseTopicReference)\n      // will consume that “topic token”.\n      this.state.type = topicTokenType;\n      this.state.value = topicTokenValue;\n      // Rewind the tokenizer to the end of the “topic token”, so that the\n      // following token starts at the equals sign after that topic token.\n      this.state.pos--;\n      this.state.end--;\n      // This is safe to do since the preceding character was either ^ or %, and\n      // thus not a newline.\n      this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);\n      // Now actually consume the topic token.\n      return this.parseTopicReference(pipeProposal);\n    } else {\n      this.unexpected();\n    }\n  }\n\n  // This helper method should only be called\n  // when the proposal-pipeline-operator plugin is active,\n  // and when the parser has reached a potential Hack pipe topic token.\n  // Although a pipe-operator proposal is assumed to be active,\n  // its configuration might not match the current token’s type.\n  // See <https://github.com/js-choi/proposal-hack-pipes>.\n  parseTopicReference(pipeProposal: string): N.Expression {\n    const node = this.startNode<N.TopicReference>();\n    const startLoc = this.state.startLoc;\n    const tokenType = this.state.type;\n\n    // Consume the current token.\n    this.next();\n\n    // If the pipe-operator plugin’s configuration matches the current token’s type,\n    // then this will return `node`, will have been finished as a topic reference.\n    // Otherwise, this will throw a `PipeTopicUnconfiguredToken` error.\n    return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);\n  }\n\n  // This helper method attempts to finish the given `node`\n  // into a topic-reference node for the given `pipeProposal`.\n  // See <https://github.com/js-choi/proposal-hack-pipes>.\n  //\n  // The method assumes that any topic token was consumed before it was called.\n  //\n  // If the `pipelineOperator` plugin is active,\n  // and if the given `tokenType` matches the plugin’s configuration,\n  // then this method will return the finished `node`.\n  //\n  // If the `pipelineOperator` plugin is active,\n  // but if the given `tokenType` does not match the plugin’s configuration,\n  // then this method will throw a `PipeTopicUnconfiguredToken` error.\n  finishTopicReference<\n    T extends N.PipelinePrimaryTopicReference | N.TopicReference,\n  >(\n    node: Undone<T>,\n    startLoc: Position,\n    pipeProposal: string,\n    tokenType: TokenType,\n  ): T {\n    if (\n      this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)\n    ) {\n      // The token matches the plugin’s configuration.\n      // The token is therefore a topic reference.\n\n      if (process.env.BABEL_8_BREAKING || pipeProposal === \"hack\") {\n        if (!this.topicReferenceIsAllowedInCurrentContext()) {\n          this.raise(Errors.PipeTopicUnbound, startLoc);\n        }\n\n        // Register the topic reference so that its pipe body knows\n        // that its topic was used at least once.\n        this.registerTopicReference();\n\n        return this.finishNode(node, \"TopicReference\");\n      } else {\n        // pipeProposal is \"smart\"\n\n        if (!this.topicReferenceIsAllowedInCurrentContext()) {\n          this.raise(Errors.PrimaryTopicNotAllowed, startLoc);\n        }\n        this.registerTopicReference();\n        return this.finishNode(node, \"PipelinePrimaryTopicReference\");\n      }\n    } else {\n      // The token does not match the plugin’s configuration.\n      throw this.raise(Errors.PipeTopicUnconfiguredToken, startLoc, {\n        token: tokenLabelName(tokenType),\n      });\n    }\n  }\n\n  // This helper method tests whether the given token type\n  // matches the pipelineOperator parser plugin’s configuration.\n  // If the active pipe proposal is Hack style,\n  // and if the given token is the same as the plugin configuration’s `topicToken`,\n  // then this is a valid topic reference.\n  // If the active pipe proposal is smart mix,\n  // then the topic token must always be `#`.\n  // If the active pipe proposal is neither (e.g., \"minimal\"(Babel 7) or \"fsharp\"),\n  // then an error is thrown.\n  testTopicReferenceConfiguration(\n    pipeProposal: string,\n    startLoc: Position,\n    tokenType: TokenType,\n  ): boolean {\n    switch (pipeProposal) {\n      case \"hack\": {\n        return this.hasPlugin([\n          \"pipelineOperator\",\n          {\n            // @ts-expect-error token must have a label\n            topicToken: tokenLabelName(tokenType),\n          },\n        ]);\n      }\n      case \"smart\":\n        return tokenType === tt.hash;\n      default:\n        throw this.raise(Errors.PipeTopicRequiresHackPipes, startLoc);\n    }\n  }\n\n  // async [no LineTerminator here] AsyncArrowBindingIdentifier[?Yield] [no LineTerminator here] => AsyncConciseBody[?In]\n  parseAsyncArrowUnaryFunction(\n    this: Parser,\n    node: Undone<N.ArrowFunctionExpression>,\n  ): N.ArrowFunctionExpression {\n    // We don't need to push a new ParameterDeclarationScope here since we are sure\n    // 1) it is an async arrow, 2) no biding pattern is allowed in params\n    this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));\n    const params = [this.parseIdentifier()];\n    this.prodParam.exit();\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(Errors.LineTerminatorBeforeArrow, this.state.curPosition());\n    }\n    this.expect(tt.arrow);\n    // let foo = async bar => {};\n    return this.parseArrowExpression(node, params, true);\n  }\n\n  // https://github.com/tc39/proposal-do-expressions\n  // https://github.com/tc39/proposal-async-do-expressions\n  parseDo(\n    this: Parser,\n    node: Undone<N.DoExpression>,\n    isAsync: boolean,\n  ): N.DoExpression {\n    this.expectPlugin(\"doExpressions\");\n    if (isAsync) {\n      this.expectPlugin(\"asyncDoExpressions\");\n    }\n    node.async = isAsync;\n    this.next(); // eat `do`\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    if (isAsync) {\n      // AsyncDoExpression :\n      // async [no LineTerminator here] do Block[~Yield, +Await, ~Return]\n      this.prodParam.enter(ParamKind.PARAM_AWAIT);\n      node.body = this.parseBlock();\n      this.prodParam.exit();\n    } else {\n      node.body = this.parseBlock();\n    }\n\n    this.state.labels = oldLabels;\n    return this.finishNode(node, \"DoExpression\");\n  }\n\n  // Parse the `super` keyword\n  parseSuper(): N.Super {\n    const node = this.startNode<N.Super>();\n    this.next(); // eat `super`\n    if (\n      this.match(tt.parenL) &&\n      !this.scope.allowDirectSuper &&\n      !(this.optionFlags & OptionFlags.AllowSuperOutsideMethod)\n    ) {\n      this.raise(Errors.SuperNotAllowed, node);\n    } else if (\n      !this.scope.allowSuper &&\n      !(this.optionFlags & OptionFlags.AllowSuperOutsideMethod)\n    ) {\n      this.raise(Errors.UnexpectedSuper, node);\n    }\n\n    if (\n      !this.match(tt.parenL) &&\n      !this.match(tt.bracketL) &&\n      !this.match(tt.dot)\n    ) {\n      this.raise(Errors.UnsupportedSuper, node);\n    }\n\n    return this.finishNode(node, \"Super\");\n  }\n\n  parsePrivateName(): N.PrivateName {\n    const node = this.startNode<N.PrivateName>();\n    const id = this.startNodeAt<N.Identifier>(\n      // The position is hardcoded because we merge `#` and name into a single\n      // tt.privateName token\n      createPositionWithColumnOffset(this.state.startLoc, 1),\n    );\n    const name = this.state.value;\n    this.next(); // eat #name;\n    node.id = this.createIdentifier(id, name);\n    return this.finishNode(node, \"PrivateName\");\n  }\n\n  parseFunctionOrFunctionSent(\n    this: Parser,\n  ): N.FunctionExpression | N.MetaProperty {\n    const node = this.startNode<N.FunctionExpression | N.MetaProperty>();\n\n    // We do not do parseIdentifier here because when parseFunctionOrFunctionSent\n    // is called we already know that the current token is a \"name\" with the value \"function\"\n    // This will improve perf a tiny little bit as we do not do validation but more importantly\n    // here is that parseIdentifier will remove an item from the expression stack\n    // if \"function\" or \"class\" is parsed as identifier (in objects e.g.), which should not happen here.\n    this.next(); // eat `function`\n\n    if (this.prodParam.hasYield && this.match(tt.dot)) {\n      const meta = this.createIdentifier(\n        this.startNodeAtNode<N.Identifier>(node),\n        \"function\",\n      );\n      this.next(); // eat `.`\n      // https://github.com/tc39/proposal-function.sent#syntax-1\n      if (this.match(tt._sent)) {\n        this.expectPlugin(\"functionSent\");\n      } else if (!this.hasPlugin(\"functionSent\")) {\n        // The code wasn't `function.sent` but just `function.`, so a simple error is less confusing.\n        this.unexpected();\n      }\n      return this.parseMetaProperty(\n        node as Undone<N.MetaProperty>,\n        meta,\n        \"sent\",\n      );\n    }\n    return this.parseFunction(node as Undone<N.FunctionExpression>);\n  }\n\n  parseMetaProperty(\n    node: Undone<N.MetaProperty>,\n    meta: N.Identifier,\n    propertyName: string,\n  ): N.MetaProperty {\n    node.meta = meta;\n\n    const containsEsc = this.state.containsEsc;\n\n    node.property = this.parseIdentifier(true);\n\n    if (node.property.name !== propertyName || containsEsc) {\n      this.raise(Errors.UnsupportedMetaProperty, node.property, {\n        target: meta.name,\n        onlyValidPropertyName: propertyName,\n      });\n    }\n\n    return this.finishNode(node, \"MetaProperty\");\n  }\n\n  // https://tc39.es/ecma262/#prod-ImportMeta\n  parseImportMetaProperty(\n    this: Parser,\n    node: Undone<N.MetaProperty | N.ImportExpression>,\n  ): N.MetaProperty | N.ImportExpression {\n    const id = this.createIdentifier(\n      this.startNodeAtNode<N.Identifier>(node),\n      \"import\",\n    );\n    this.next(); // eat `.`\n\n    if (this.isContextual(tt._meta)) {\n      if (!this.inModule) {\n        this.raise(Errors.ImportMetaOutsideModule, id);\n      }\n      this.sawUnambiguousESM = true;\n    } else if (this.isContextual(tt._source) || this.isContextual(tt._defer)) {\n      const isSource = this.isContextual(tt._source);\n\n      this.expectPlugin(\n        isSource ? \"sourcePhaseImports\" : \"deferredImportEvaluation\",\n      );\n      if (!(this.optionFlags & OptionFlags.CreateImportExpressions)) {\n        throw this.raise(\n          Errors.DynamicImportPhaseRequiresImportExpressions,\n          this.state.startLoc,\n          {\n            phase: this.state.value,\n          },\n        );\n      }\n      this.next();\n      (node as Undone<N.ImportExpression>).phase = isSource\n        ? \"source\"\n        : \"defer\";\n      return this.parseImportCall(node as Undone<N.ImportExpression>);\n    }\n\n    return this.parseMetaProperty(node as Undone<N.MetaProperty>, id, \"meta\");\n  }\n\n  parseLiteralAtNode<T extends N.Node>(\n    value: any,\n    type: T[\"type\"],\n    node: any,\n  ): T {\n    this.addExtra(node, \"rawValue\", value);\n    this.addExtra(\n      node,\n      \"raw\",\n      this.input.slice(this.offsetToSourcePos(node.start), this.state.end),\n    );\n    node.value = value;\n    this.next();\n    return this.finishNode<T>(node, type);\n  }\n\n  parseLiteral<T extends N.Node>(value: any, type: T[\"type\"]): T {\n    const node = this.startNode();\n    return this.parseLiteralAtNode(value, type, node);\n  }\n\n  parseStringLiteral(value: any) {\n    return this.parseLiteral<N.StringLiteral>(value, \"StringLiteral\");\n  }\n\n  parseNumericLiteral(value: any) {\n    return this.parseLiteral<N.NumericLiteral>(value, \"NumericLiteral\");\n  }\n\n  parseBigIntLiteral(value: any) {\n    return this.parseLiteral<N.BigIntLiteral>(value, \"BigIntLiteral\");\n  }\n\n  // TODO: Remove this in Babel 8\n  parseDecimalLiteral(value: any) {\n    return this.parseLiteral<N.DecimalLiteral>(value, \"DecimalLiteral\");\n  }\n\n  parseRegExpLiteral(value: {\n    value: any;\n    pattern: string;\n    flags: N.RegExpLiteral[\"flags\"];\n  }) {\n    const node = this.startNode<N.RegExpLiteral>();\n    this.addExtra(\n      node,\n      \"raw\",\n      this.input.slice(this.offsetToSourcePos(node.start), this.state.end),\n    );\n    node.pattern = value.pattern;\n    node.flags = value.flags;\n    this.next();\n    return this.finishNode(node, \"RegExpLiteral\");\n  }\n\n  parseBooleanLiteral(value: boolean) {\n    const node = this.startNode<N.BooleanLiteral>();\n    node.value = value;\n    this.next();\n    return this.finishNode(node, \"BooleanLiteral\");\n  }\n\n  parseNullLiteral() {\n    const node = this.startNode<N.NullLiteral>();\n    this.next();\n    return this.finishNode(node, \"NullLiteral\");\n  }\n\n  // https://tc39.es/ecma262/#prod-CoverParenthesizedExpressionAndArrowParameterList\n  parseParenAndDistinguishExpression(\n    this: Parser,\n    canBeArrow: boolean,\n  ): N.Expression {\n    const startLoc = this.state.startLoc;\n\n    let val;\n    this.next(); // eat `(`\n    this.expressionScope.enter(newArrowHeadScope());\n\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.maybeInArrowParameters = true;\n    this.state.inFSharpPipelineDirectBody = false;\n\n    const innerStartLoc = this.state.startLoc;\n    const exprList: (N.Expression | N.RestElement)[] = [];\n    const refExpressionErrors = new ExpressionErrors();\n    let first = true;\n    let spreadStartLoc;\n    let optionalCommaStartLoc;\n\n    while (!this.match(tt.parenR)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(\n          tt.comma,\n          refExpressionErrors.optionalParametersLoc === null\n            ? null\n            : refExpressionErrors.optionalParametersLoc,\n        );\n        if (this.match(tt.parenR)) {\n          optionalCommaStartLoc = this.state.startLoc;\n          break;\n        }\n      }\n\n      if (this.match(tt.ellipsis)) {\n        const spreadNodeStartLoc = this.state.startLoc;\n        spreadStartLoc = this.state.startLoc;\n        exprList.push(\n          this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc),\n        );\n\n        if (!this.checkCommaAfterRest(charCodes.rightParenthesis)) {\n          break;\n        }\n      } else {\n        exprList.push(\n          this.parseMaybeAssignAllowIn(\n            refExpressionErrors,\n            this.parseParenItem,\n          ),\n        );\n      }\n    }\n\n    const innerEndLoc = this.state.lastTokEndLoc;\n    this.expect(tt.parenR);\n\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n\n    let arrowNode = this.startNodeAt<N.ArrowFunctionExpression>(startLoc);\n    if (\n      canBeArrow &&\n      this.shouldParseArrow(exprList) &&\n      (arrowNode = this.parseArrow(arrowNode))\n    ) {\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      this.parseArrowExpression(arrowNode, exprList, false);\n      // @ts-expect-error todo(flow->ts) improve node types\n      return arrowNode;\n    }\n    this.expressionScope.exit();\n\n    if (!exprList.length) {\n      this.unexpected(this.state.lastTokStartLoc);\n    }\n    if (optionalCommaStartLoc) this.unexpected(optionalCommaStartLoc);\n    if (spreadStartLoc) this.unexpected(spreadStartLoc);\n    this.checkExpressionErrors(refExpressionErrors, true);\n\n    this.toReferencedListDeep(exprList, /* isParenthesizedExpr */ true);\n    if (exprList.length > 1) {\n      val = this.startNodeAt<N.SequenceExpression>(innerStartLoc);\n      val.expressions = exprList as N.Expression[];\n      // finish node at current location so it can pick up comments after `)`\n      this.finishNode(val, \"SequenceExpression\");\n      this.resetEndLocation(val, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n\n    return this.wrapParenthesis(\n      startLoc,\n      // @ts-expect-error todo(flow->ts)\n      val,\n    );\n  }\n\n  wrapParenthesis(startLoc: Position, expression: N.Expression): N.Expression {\n    if (!(this.optionFlags & OptionFlags.CreateParenthesizedExpressions)) {\n      this.addExtra(expression, \"parenthesized\", true);\n      this.addExtra(expression, \"parenStart\", startLoc.index);\n\n      this.takeSurroundingComments(\n        expression,\n        startLoc.index,\n        this.state.lastTokEndLoc.index,\n      );\n\n      return expression;\n    }\n\n    const parenExpression =\n      this.startNodeAt<N.ParenthesizedExpression>(startLoc);\n    parenExpression.expression = expression;\n    return this.finishNode(parenExpression, \"ParenthesizedExpression\");\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars -- `params` is used in typescript plugin\n  shouldParseArrow(params: Array<N.Node>): boolean {\n    return !this.canInsertSemicolon();\n  }\n\n  parseArrow(\n    node: Undone<N.ArrowFunctionExpression>,\n  ): Undone<N.ArrowFunctionExpression> | undefined {\n    if (this.eat(tt.arrow)) {\n      return node;\n    }\n  }\n\n  parseParenItem<T extends N.Expression | N.RestElement | N.SpreadElement>(\n    node: T,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    startLoc: Position,\n  ): T | N.TypeCastExpression | N.TsTypeCastExpression {\n    return node;\n  }\n\n  parseNewOrNewTarget(this: Parser): N.NewExpression | N.MetaProperty {\n    const node = this.startNode<N.NewExpression | N.MetaProperty>();\n    this.next();\n    if (this.match(tt.dot)) {\n      // https://tc39.es/ecma262/#prod-NewTarget\n      const meta = this.createIdentifier(\n        this.startNodeAtNode<N.Identifier>(node),\n        \"new\",\n      );\n      this.next();\n      const metaProp = this.parseMetaProperty(\n        node as Undone<N.MetaProperty>,\n        meta,\n        \"target\",\n      );\n\n      if (\n        !this.scope.inNonArrowFunction &&\n        !this.scope.inClass &&\n        !(this.optionFlags & OptionFlags.AllowNewTargetOutsideFunction)\n      ) {\n        this.raise(Errors.UnexpectedNewTarget, metaProp);\n      }\n\n      return metaProp;\n    }\n\n    return this.parseNew(node as Undone<N.NewExpression>);\n  }\n\n  // New's precedence is slightly tricky. It must allow its argument to\n  // be a `[]` or dot subscript expression, but not a call — at least,\n  // not without wrapping it in parentheses. Thus, it uses the noCalls\n  // argument to parseSubscripts to prevent it from consuming the\n  // argument list.\n  // https://tc39.es/ecma262/#prod-NewExpression\n  parseNew(this: Parser, node: Undone<N.NewExpression>): N.NewExpression {\n    this.parseNewCallee(node);\n\n    if (this.eat(tt.parenL)) {\n      const args = this.parseExprList(tt.parenR);\n      this.toReferencedList(args);\n      // (parseExprList should be all non-null in this case)\n      node.arguments = args;\n    } else {\n      node.arguments = [];\n    }\n\n    return this.finishNode(node, \"NewExpression\");\n  }\n\n  parseNewCallee(this: Parser, node: Undone<N.NewExpression>): void {\n    const isImport = this.match(tt._import);\n    const callee = this.parseNoCallExpr();\n    node.callee = callee;\n    if (\n      isImport &&\n      (callee.type === \"Import\" || callee.type === \"ImportExpression\")\n    ) {\n      this.raise(Errors.ImportCallNotNewExpression, callee);\n    }\n  }\n\n  // Parse template expression.\n\n  parseTemplateElement(isTagged: boolean): N.TemplateElement {\n    const { start, startLoc, end, value } = this.state;\n    const elemStart = start + 1;\n    const elem = this.startNodeAt<N.TemplateElement>(\n      createPositionWithColumnOffset(startLoc, 1),\n    );\n    if (value === null) {\n      if (!isTagged) {\n        this.raise(\n          Errors.InvalidEscapeSequenceTemplate,\n          // FIXME: Adding 1 is probably wrong.\n          createPositionWithColumnOffset(\n            this.state.firstInvalidTemplateEscapePos,\n            1,\n          ),\n        );\n      }\n    }\n\n    const isTail = this.match(tt.templateTail);\n    const endOffset = isTail ? -1 : -2;\n    const elemEnd = end + endOffset;\n    elem.value = {\n      raw: this.input.slice(elemStart, elemEnd).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: value === null ? null : value.slice(1, endOffset),\n    };\n    elem.tail = isTail;\n    this.next();\n    const finishedNode = this.finishNode(elem, \"TemplateElement\");\n    this.resetEndLocation(\n      finishedNode,\n      createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset),\n    );\n    return finishedNode;\n  }\n\n  // https://tc39.es/ecma262/#prod-TemplateLiteral\n  parseTemplate(this: Parser, isTagged: boolean): N.TemplateLiteral {\n    const node = this.startNode<N.TemplateLiteral>();\n    let curElt = this.parseTemplateElement(isTagged);\n    const quasis = [curElt];\n    const substitutions = [];\n    while (!curElt.tail) {\n      substitutions.push(this.parseTemplateSubstitution());\n      this.readTemplateContinuation();\n      quasis.push((curElt = this.parseTemplateElement(isTagged)));\n    }\n    // Type cast from (N.Expression[] | N.TsType[]). parseTemplateSubstitution\n    // returns consistent results.\n    node.expressions = substitutions as N.Expression[] | N.TsType[];\n    node.quasis = quasis;\n    return this.finishNode(node, \"TemplateLiteral\");\n  }\n\n  // This is overwritten by the TypeScript plugin to parse template types\n  parseTemplateSubstitution(this: Parser): N.Expression | N.TsType {\n    return this.parseExpression();\n  }\n\n  // Parse an object literal, binding pattern, or record.\n\n  parseObjectLike(\n    close: TokenType,\n    isPattern: true,\n    isRecord?: boolean | null,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.ObjectPattern;\n  parseObjectLike(\n    close: TokenType,\n    isPattern: false,\n    isRecord?: false | null,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.ObjectExpression;\n  parseObjectLike(\n    close: TokenType,\n    isPattern: false,\n    isRecord?: true,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.RecordExpression;\n  parseObjectLike<T extends N.ObjectPattern | N.ObjectExpression>(\n    this: Parser,\n    close: TokenType,\n    isPattern: boolean,\n    isRecord?: boolean | null,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): T {\n    if (isRecord) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    let sawProto = false;\n    let first = true;\n    const node = this.startNode<\n      N.ObjectExpression | N.ObjectPattern | N.RecordExpression\n    >();\n\n    node.properties = [];\n    this.next();\n\n    while (!this.match(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(tt.comma);\n        if (this.match(close)) {\n          this.addTrailingCommaExtraToNode(node);\n          break;\n        }\n      }\n\n      let prop;\n      if (isPattern) {\n        prop = this.parseBindingProperty();\n      } else {\n        prop = this.parsePropertyDefinition(refExpressionErrors);\n        sawProto = this.checkProto(\n          prop,\n          isRecord,\n          sawProto,\n          refExpressionErrors,\n        );\n      }\n\n      if (\n        isRecord &&\n        !this.isObjectProperty(prop) &&\n        prop.type !== \"SpreadElement\"\n      ) {\n        this.raise(Errors.InvalidRecordProperty, prop);\n      }\n\n      if (!process.env.BABEL_8_BREAKING) {\n        // @ts-expect-error shorthand may not index prop\n        if (prop.shorthand) {\n          this.addExtra(prop, \"shorthand\", true);\n        }\n      }\n\n      // @ts-expect-error Fixme: refine typings\n      node.properties.push(prop);\n    }\n\n    this.next();\n\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let type = \"ObjectExpression\";\n    if (isPattern) {\n      type = \"ObjectPattern\";\n    } else if (isRecord) {\n      type = \"RecordExpression\";\n    }\n    // @ts-expect-error type is well defined\n    return this.finishNode(node, type);\n  }\n\n  addTrailingCommaExtraToNode(node: Undone<N.Node>): void {\n    this.addExtra(node, \"trailingComma\", this.state.lastTokStartLoc.index);\n    this.addExtra(node, \"trailingCommaLoc\", this.state.lastTokStartLoc, false);\n  }\n\n  // Check grammar production:\n  //   IdentifierName *_opt PropertyName\n  // It is used in `parsePropertyDefinition` to detect AsyncMethod and Accessors\n  maybeAsyncOrAccessorProp(\n    prop: Undone<N.ObjectProperty>,\n  ): prop is typeof prop & { key: N.Identifier } {\n    return (\n      !prop.computed &&\n      prop.key.type === \"Identifier\" &&\n      (this.isLiteralPropertyName() ||\n        this.match(tt.bracketL) ||\n        this.match(tt.star))\n    );\n  }\n\n  // https://tc39.es/ecma262/#prod-PropertyDefinition\n  parsePropertyDefinition(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.ObjectMember | N.SpreadElement {\n    let decorators = [];\n    if (this.match(tt.at)) {\n      if (this.hasPlugin(\"decorators\")) {\n        this.raise(Errors.UnsupportedPropertyDecorator, this.state.startLoc);\n      }\n\n      // we needn't check if decorators (stage 0) plugin is enabled since it's checked by\n      // the call to this.parseDecorator\n      while (this.match(tt.at)) {\n        decorators.push(this.parseDecorator());\n      }\n    }\n\n    const prop = this.startNode<N.ObjectProperty>();\n    let isAsync = false;\n    let isAccessor = false;\n    let startLoc;\n\n    if (this.match(tt.ellipsis)) {\n      if (decorators.length) this.unexpected();\n      return this.parseSpread();\n    }\n\n    if (decorators.length) {\n      prop.decorators = decorators;\n      decorators = [];\n    }\n\n    prop.method = false;\n\n    if (refExpressionErrors) {\n      startLoc = this.state.startLoc;\n    }\n\n    let isGenerator = this.eat(tt.star);\n    this.parsePropertyNamePrefixOperator(prop);\n    const containsEsc = this.state.containsEsc;\n    this.parsePropertyName(prop, refExpressionErrors);\n\n    if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {\n      const { key } = prop;\n      const keyName = key.name;\n      // https://tc39.es/ecma262/#prod-AsyncMethod\n      // https://tc39.es/ecma262/#prod-AsyncGeneratorMethod\n      if (keyName === \"async\" && !this.hasPrecedingLineBreak()) {\n        isAsync = true;\n        this.resetPreviousNodeTrailingComments(key);\n        isGenerator = this.eat(tt.star);\n        this.parsePropertyName(prop);\n      }\n      // get PropertyName[?Yield, ?Await] () { FunctionBody[~Yield, ~Await] }\n      // set PropertyName[?Yield, ?Await] ( PropertySetParameterList ) { FunctionBody[~Yield, ~Await] }\n      if (keyName === \"get\" || keyName === \"set\") {\n        isAccessor = true;\n        this.resetPreviousNodeTrailingComments(key);\n        prop.kind = keyName;\n        if (this.match(tt.star)) {\n          isGenerator = true;\n          this.raise(Errors.AccessorIsGenerator, this.state.curPosition(), {\n            kind: keyName,\n          });\n          this.next();\n        }\n        this.parsePropertyName(prop);\n      }\n    }\n\n    return this.parseObjPropValue(\n      prop,\n      startLoc,\n      isGenerator,\n      isAsync,\n      false /* isPattern */,\n      isAccessor,\n      refExpressionErrors,\n    );\n  }\n\n  getGetterSetterExpectedParamCount(\n    method: N.ObjectMethod | N.ClassMethod,\n  ): number {\n    return method.kind === \"get\" ? 0 : 1;\n  }\n\n  // This exists so we can override within the ESTree plugin\n  getObjectOrClassMethodParams(method: N.ObjectMethod | N.ClassMethod) {\n    return method.params;\n  }\n\n  // get methods aren't allowed to have any parameters\n  // set methods must have exactly 1 parameter which is not a rest parameter\n  checkGetterSetterParams(method: N.ObjectMethod | N.ClassMethod): void {\n    const paramCount = this.getGetterSetterExpectedParamCount(method);\n    const params = this.getObjectOrClassMethodParams(method);\n\n    if (params.length !== paramCount) {\n      this.raise(\n        method.kind === \"get\" ? Errors.BadGetterArity : Errors.BadSetterArity,\n        method,\n      );\n    }\n\n    if (\n      method.kind === \"set\" &&\n      params[params.length - 1]?.type === \"RestElement\"\n    ) {\n      this.raise(Errors.BadSetterRestParameter, method);\n    }\n  }\n\n  // https://tc39.es/ecma262/#prod-MethodDefinition\n  parseObjectMethod(\n    this: Parser,\n    prop: Undone<N.ObjectMethod>,\n    isGenerator: boolean,\n    isAsync: boolean,\n    isPattern: boolean,\n    isAccessor: boolean,\n  ): N.ObjectMethod | undefined | null {\n    if (isAccessor) {\n      // isAccessor implies isAsync: false, isPattern: false, isGenerator: false\n      const finishedProp = this.parseMethod(\n        prop,\n        // This _should_ be false, but with error recovery, we allow it to be\n        // set for informational purposes\n        isGenerator,\n        /* isAsync */ false,\n        /* isConstructor */ false,\n        false,\n        \"ObjectMethod\",\n      );\n      this.checkGetterSetterParams(finishedProp);\n      return finishedProp;\n    }\n\n    if (isAsync || isGenerator || this.match(tt.parenL)) {\n      if (isPattern) this.unexpected();\n      prop.kind = \"method\";\n      prop.method = true;\n      return this.parseMethod(\n        prop,\n        isGenerator,\n        isAsync,\n        /* isConstructor */ false,\n        false,\n        \"ObjectMethod\",\n      );\n    }\n  }\n\n  // if `isPattern` is true, parse https://tc39.es/ecma262/#prod-BindingProperty\n  // else https://tc39.es/ecma262/#prod-PropertyDefinition\n  parseObjectProperty(\n    this: Parser,\n    prop: Undone<N.ObjectProperty>,\n    startLoc: Position | undefined | null,\n    isPattern: boolean,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.ObjectProperty | undefined | null {\n    prop.shorthand = false;\n\n    if (this.eat(tt.colon)) {\n      prop.value = isPattern\n        ? this.parseMaybeDefault(this.state.startLoc)\n        : this.parseMaybeAssignAllowIn(refExpressionErrors);\n\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n\n    if (!prop.computed && prop.key.type === \"Identifier\") {\n      // PropertyDefinition:\n      //   IdentifierReference\n      //   CoverInitializedName\n      // Note: `{ eval } = {}` will be checked in `checkLVal` later.\n      this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);\n\n      if (isPattern) {\n        prop.value = this.parseMaybeDefault(\n          startLoc,\n          cloneIdentifier(prop.key),\n        );\n      } else if (this.match(tt.eq)) {\n        const shorthandAssignLoc = this.state.startLoc;\n        if (refExpressionErrors != null) {\n          if (refExpressionErrors.shorthandAssignLoc === null) {\n            refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;\n          }\n        } else {\n          this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);\n        }\n        prop.value = this.parseMaybeDefault(\n          startLoc,\n          cloneIdentifier(prop.key),\n        );\n      } else {\n        prop.value = cloneIdentifier(prop.key);\n      }\n      prop.shorthand = true;\n\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n  }\n\n  parseObjPropValue<T extends N.ObjectMember>(\n    this: Parser,\n    prop: Undone<T>,\n    startLoc: Position | undefined | null,\n    isGenerator: boolean,\n    isAsync: boolean,\n    isPattern: boolean,\n    isAccessor: boolean,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): T {\n    const node = (this.parseObjectMethod(\n      prop as Undone<N.ObjectMethod>,\n      isGenerator,\n      isAsync,\n      isPattern,\n      isAccessor,\n    ) ||\n      this.parseObjectProperty(\n        prop as Undone<N.ObjectProperty>,\n        startLoc,\n        isPattern,\n        refExpressionErrors,\n      )) as T;\n\n    if (!node) this.unexpected();\n\n    return node;\n  }\n\n  // https://tc39.es/ecma262/#prod-PropertyName\n  // when refExpressionErrors presents, it will parse private name\n  // and record the position of the first private name\n  parsePropertyName(\n    this: Parser,\n    prop:\n      | Undone<N.ObjectOrClassMember | N.ClassMember>\n      | N.TsNamedTypeElementBase,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): void {\n    if (this.eat(tt.bracketL)) {\n      (prop as Undone<N.ObjectOrClassMember>).computed = true;\n      prop.key = this.parseMaybeAssignAllowIn();\n      this.expect(tt.bracketR);\n    } else {\n      // We check if it's valid for it to be a private name when we push it.\n      const { type, value } = this.state;\n      let key;\n      // most un-computed property names are identifiers\n      if (tokenIsKeywordOrIdentifier(type)) {\n        key = this.parseIdentifier(true);\n      } else {\n        switch (type) {\n          case tt.num:\n            key = this.parseNumericLiteral(value);\n            break;\n          case tt.string:\n            key = this.parseStringLiteral(value);\n            break;\n          case tt.bigint:\n            key = this.parseBigIntLiteral(value);\n            break;\n          case tt.privateName: {\n            // the class private key has been handled in parseClassElementName\n            const privateKeyLoc = this.state.startLoc;\n            if (refExpressionErrors != null) {\n              if (refExpressionErrors.privateKeyLoc === null) {\n                refExpressionErrors.privateKeyLoc = privateKeyLoc;\n              }\n            } else {\n              this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);\n            }\n            key = this.parsePrivateName();\n            break;\n          }\n          default:\n            if (!process.env.BABEL_8_BREAKING && type === tt.decimal) {\n              key = this.parseDecimalLiteral(value);\n              break;\n            }\n\n            this.unexpected();\n        }\n      }\n      (prop as any).key = key;\n      if (type !== tt.privateName) {\n        // ClassPrivateProperty is never computed, so we don't assign in that case.\n        prop.computed = false;\n      }\n    }\n  }\n\n  // Initialize empty function node.\n\n  initFunction(node: N.BodilessFunctionOrMethodBase, isAsync: boolean): void {\n    node.id = null;\n    node.generator = false;\n    node.async = isAsync;\n  }\n\n  // Parse object or class method.\n\n  parseMethod<T extends N.ObjectMethod | N.ClassMethod | N.ClassPrivateMethod>(\n    this: Parser,\n    node: Undone<T>,\n    isGenerator: boolean,\n    isAsync: boolean,\n    isConstructor: boolean,\n    allowDirectSuper: boolean,\n    type: T[\"type\"],\n    inClassScope: boolean = false,\n  ): T {\n    this.initFunction(node, isAsync);\n    node.generator = isGenerator;\n    this.scope.enter(\n      ScopeFlag.FUNCTION |\n        ScopeFlag.SUPER |\n        (inClassScope ? ScopeFlag.CLASS : 0) |\n        (allowDirectSuper ? ScopeFlag.DIRECT_SUPER : 0),\n    );\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n    this.parseFunctionParams(node, isConstructor);\n    const finishedNode = this.parseFunctionBodyAndFinish(node, type, true);\n    this.prodParam.exit();\n    this.scope.exit();\n\n    return finishedNode;\n  }\n\n  // parse an array literal or tuple literal\n  // https://tc39.es/ecma262/#prod-ArrayLiteral\n  // https://tc39.es/proposal-record-tuple/#prod-TupleLiteral\n  parseArrayLike(\n    this: Parser,\n    close: TokenType,\n    canBePattern: boolean,\n    isTuple: boolean,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.ArrayExpression | N.TupleExpression {\n    if (isTuple) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    const node = this.startNode<N.ArrayExpression | N.TupleExpression>();\n    this.next();\n    node.elements = this.parseExprList(\n      close,\n      /* allowEmpty */ !isTuple,\n      refExpressionErrors,\n      // @ts-expect-error todo(flow->ts)\n      node,\n    );\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return this.finishNode(\n      node,\n      isTuple ? \"TupleExpression\" : \"ArrayExpression\",\n    );\n  }\n\n  // Parse arrow function expression.\n  // If the parameters are provided, they will be converted to an\n  // assignable list.\n  parseArrowExpression(\n    this: Parser,\n    node: Undone<N.ArrowFunctionExpression>,\n    params:\n      | Array<N.Expression | N.SpreadElement>\n      | Array<N.Expression | N.RestElement>,\n    isAsync: boolean,\n    trailingCommaLoc?: Position | null,\n  ): N.ArrowFunctionExpression {\n    this.scope.enter(ScopeFlag.FUNCTION | ScopeFlag.ARROW);\n    let flags = functionFlags(isAsync, false);\n    // ConciseBody[In] :\n    //   [lookahead ≠ {] ExpressionBody[?In, ~Await]\n    //   { FunctionBody[~Yield, ~Await] }\n    if (!this.match(tt.braceL) && this.prodParam.hasIn) {\n      flags |= ParamKind.PARAM_IN;\n    }\n    this.prodParam.enter(flags);\n    this.initFunction(node, isAsync);\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n\n    if (params) {\n      this.state.maybeInArrowParameters = true;\n      this.setArrowFunctionParameters(node, params, trailingCommaLoc);\n    }\n    this.state.maybeInArrowParameters = false;\n    this.parseFunctionBody(node, true);\n\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n\n    return this.finishNode(node, \"ArrowFunctionExpression\");\n  }\n\n  setArrowFunctionParameters(\n    node: Undone<N.ArrowFunctionExpression>,\n    params:\n      | Array<N.Expression | N.SpreadElement>\n      | Array<N.Expression | N.RestElement>,\n    trailingCommaLoc?: Position | null,\n  ): void {\n    this.toAssignableList(params, trailingCommaLoc, false);\n    node.params = params as (N.Pattern | N.TSParameterProperty)[];\n  }\n\n  parseFunctionBodyAndFinish<\n    T extends\n      | N.Function\n      | N.TSDeclareMethod\n      | N.TSDeclareFunction\n      | N.ClassPrivateMethod,\n  >(node: Undone<T>, type: T[\"type\"], isMethod: boolean = false): T {\n    // @ts-expect-error (node is not bodiless if we get here)\n    this.parseFunctionBody(node, false, isMethod);\n    return this.finishNode(node, type);\n  }\n\n  // Parse function body and check parameters.\n  parseFunctionBody(\n    this: Parser,\n    node: Undone<N.Function>,\n    allowExpression?: boolean | null,\n    isMethod: boolean = false,\n  ): void {\n    const isExpression = allowExpression && !this.match(tt.braceL);\n    this.expressionScope.enter(newExpressionScope());\n\n    if (isExpression) {\n      // https://tc39.es/ecma262/#prod-ExpressionBody\n      (node as Undone<N.ArrowFunctionExpression>).body =\n        this.parseMaybeAssign();\n      this.checkParams(node, false, allowExpression, false);\n    } else {\n      const oldStrict = this.state.strict;\n      // Start a new scope with regard to labels\n      // flag (restore them to their old value afterwards).\n      const oldLabels = this.state.labels;\n      this.state.labels = [];\n\n      // FunctionBody[Yield, Await]:\n      //   StatementList[?Yield, ?Await, +Return] opt\n      this.prodParam.enter(\n        this.prodParam.currentFlags() | ParamKind.PARAM_RETURN,\n      );\n      node.body = this.parseBlock(\n        true,\n        false,\n        // Strict mode function checks after we parse the statements in the function body.\n        (hasStrictModeDirective: boolean) => {\n          const nonSimple = !this.isSimpleParamList(node.params);\n\n          if (hasStrictModeDirective && nonSimple) {\n            // This logic is here to align the error location with the ESTree plugin.\n            this.raise(\n              Errors.IllegalLanguageModeDirective,\n              // @ts-expect-error kind may not index node\n              (node.kind === \"method\" || node.kind === \"constructor\") &&\n                // @ts-expect-error key may not index node\n                !!node.key\n                ? // @ts-expect-error node.key has been guarded\n                  node.key.loc.end\n                : node,\n            );\n          }\n\n          const strictModeChanged = !oldStrict && this.state.strict;\n\n          // Add the params to varDeclaredNames to ensure that an error is thrown\n          // if a let/const declaration in the function clashes with one of the params.\n          this.checkParams(\n            node,\n            !this.state.strict && !allowExpression && !isMethod && !nonSimple,\n            allowExpression,\n            strictModeChanged,\n          );\n\n          // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n          if (this.state.strict && node.id) {\n            this.checkIdentifier(\n              node.id,\n              BindingFlag.TYPE_OUTSIDE,\n              strictModeChanged,\n            );\n          }\n        },\n      );\n      this.prodParam.exit();\n      this.state.labels = oldLabels;\n    }\n    this.expressionScope.exit();\n  }\n\n  isSimpleParameter(node: N.Pattern | N.TSParameterProperty): boolean {\n    return node.type === \"Identifier\";\n  }\n\n  isSimpleParamList(\n    params: ReadonlyArray<N.Pattern | N.TSParameterProperty>,\n  ): boolean {\n    for (let i = 0, len = params.length; i < len; i++) {\n      if (!this.isSimpleParameter(params[i])) return false;\n    }\n    return true;\n  }\n\n  checkParams(\n    node: Undone<N.Function>,\n    allowDuplicates: boolean,\n    isArrowFunction?: boolean | null,\n    strictModeChanged: boolean = true,\n  ): void {\n    const checkClashes = !allowDuplicates && new Set<string>();\n    // We create a fake node with the \"ephemeral\" type `FormalParameters`[1]\n    // since we just store an array of parameters. Perhaps someday we can have\n    // something like class FormalParameters extends Array { ... }, which would\n    // also be helpful when traversing this node.\n    //\n    // 1. https://tc39.es/ecma262/#prod-FormalParameters\n    const formalParameters = { type: \"FormalParameters\" } as const;\n    for (const param of node.params) {\n      this.checkLVal(\n        param,\n        formalParameters,\n        BindingFlag.TYPE_VAR,\n        checkClashes,\n        strictModeChanged,\n      );\n    }\n  }\n\n  // Parses a comma-separated list of expressions, and returns them as\n  // an array. `close` is the token type that ends the list, and\n  // `allowEmpty` can be turned on to allow subsequent commas with\n  // nothing in between them to be parsed as `null` (which is needed\n  // for array literals).\n\n  parseExprList(\n    this: Parser,\n    close: TokenType,\n    allowEmpty?: boolean,\n    refExpressionErrors?: ExpressionErrors | null,\n    nodeForExtra?: N.Node | null,\n  ): (N.Expression | null)[] {\n    const elts: (N.Expression | null)[] = [];\n    let first = true;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(tt.comma);\n        if (this.match(close)) {\n          if (nodeForExtra) {\n            this.addTrailingCommaExtraToNode(nodeForExtra);\n          }\n          this.next();\n          break;\n        }\n      }\n\n      elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));\n    }\n    return elts;\n  }\n\n  parseExprListItem(\n    this: Parser,\n    allowEmpty?: boolean,\n    refExpressionErrors?: ExpressionErrors | null,\n    allowPlaceholder?: boolean | null,\n  ): N.Expression | null;\n  parseExprListItem(\n    this: Parser,\n    allowEmpty?: false,\n    refExpressionErrors?: ExpressionErrors | null,\n    allowPlaceholder?: boolean | null,\n  ): N.Expression;\n  parseExprListItem(\n    this: Parser,\n    allowEmpty?: boolean | null,\n    refExpressionErrors?: ExpressionErrors | null,\n    allowPlaceholder?: boolean | null,\n  ): N.Expression | N.SpreadElement | N.ArgumentPlaceholder | null {\n    let elt;\n    if (this.match(tt.comma)) {\n      if (!allowEmpty) {\n        this.raise(Errors.UnexpectedToken, this.state.curPosition(), {\n          unexpected: \",\",\n        });\n      }\n      elt = null;\n    } else if (this.match(tt.ellipsis)) {\n      const spreadNodeStartLoc = this.state.startLoc;\n\n      elt = this.parseParenItem(\n        this.parseSpread(refExpressionErrors),\n        spreadNodeStartLoc,\n      );\n    } else if (this.match(tt.question)) {\n      this.expectPlugin(\"partialApplication\");\n      if (!allowPlaceholder) {\n        this.raise(Errors.UnexpectedArgumentPlaceholder, this.state.startLoc);\n      }\n      const node = this.startNode<N.ArgumentPlaceholder>();\n      this.next();\n      elt = this.finishNode(node, \"ArgumentPlaceholder\");\n    } else {\n      elt = this.parseMaybeAssignAllowIn(\n        refExpressionErrors,\n        this.parseParenItem,\n      );\n    }\n    return elt;\n  }\n\n  // Parse the next token as an identifier. If `liberal` is true (used\n  // when parsing properties), it will also convert keywords into\n  // identifiers.\n  // This shouldn't be used to parse the keywords of meta properties, since they\n  // are not identifiers and cannot contain escape sequences.\n\n  parseIdentifier(liberal?: boolean): N.Identifier {\n    const node = this.startNode<N.Identifier>();\n    const name = this.parseIdentifierName(liberal);\n\n    return this.createIdentifier(node, name);\n  }\n\n  createIdentifier(\n    node: Omit<N.Identifier, \"type\">,\n    name: string,\n  ): N.Identifier {\n    node.name = name;\n    node.loc.identifierName = name;\n\n    return this.finishNode(node, \"Identifier\");\n  }\n\n  parseIdentifierName(liberal?: boolean): string {\n    let name: string;\n\n    const { startLoc, type } = this.state;\n\n    if (tokenIsKeywordOrIdentifier(type)) {\n      name = this.state.value;\n    } else {\n      this.unexpected();\n    }\n\n    const tokenIsKeyword = tokenKeywordOrIdentifierIsKeyword(type);\n\n    if (liberal) {\n      // If the current token is not used as a keyword, set its type to \"tt.name\".\n      // This will prevent this.next() from throwing about unexpected escapes.\n      if (tokenIsKeyword) {\n        this.replaceToken(tt.name);\n      }\n    } else {\n      this.checkReservedWord(name, startLoc, tokenIsKeyword, false);\n    }\n\n    this.next();\n\n    return name;\n  }\n\n  checkReservedWord(\n    word: string,\n    startLoc: Position,\n    checkKeywords: boolean,\n    isBinding: boolean,\n  ): void {\n    // Every JavaScript reserved word is 10 characters or less.\n    if (word.length > 10) {\n      return;\n    }\n    // Most identifiers are not reservedWord-like, they don't need special\n    // treatments afterward, which very likely ends up throwing errors\n    if (!canBeReservedWord(word)) {\n      return;\n    }\n\n    if (checkKeywords && isKeyword(word)) {\n      this.raise(Errors.UnexpectedKeyword, startLoc, {\n        keyword: word,\n      });\n      return;\n    }\n\n    const reservedTest = !this.state.strict\n      ? isReservedWord\n      : isBinding\n        ? isStrictBindReservedWord\n        : isStrictReservedWord;\n\n    if (reservedTest(word, this.inModule)) {\n      this.raise(Errors.UnexpectedReservedWord, startLoc, {\n        reservedWord: word,\n      });\n      return;\n    } else if (word === \"yield\") {\n      if (this.prodParam.hasYield) {\n        this.raise(Errors.YieldBindingIdentifier, startLoc);\n        return;\n      }\n    } else if (word === \"await\") {\n      if (this.prodParam.hasAwait) {\n        this.raise(Errors.AwaitBindingIdentifier, startLoc);\n        return;\n      }\n\n      if (this.scope.inStaticBlock) {\n        this.raise(Errors.AwaitBindingIdentifierInStaticBlock, startLoc);\n        return;\n      }\n\n      this.expressionScope.recordAsyncArrowParametersError(startLoc);\n    } else if (word === \"arguments\") {\n      if (this.scope.inClassAndNotInNonArrowFunction) {\n        this.raise(Errors.ArgumentsInClass, startLoc);\n        return;\n      }\n    }\n  }\n\n  // Returns wether `await` is allowed or not in this context, and if it is\n  // keeps track of it to determine whether a module uses top-level await.\n  recordAwaitIfAllowed(): boolean {\n    const isAwaitAllowed =\n      this.prodParam.hasAwait ||\n      (this.optionFlags & OptionFlags.AllowAwaitOutsideFunction &&\n        !this.scope.inFunction);\n\n    if (isAwaitAllowed && !this.scope.inFunction) {\n      this.state.hasTopLevelAwait = true;\n    }\n\n    return isAwaitAllowed;\n  }\n\n  // Parses await expression inside async function.\n\n  parseAwait(this: Parser, startLoc: Position): N.AwaitExpression {\n    const node = this.startNodeAt<N.AwaitExpression>(startLoc);\n\n    this.expressionScope.recordParameterInitializerError(\n      Errors.AwaitExpressionFormalParameter,\n      node,\n    );\n\n    if (this.eat(tt.star)) {\n      this.raise(Errors.ObsoleteAwaitStar, node);\n    }\n\n    if (\n      !this.scope.inFunction &&\n      !(this.optionFlags & OptionFlags.AllowAwaitOutsideFunction)\n    ) {\n      if (this.isAmbiguousAwait()) {\n        this.ambiguousScriptDifferentAst = true;\n      } else {\n        this.sawUnambiguousESM = true;\n      }\n    }\n\n    if (!this.state.soloAwait) {\n      node.argument = this.parseMaybeUnary(null, true);\n    }\n\n    return this.finishNode(node, \"AwaitExpression\");\n  }\n\n  isAmbiguousAwait(): boolean {\n    if (this.hasPrecedingLineBreak()) return true;\n    const { type } = this.state;\n    return (\n      // All the following expressions are ambiguous:\n      //   await + 0, await - 0, await ( 0 ), await [ 0 ], await / 0 /u, await ``, await of []\n      type === tt.plusMin ||\n      type === tt.parenL ||\n      type === tt.bracketL ||\n      tokenIsTemplate(type) ||\n      (type === tt._of && !this.state.containsEsc) ||\n      // Sometimes the tokenizer generates tt.slash for regexps, and this is\n      // handler by parseExprAtom\n      type === tt.regexp ||\n      type === tt.slash ||\n      // This code could be parsed both as a modulo operator or as an intrinsic:\n      //   await %x(0)\n      (this.hasPlugin(\"v8intrinsic\") && type === tt.modulo)\n    );\n  }\n\n  // Parses yield expression inside generator.\n\n  parseYield(this: Parser): N.YieldExpression {\n    const node = this.startNode<N.YieldExpression>();\n\n    this.expressionScope.recordParameterInitializerError(\n      Errors.YieldInParameter,\n      node,\n    );\n\n    this.next();\n    let delegating = false;\n    let argument: N.Expression | null = null;\n    if (!this.hasPrecedingLineBreak()) {\n      delegating = this.eat(tt.star);\n      switch (this.state.type) {\n        case tt.semi:\n        case tt.eof:\n        case tt.braceR:\n        case tt.parenR:\n        case tt.bracketR:\n        case tt.braceBarR:\n        case tt.colon:\n        case tt.comma:\n          // The above is the complete set of tokens that can\n          // follow an AssignmentExpression, and none of them\n          // can start an AssignmentExpression\n          if (!delegating) break;\n        /* fallthrough */\n        default:\n          argument = this.parseMaybeAssign();\n      }\n    }\n    node.delegate = delegating;\n    node.argument = argument;\n    return this.finishNode(node, \"YieldExpression\");\n  }\n\n  // https://tc39.es/ecma262/#prod-ImportCall\n  parseImportCall(\n    this: Parser,\n    node: Undone<N.ImportExpression>,\n  ): N.ImportExpression {\n    this.next(); // eat tt.parenL\n    node.source = this.parseMaybeAssignAllowIn();\n    node.options = null;\n    if (this.eat(tt.comma)) {\n      if (!this.match(tt.parenR)) {\n        node.options = this.parseMaybeAssignAllowIn();\n\n        if (this.eat(tt.comma) && !this.match(tt.parenR)) {\n          // keep consuming arguments, to then throw ImportCallArity\n          // instead of \"expected )\"\n          do {\n            this.parseMaybeAssignAllowIn();\n          } while (this.eat(tt.comma) && !this.match(tt.parenR));\n\n          this.raise(Errors.ImportCallArity, node);\n        }\n      }\n    }\n    this.expect(tt.parenR);\n    return this.finishNode(node, \"ImportExpression\");\n  }\n\n  // Validates a pipeline (for any of the pipeline Babylon plugins) at the point\n  // of the infix operator `|>`.\n\n  checkPipelineAtInfixOperator(left: N.Expression, leftStartLoc: Position) {\n    // @ts-expect-error Remove this in Babel 8\n    if (this.hasPlugin([\"pipelineOperator\", { proposal: \"smart\" }])) {\n      if (left.type === \"SequenceExpression\") {\n        // Ensure that the pipeline head is not a comma-delimited\n        // sequence expression.\n        this.raise(Errors.PipelineHeadSequenceExpression, leftStartLoc);\n      }\n    }\n  }\n\n  parseSmartPipelineBodyInStyle(childExpr: N.Expression, startLoc: Position) {\n    if (this.isSimpleReference(childExpr)) {\n      const bodyNode = this.startNodeAt<N.PipelineBareFunction>(startLoc);\n      bodyNode.callee = childExpr;\n      return this.finishNode(bodyNode, \"PipelineBareFunction\");\n    } else {\n      const bodyNode = this.startNodeAt<N.PipelineTopicExpression>(startLoc);\n      this.checkSmartPipeTopicBodyEarlyErrors(startLoc);\n      bodyNode.expression = childExpr;\n      return this.finishNode(bodyNode, \"PipelineTopicExpression\");\n    }\n  }\n\n  isSimpleReference(expression: N.Expression): boolean {\n    switch (expression.type) {\n      case \"MemberExpression\":\n        return (\n          !expression.computed && this.isSimpleReference(expression.object)\n        );\n      case \"Identifier\":\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  // This helper method is to be called immediately\n  // after a topic-style smart-mix pipe body is parsed.\n  // The `startLoc` is the starting position of the pipe body.\n\n  checkSmartPipeTopicBodyEarlyErrors(startLoc: Position): void {\n    // If the following token is invalidly `=>`, then throw a human-friendly error\n    // instead of something like 'Unexpected token, expected \";\"'.\n    // For example, `x => x |> y => #` (assuming `#` is the topic reference)\n    // groups into `x => (x |> y) => #`,\n    // and `(x |> y) => #` is an invalid arrow function.\n    // This is because smart-mix `|>` has tighter precedence than `=>`.\n    if (this.match(tt.arrow)) {\n      throw this.raise(Errors.PipelineBodyNoArrow, this.state.startLoc);\n    }\n\n    // A topic-style smart-mix pipe body must use the topic reference at least once.\n    if (!this.topicReferenceWasUsedInCurrentContext()) {\n      this.raise(Errors.PipelineTopicUnused, startLoc);\n    }\n  }\n\n  // Enable topic references from outer contexts within Hack-style pipe bodies.\n  // The function modifies the parser's topic-context state to enable or disable\n  // the use of topic references.\n  // The function then calls a callback, then resets the parser\n  // to the old topic-context state that it had before the function was called.\n\n  withTopicBindingContext<T>(callback: () => T): T {\n    const outerContextTopicState = this.state.topicContext;\n    this.state.topicContext = {\n      // Enable the use of the primary topic reference.\n      maxNumOfResolvableTopics: 1,\n      // Hide the use of any topic references from outer contexts.\n      maxTopicIndex: null,\n    };\n\n    try {\n      return callback();\n    } finally {\n      this.state.topicContext = outerContextTopicState;\n    }\n  }\n\n  // This helper method is used only with the deprecated smart-mix pipe proposal.\n  // Disables topic references from outer contexts within syntax constructs\n  // such as the bodies of iteration statements.\n  // The function modifies the parser's topic-context state to enable or disable\n  // the use of topic references with the smartPipelines plugin. They then run a\n  // callback, then they reset the parser to the old topic-context state that it\n  // had before the function was called.\n\n  withSmartMixTopicForbiddingContext<T>(callback: () => T): T {\n    // TODO(Babel 8): Remove this method\n\n    if (\n      !process.env.BABEL_8_BREAKING &&\n      // @ts-expect-error Babel 7 only\n      this.hasPlugin([\"pipelineOperator\", { proposal: \"smart\" }])\n    ) {\n      // Reset the parser’s topic context only if the smart-mix pipe proposal is active.\n      const outerContextTopicState = this.state.topicContext;\n      this.state.topicContext = {\n        // Disable the use of the primary topic reference.\n        maxNumOfResolvableTopics: 0,\n        // Hide the use of any topic references from outer contexts.\n        maxTopicIndex: null,\n      };\n\n      try {\n        return callback();\n      } finally {\n        this.state.topicContext = outerContextTopicState;\n      }\n    } else {\n      // If the pipe proposal is \"minimal\"(Babel 7), \"fsharp\", or \"hack\",\n      // or if no pipe proposal is active,\n      // then the callback result is returned\n      // without touching any extra parser state.\n      return callback();\n    }\n  }\n\n  withSoloAwaitPermittingContext<T>(callback: () => T): T {\n    const outerContextSoloAwaitState = this.state.soloAwait;\n    this.state.soloAwait = true;\n\n    try {\n      return callback();\n    } finally {\n      this.state.soloAwait = outerContextSoloAwaitState;\n    }\n  }\n\n  allowInAnd<T>(callback: () => T): T {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToSet = ParamKind.PARAM_IN & ~flags;\n    if (prodParamToSet) {\n      this.prodParam.enter(flags | ParamKind.PARAM_IN);\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n    return callback();\n  }\n\n  disallowInAnd<T>(callback: () => T): T {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToClear = ParamKind.PARAM_IN & flags;\n    if (prodParamToClear) {\n      this.prodParam.enter(flags & ~ParamKind.PARAM_IN);\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n    return callback();\n  }\n\n  // Register the use of a topic reference within the current\n  // topic-binding context.\n  registerTopicReference(): void {\n    this.state.topicContext.maxTopicIndex = 0;\n  }\n\n  topicReferenceIsAllowedInCurrentContext(): boolean {\n    return this.state.topicContext.maxNumOfResolvableTopics >= 1;\n  }\n\n  topicReferenceWasUsedInCurrentContext(): boolean {\n    return (\n      this.state.topicContext.maxTopicIndex != null &&\n      this.state.topicContext.maxTopicIndex >= 0\n    );\n  }\n\n  parseFSharpPipelineBody(this: Parser, prec: number): N.Expression {\n    const startLoc = this.state.startLoc;\n\n    this.state.potentialArrowAt = this.state.start;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = true;\n\n    const ret = this.parseExprOp(\n      this.parseMaybeUnaryOrPrivate(),\n      startLoc,\n      prec,\n    );\n\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n\n    return ret;\n  }\n\n  // https://github.com/tc39/proposal-js-module-blocks\n  parseModuleExpression(this: Parser): N.ModuleExpression {\n    this.expectPlugin(\"moduleBlocks\");\n    const node = this.startNode<N.ModuleExpression>();\n    this.next(); // eat \"module\"\n    if (!this.match(tt.braceL)) {\n      this.unexpected(null, tt.braceL);\n    }\n    // start program node immediately after `{`\n    const program = this.startNodeAt<N.Program>(this.state.endLoc);\n    this.next(); // eat `{`\n\n    const revertScopes = this.initializeScopes(/** inModule */ true);\n    this.enterInitialScopes();\n\n    try {\n      node.body = this.parseProgram(program, tt.braceR, \"module\");\n    } finally {\n      revertScopes();\n    }\n    return this.finishNode<N.ModuleExpression>(node, \"ModuleExpression\");\n  }\n\n  // Used in Flow plugin\n  parsePropertyNamePrefixOperator(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    prop: Undone<N.ObjectOrClassMember | N.ClassMember>,\n  ): void {}\n}\n"],"mappings":"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","ignoreList":[]}