{"version":3,"names":["_types","require","_expression","_parseError","_identifier","_scopeflags","_util","_productionParameter","_expressionScope","_options","_index","_location","_node","_lval","_state","loopLabel","kind","LoopLabelKind","Loop","switchLabel","Switch","ParseFunctionFlag","exports","Expression","Declaration","HangingDeclaration","NullableId","Async","ParseStatementFlag","StatementOnly","AllowImportExport","AllowDeclaration","AllowFunctionDeclaration","AllowLabeledFunction","loneSurrogate","keywordRelationalOperator","babel7CompatTokens","tokens","input","startIndex","i","length","token","type","process","env","BABEL_8_BREAKING","loc","start","value","end","hashEndPos","hashEndLoc","createPositionWithColumnOffset","splice","Token","getExportedToken","startLoc","endLoc","tokenIsTemplate","backquoteEnd","backquoteEndLoc","startToken","charCodeAt","templateValue","templateElementEnd","templateElementEndLoc","endToken","slice","StatementParser","ExpressionParser","parseTopLevel","file","program","parseProgram","comments","optionFlags","OptionFlags","Tokens","finishNode","sourceType","options","interpreter","parseInterpreterDirective","parseBlockBody","inModule","AllowUndeclaredExports","scope","undefinedExports","size","localName","at","Array","from","raise","Errors","ModuleExportUndefined","addExtra","state","hasTopLevelAwait","finishedProgram","finishNodeAt","stmtToDirective","stmt","directive","expression","directiveLiteral","expressionValue","raw","offsetToSourcePos","val","match","node","startNode","next","isLet","isContextual","hasFollowingBindingAtom","chStartsBindingIdentifier","ch","pos","isIdentifierStart","lastIndex","test","endCh","codePointAtPos","isIdentifierChar","chStartsBindingPattern","nextTokenStart","nextCh","hasInLineFollowingBindingIdentifierOrBrace","nextTokenInLineStart","startsUsingForOf","containsEsc","lookahead","tokenIsIdentifier","hasFollowingLineBreak","expectPlugin","startsAwaitUsing","isUnparsedContextual","nextTokenInLineStartSince","parseModuleItem","parseStatementLike","parseStatementListItem","annexB","strict","parseStatementOrSloppyAnnexBFunctionDeclaration","allowLabeledFunction","flags","parseStatement","decorators","parseDecorators","parseStatementContent","startType","allowDeclaration","allowFunctionDeclaration","topLevel","parseBreakContinueStatement","parseDebuggerStatement","parseDoWhileStatement","parseForStatement","lookaheadCharCode","StrictFunction","SloppyFunctionAnnexB","SloppyFunction","parseFunctionStatement","unexpected","parseClass","maybeTakeDecorators","parseIfStatement","parseReturnStatement","parseSwitchStatement","parseThrowStatement","parseTryStatement","recordAwaitIfAllowed","AwaitUsingNotInAsyncContext","UnexpectedLexicalDeclaration","parseVarStatement","inTopLevel","UnexpectedUsingDeclaration","parseWhileStatement","parseWithStatement","parseBlock","parseEmptyStatement","nextTokenCharCode","AllowImportExportEverywhere","UnexpectedImportExport","result","parseImport","parseExport","assertModuleNodeAllowed","isAsyncFunction","AsyncFunctionInSingleStatementContext","maybeName","expr","parseExpression","eat","parseLabeledStatement","parseExpressionStatement","ImportOutsideModule","decoratorsEnabledBeforeExport","hasPlugin","getPluginOption","maybeDecorators","classNode","exportNode","DecoratorsBeforeAfterExport","unshift","resetStartLocationFromNode","canHaveLeadingDecorator","allowExport","push","parseDecorator","DecoratorExportClass","UnexpectedLeadingDecorator","expectOnePlugin","expect","wrapParenthesis","paramsStartLoc","parseMaybeDecoratorArguments","DecoratorArgumentsOutsideParentheses","parseIdentifier","startNodeAt","object","classScope","usePrivateName","property","parsePrivateName","computed","parseExprSubscripts","callee","arguments","parseCallExpressionArguments","toReferencedList","isBreak","isLineTerminator","label","semicolon","verifyBreakContinue","labels","lab","name","IllegalBreakContinue","parseHeaderExpression","body","withSmartMixTopicForbiddingContext","pop","awaitAt","enter","ScopeFlag","OTHER","parseFor","startsWithLet","startsWithAwaitUsing","starsWithUsingDeclaration","isLetOrUsing","initNode","parseVar","init","isForIn","ForInUsing","declarations","parseForIn","startsWithAsync","refExpressionErrors","ExpressionErrors","isForOf","ForOfLet","ForOfAsync","checkDestructuringPrivate","toAssignable","checkLVal","checkExpressionErrors","isAsync","isHangingDeclaration","parseFunction","consequent","alternate","prodParam","hasReturn","AllowReturnOutsideFunction","IllegalReturn","argument","discriminant","cases","cur","sawDefault","isCase","MultipleDefaultsInSwitch","lastTokStartLoc","exit","hasPrecedingLineBreak","NewlineAfterThrow","lastTokEndLoc","parseCatchClauseParam","param","parseBindingAtom","SIMPLE_CATCH","BindingFlag","TYPE_CATCH_PARAM","block","handler","clause","finalizer","NoCatchOrFinally","allowMissingInitializer","StrictWith","LabelRedeclaration","labelName","tokenIsLoop","statementStart","sourceToOffsetPos","allowDirectives","createNewLexicalScope","afterBlockParse","strictErrors","clear","isValidDirective","extra","parenthesized","directives","parseBlockOrModuleBlockBody","undefined","oldStrict","hasStrictModeDirective","parsedNonDirective","setStrict","call","update","await","id","ForInOfLoopInitializer","InvalidLhs","ancestor","left","right","parseMaybeAssignAllowIn","isFor","decl","parseVarId","parseMaybeAssignDisallowIn","DeclarationMissingInitializer","UsingDeclarationHasBindingPattern","TYPE_VAR","TYPE_LEXICAL","parseAsyncFunctionExpression","hangingDeclaration","isDeclaration","requireId","initFunction","GeneratorInSingleStatementContext","generator","parseFunctionId","oldMaybeInArrowParameters","maybeInArrowParameters","FUNCTION","functionFlags","parseFunctionParams","parseFunctionBodyAndFinish","registerFunctionStatementId","isConstructor","expressionScope","newParameterDeclarationScope","params","parseBindingList","ParseBindingListFlags","IS_FUNCTION_PARAMS","IS_CONSTRUCTOR_PARAMS","declareName","async","treatFunctionsAsVar","TYPE_FUNCTION","isStatement","optionalId","parseClassId","parseClassSuper","parseClassBody","superClass","isClassProperty","isClassMethod","nameIsConstructor","key","isNonstaticConstructor","method","static","hadSuperClass","hadConstructor","classBody","DecoratorSemicolon","member","parseClassMember","DecoratorConstructor","TrailingDecorator","parseClassMemberFromModifier","pushClassMethod","prop","parseClassProperty","resetPreviousNodeTrailingComments","isStatic","parseClassStaticBlock","parseClassMemberWithIsStatic","publicMethod","privateMethod","publicProp","privateProp","accessorProp","publicMember","parsePropertyNamePrefixOperator","isPrivateName","parseClassElementName","pushClassPrivateMethod","ConstructorIsGenerator","maybeContextualKw","isPrivate","maybeQuestionTokenStartLoc","parsePostMemberNameModifiers","allowsDirectSuper","DuplicateConstructor","override","OverrideOnConstructor","pushClassPrivateProperty","pushClassProperty","isGenerator","optional","ConstructorIsAsync","ConstructorIsAccessor","checkGetterSetterParams","pushClassAccessorProperty","StaticPrototype","ConstructorClassPrivateField","parsePropertyName","CLASS","STATIC_BLOCK","SUPER","oldLabels","ParamKind","PARAM","DecoratorStaticBlock","ConstructorClassField","parseClassPrivateProperty","declarePrivateName","getPrivateNameSV","ClassElementType","parseClassAccessorProperty","parseMethod","STATIC_GETTER","INSTANCE_GETTER","STATIC_SETTER","INSTANCE_SETTER","declareClassPrivateMethodInScope","methodOrProp","parseInitializer","newExpressionScope","bindingType","TYPE_CLASS","declareNameFromIdentifier","MissingClassName","maybeDefaultIdentifier","parseMaybeImportPhase","hasDefault","maybeParseExportDefaultSpecifier","parseAfterDefault","hasStar","eatExportStar","hasNamespace","maybeParseExportNamespaceSpecifier","parseAfterNamespace","isFromRequired","UnsupportedDecoratorExport","parseExportFrom","sawUnambiguousESM","hasSpecifiers","maybeParseExportNamedSpecifiers","hasDeclaration","maybeParseExportDeclaration","node2","checkExport","source","declaration","parseExportDefaultExpression","isExportDefaultSpecifier","specifier","startNodeAtNode","exported","specifiers","parseModuleExportName","isTypeExport","exportKind","parseExportSpecifiers","assertions","attributes","shouldParseExportDeclaration","parseExportDeclaration","DecoratorBeforeExport","UnsupportedDefaultExport","res","nextType","hasFrom","nextAfterFrom","nextTokenStartSince","eatContextual","parseImportSource","maybeParseImportAttributes","checkJSONModuleImport","UsingDeclarationExport","checkNames","isDefault","isFrom","checkDuplicateExports","ExportDefaultFromAsIdentifier","exportName","local","ExportBindingIsString","checkReservedWord","checkLocalExport","Error","checkDeclaration","properties","elem","elements","exportedIdentifiers","has","DuplicateDefaultExport","DuplicateExport","add","isInTypeExport","nodes","first","isMaybeTypeOnly","isString","parseExportSpecifier","cloneStringLiteral","cloneIdentifier","parseStringLiteral","surrogate","exec","ModuleExportNameHasLoneSurrogate","surrogateCharCode","isJSONModuleImport","some","checkImportReflection","singleBindingType","phase","SourcePhaseImportRequiresDefault","DeferImportRequiresNamespace","module","ImportReflectionNotBinding","ImportReflectionHasAssertion","nonDefaultNamedSpecifier","find","imported","ImportJSONBindingNotDefault","isPotentialImportPhase","isExport","applyImportPhase","phaseIdentifier","isImportPhase","tokenIsKeywordOrIdentifier","resetPreviousIdentifierLeadingComments","isPrecedingIdImportPhase","parseImportSourceAndAttributes","parseImportSpecifiersAndAfter","maybeParseDefaultImportSpecifier","parseNext","maybeParseStarImportSpecifier","parseNamedImportSpecifiers","expectContextual","parseExprAtom","parseImportSpecifierLocal","finishImportSpecifier","parseImportAttributes","attrs","attrNames","Set","keyName","ModuleAttributesWithDuplicateKeys","ModuleAttributeInvalidValue","parseModuleAttributes","ModuleAttributeDifferentFromType","useWith","ImportAttributesUseAssert","DestructureNamedImport","importedIsString","importSpecifier","parseImportSpecifier","importKind","isInTypeOnlyImport","ImportBindingIsString","importName","isThisParam","default"],"sources":["../../src/parser/statement.ts"],"sourcesContent":["import type * as N from \"../types.ts\";\nimport {\n  tokenIsIdentifier,\n  tokenIsKeywordOrIdentifier,\n  tokenIsLoop,\n  tokenIsTemplate,\n  tt,\n  type TokenType,\n  getExportedToken,\n} from \"../tokenizer/types.ts\";\nimport ExpressionParser from \"./expression.ts\";\nimport { Errors } from \"../parse-error.ts\";\nimport { isIdentifierChar, isIdentifierStart } from \"../util/identifier.ts\";\nimport * as charCodes from \"charcodes\";\nimport {\n  ScopeFlag,\n  ClassElementType,\n  BindingFlag,\n} from \"../util/scopeflags.ts\";\nimport { ExpressionErrors } from \"./util.ts\";\nimport { ParamKind, functionFlags } from \"../util/production-parameter.ts\";\nimport {\n  newExpressionScope,\n  newParameterDeclarationScope,\n} from \"../util/expression-scope.ts\";\nimport { OptionFlags, type SourceType } from \"../options.ts\";\nimport { Token } from \"../tokenizer/index.ts\";\nimport type { Position } from \"../util/location.ts\";\nimport { createPositionWithColumnOffset } from \"../util/location.ts\";\nimport { cloneStringLiteral, cloneIdentifier, type Undone } from \"./node.ts\";\nimport type Parser from \"./index.ts\";\nimport { ParseBindingListFlags } from \"./lval.ts\";\nimport { LoopLabelKind } from \"../tokenizer/state.ts\";\n\nconst loopLabel = { kind: LoopLabelKind.Loop } as const,\n  switchLabel = { kind: LoopLabelKind.Switch } as const;\n\nexport const enum ParseFunctionFlag {\n  Expression = 0b0000,\n  Declaration = 0b0001,\n  HangingDeclaration = 0b0010,\n  NullableId = 0b0100,\n  Async = 0b1000,\n}\n\nexport const enum ParseStatementFlag {\n  StatementOnly = 0b0000,\n  AllowImportExport = 0b0001,\n  AllowDeclaration = 0b0010,\n  AllowFunctionDeclaration = 0b0100,\n  AllowLabeledFunction = 0b1000,\n}\n\nconst loneSurrogate = /[\\uD800-\\uDFFF]/u;\n\nconst keywordRelationalOperator = /in(?:stanceof)?/y;\n\n/**\n * Convert tokens for backward Babel 7 compat.\n * tt.privateName => tt.hash + tt.name\n * tt.templateTail => tt.backquote/tt.braceR + tt.template + tt.backquote\n * tt.templateNonTail => tt.backquote/tt.braceR + tt.template + tt.dollarBraceL\n * For performance reasons this routine mutates `tokens`, it is okay\n * here since we execute `parseTopLevel` once for every file.\n */\nfunction babel7CompatTokens(\n  tokens: (Token | N.Comment)[],\n  input: string,\n  startIndex: number,\n) {\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    const { type } = token;\n    if (typeof type === \"number\") {\n      if (!process.env.BABEL_8_BREAKING) {\n        if (type === tt.privateName) {\n          const { loc, start, value, end } = token;\n          const hashEndPos = start + 1;\n          const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);\n          tokens.splice(\n            i,\n            1,\n            new Token({\n              // @ts-expect-error: hacky way to create token\n              type: getExportedToken(tt.hash),\n              value: \"#\",\n              start: start,\n              end: hashEndPos,\n              startLoc: loc.start,\n              endLoc: hashEndLoc,\n            }),\n            new Token({\n              // @ts-expect-error: hacky way to create token\n              type: getExportedToken(tt.name),\n              value: value,\n              start: hashEndPos,\n              end: end,\n              startLoc: hashEndLoc,\n              endLoc: loc.end,\n            }),\n          );\n          i++;\n          continue;\n        }\n\n        if (tokenIsTemplate(type)) {\n          const { loc, start, value, end } = token;\n          const backquoteEnd = start + 1;\n          const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);\n          let startToken;\n          if (input.charCodeAt(start - startIndex) === charCodes.graveAccent) {\n            startToken = new Token({\n              // @ts-expect-error: hacky way to create token\n              type: getExportedToken(tt.backQuote),\n              value: \"`\",\n              start: start,\n              end: backquoteEnd,\n              startLoc: loc.start,\n              endLoc: backquoteEndLoc,\n            });\n          } else {\n            startToken = new Token({\n              // @ts-expect-error: hacky way to create token\n              type: getExportedToken(tt.braceR),\n              value: \"}\",\n              start: start,\n              end: backquoteEnd,\n              startLoc: loc.start,\n              endLoc: backquoteEndLoc,\n            });\n          }\n          let templateValue,\n            templateElementEnd,\n            templateElementEndLoc,\n            endToken;\n          if (type === tt.templateTail) {\n            // ends with '`'\n            templateElementEnd = end - 1;\n            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);\n            templateValue = value === null ? null : value.slice(1, -1);\n            endToken = new Token({\n              // @ts-expect-error: hacky way to create token\n              type: getExportedToken(tt.backQuote),\n              value: \"`\",\n              start: templateElementEnd,\n              end: end,\n              startLoc: templateElementEndLoc,\n              endLoc: loc.end,\n            });\n          } else {\n            // ends with `${`\n            templateElementEnd = end - 2;\n            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);\n            templateValue = value === null ? null : value.slice(1, -2);\n            endToken = new Token({\n              // @ts-expect-error: hacky way to create token\n              type: getExportedToken(tt.dollarBraceL),\n              value: \"${\",\n              start: templateElementEnd,\n              end: end,\n              startLoc: templateElementEndLoc,\n              endLoc: loc.end,\n            });\n          }\n          tokens.splice(\n            i,\n            1,\n            startToken,\n            new Token({\n              // @ts-expect-error: hacky way to create token\n              type: getExportedToken(tt.template),\n              value: templateValue,\n              start: backquoteEnd,\n              end: templateElementEnd,\n              startLoc: backquoteEndLoc,\n              endLoc: templateElementEndLoc,\n            }),\n            endToken,\n          );\n          i += 2;\n          continue;\n        }\n      }\n      // @ts-expect-error: we manipulate `token` for performance reasons\n      token.type = getExportedToken(type);\n    }\n  }\n  return tokens;\n}\nexport default abstract class StatementParser extends ExpressionParser {\n  // ### Statement parsing\n\n  // Parse a program. Initializes the parser, reads any number of\n  // statements, and wraps them in a Program node.  Optionally takes a\n  // `program` argument.  If present, the statements will be appended\n  // to its body instead of creating a new node.\n\n  parseTopLevel(\n    this: Parser,\n    file: Undone<N.File>,\n    program: Undone<N.Program>,\n  ): N.File {\n    file.program = this.parseProgram(program);\n    file.comments = this.comments;\n\n    if (this.optionFlags & OptionFlags.Tokens) {\n      file.tokens = babel7CompatTokens(\n        this.tokens,\n        this.input,\n        this.startIndex,\n      );\n    }\n\n    return this.finishNode(file, \"File\");\n  }\n\n  parseProgram(\n    this: Parser,\n    program: Undone<N.Program>,\n    end: TokenType = tt.eof,\n    sourceType: SourceType = this.options.sourceType,\n  ): N.Program {\n    program.sourceType = sourceType;\n    program.interpreter = this.parseInterpreterDirective();\n    this.parseBlockBody(program, true, true, end);\n    if (this.inModule) {\n      if (\n        !(this.optionFlags & OptionFlags.AllowUndeclaredExports) &&\n        this.scope.undefinedExports.size > 0\n      ) {\n        for (const [localName, at] of Array.from(this.scope.undefinedExports)) {\n          this.raise(Errors.ModuleExportUndefined, at, { localName });\n        }\n      }\n      this.addExtra(program, \"topLevelAwait\", this.state.hasTopLevelAwait);\n    }\n    let finishedProgram: N.Program;\n    if (end === tt.eof) {\n      // finish at eof for top level program\n      finishedProgram = this.finishNode(program, \"Program\");\n    } else {\n      // finish immediately before the end token\n      finishedProgram = this.finishNodeAt(\n        program,\n        \"Program\",\n        createPositionWithColumnOffset(this.state.startLoc, -1),\n      );\n    }\n    return finishedProgram;\n  }\n\n  /**\n   * cast a Statement to a Directive. This method mutates input statement.\n   */\n  stmtToDirective(stmt: N.Statement): N.Directive {\n    const directive = stmt as any;\n    directive.type = \"Directive\";\n    directive.value = directive.expression;\n    delete directive.expression;\n\n    const directiveLiteral = directive.value;\n    const expressionValue = directiveLiteral.value;\n    const raw = this.input.slice(\n      this.offsetToSourcePos(directiveLiteral.start),\n      this.offsetToSourcePos(directiveLiteral.end),\n    );\n    const val = (directiveLiteral.value = raw.slice(1, -1)); // remove quotes\n\n    this.addExtra(directiveLiteral, \"raw\", raw);\n    this.addExtra(directiveLiteral, \"rawValue\", val);\n    this.addExtra(directiveLiteral, \"expressionValue\", expressionValue);\n\n    directiveLiteral.type = \"DirectiveLiteral\";\n\n    return directive;\n  }\n\n  parseInterpreterDirective(): N.InterpreterDirective | null {\n    if (!this.match(tt.interpreterDirective)) {\n      return null;\n    }\n\n    const node = this.startNode<N.InterpreterDirective>();\n    node.value = this.state.value;\n    this.next();\n    return this.finishNode(node, \"InterpreterDirective\");\n  }\n\n  isLet(): boolean {\n    if (!this.isContextual(tt._let)) {\n      return false;\n    }\n    return this.hasFollowingBindingAtom();\n  }\n\n  chStartsBindingIdentifier(ch: number, pos: number) {\n    if (isIdentifierStart(ch)) {\n      keywordRelationalOperator.lastIndex = pos;\n      if (keywordRelationalOperator.test(this.input)) {\n        // We have seen `in` or `instanceof` so far, now check if the identifier\n        // ends here\n        const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);\n        if (!isIdentifierChar(endCh) && endCh !== charCodes.backslash) {\n          return false;\n        }\n      }\n      return true;\n    } else if (ch === charCodes.backslash) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  chStartsBindingPattern(ch: number) {\n    return (\n      ch === charCodes.leftSquareBracket || ch === charCodes.leftCurlyBrace\n    );\n  }\n\n  /**\n   * Assuming we have seen a contextual `let` and declaration is allowed, check if it\n   * starts a variable declaration so that it should be interpreted as a keyword.\n   */\n  hasFollowingBindingAtom(): boolean {\n    const next = this.nextTokenStart();\n    const nextCh = this.codePointAtPos(next);\n    return (\n      this.chStartsBindingPattern(nextCh) ||\n      this.chStartsBindingIdentifier(nextCh, next)\n    );\n  }\n\n  /**\n   * Assuming we have seen a contextual `using` and declaration is allowed, check if it\n   * starts a variable declaration in the same line so that it should be interpreted as\n   * a keyword.\n   */\n  hasInLineFollowingBindingIdentifierOrBrace(): boolean {\n    const next = this.nextTokenInLineStart();\n    const nextCh = this.codePointAtPos(next);\n    return (\n      nextCh === charCodes.leftCurlyBrace ||\n      this.chStartsBindingIdentifier(nextCh, next)\n    );\n  }\n\n  startsUsingForOf(): boolean {\n    const { type, containsEsc } = this.lookahead();\n    if (type === tt._of && !containsEsc) {\n      // `using of` must start a for-lhs-of statement\n      return false;\n    } else if (tokenIsIdentifier(type) && !this.hasFollowingLineBreak()) {\n      this.expectPlugin(\"explicitResourceManagement\");\n      return true;\n    }\n  }\n\n  startsAwaitUsing(): boolean {\n    let next = this.nextTokenInLineStart();\n    if (this.isUnparsedContextual(next, \"using\")) {\n      next = this.nextTokenInLineStartSince(next + 5);\n      const nextCh = this.codePointAtPos(next);\n      if (this.chStartsBindingIdentifier(nextCh, next)) {\n        this.expectPlugin(\"explicitResourceManagement\");\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // https://tc39.es/ecma262/#prod-ModuleItem\n  parseModuleItem(this: Parser) {\n    return this.parseStatementLike(\n      ParseStatementFlag.AllowImportExport |\n        ParseStatementFlag.AllowDeclaration |\n        ParseStatementFlag.AllowFunctionDeclaration |\n        // This function is actually also used to parse StatementItems,\n        // which with Annex B enabled allows labeled functions.\n        ParseStatementFlag.AllowLabeledFunction,\n    );\n  }\n\n  // https://tc39.es/ecma262/#prod-StatementListItem\n  parseStatementListItem(this: Parser) {\n    return this.parseStatementLike(\n      ParseStatementFlag.AllowDeclaration |\n        ParseStatementFlag.AllowFunctionDeclaration |\n        (!this.options.annexB || this.state.strict\n          ? 0\n          : ParseStatementFlag.AllowLabeledFunction),\n    );\n  }\n\n  parseStatementOrSloppyAnnexBFunctionDeclaration(\n    this: Parser,\n    allowLabeledFunction: boolean = false,\n  ) {\n    let flags: ParseStatementFlag = ParseStatementFlag.StatementOnly;\n    if (this.options.annexB && !this.state.strict) {\n      flags |= ParseStatementFlag.AllowFunctionDeclaration;\n      if (allowLabeledFunction) {\n        flags |= ParseStatementFlag.AllowLabeledFunction;\n      }\n    }\n    return this.parseStatementLike(flags);\n  }\n\n  // Parse a single statement.\n  //\n  // If expecting a statement and finding a slash operator, parse a\n  // regular expression literal. This is to handle cases like\n  // `if (foo) /blah/.exec(foo)`, where looking at the previous token\n  // does not help.\n  // https://tc39.es/ecma262/#prod-Statement\n  parseStatement(this: Parser) {\n    return this.parseStatementLike(ParseStatementFlag.StatementOnly);\n  }\n\n  // ImportDeclaration and ExportDeclaration are also handled here so we can throw recoverable errors\n  // when they are not at the top level\n  parseStatementLike(\n    this: Parser,\n    flags: ParseStatementFlag,\n  ):\n    | N.Statement\n    | N.Declaration\n    | N.ImportDeclaration\n    | N.ExportDefaultDeclaration\n    | N.ExportNamedDeclaration\n    | N.ExportAllDeclaration {\n    let decorators: N.Decorator[] | null = null;\n\n    if (this.match(tt.at)) {\n      decorators = this.parseDecorators(true);\n    }\n    return this.parseStatementContent(flags, decorators);\n  }\n\n  parseStatementContent(\n    this: Parser,\n    flags: ParseStatementFlag,\n    decorators?: N.Decorator[] | null,\n  ): N.Statement {\n    const startType = this.state.type;\n    const node = this.startNode();\n    const allowDeclaration = !!(flags & ParseStatementFlag.AllowDeclaration);\n    const allowFunctionDeclaration = !!(\n      flags & ParseStatementFlag.AllowFunctionDeclaration\n    );\n    const topLevel = flags & ParseStatementFlag.AllowImportExport;\n\n    // Most types of statements are recognized by the keyword they\n    // start with. Many are trivial to parse, some require a bit of\n    // complexity.\n\n    switch (startType) {\n      case tt._break:\n        return this.parseBreakContinueStatement(node, /* isBreak */ true);\n      case tt._continue:\n        return this.parseBreakContinueStatement(node, /* isBreak */ false);\n      case tt._debugger:\n        return this.parseDebuggerStatement(node as Undone<N.DebuggerStatement>);\n      case tt._do:\n        return this.parseDoWhileStatement(node as Undone<N.DoWhileStatement>);\n      case tt._for:\n        return this.parseForStatement(node as Undone<N.ForStatement>);\n      case tt._function:\n        if (this.lookaheadCharCode() === charCodes.dot) break;\n        if (!allowFunctionDeclaration) {\n          this.raise(\n            this.state.strict\n              ? Errors.StrictFunction\n              : this.options.annexB\n                ? Errors.SloppyFunctionAnnexB\n                : Errors.SloppyFunction,\n            this.state.startLoc,\n          );\n        }\n        return this.parseFunctionStatement(\n          node as Undone<N.FunctionDeclaration>,\n          false,\n          !allowDeclaration && allowFunctionDeclaration,\n        );\n      case tt._class:\n        if (!allowDeclaration) this.unexpected();\n        return this.parseClass(\n          this.maybeTakeDecorators(\n            decorators,\n            node as Undone<N.ClassDeclaration>,\n          ),\n          true,\n        );\n\n      case tt._if:\n        return this.parseIfStatement(node as Undone<N.IfStatement>);\n      case tt._return:\n        return this.parseReturnStatement(node as Undone<N.ReturnStatement>);\n      case tt._switch:\n        return this.parseSwitchStatement(node as Undone<N.SwitchStatement>);\n      case tt._throw:\n        return this.parseThrowStatement(node as Undone<N.ThrowStatement>);\n      case tt._try:\n        return this.parseTryStatement(node as Undone<N.TryStatement>);\n\n      case tt._await:\n        // [+Await] await [no LineTerminator here] using [no LineTerminator here] BindingList[+Using]\n        if (!this.state.containsEsc && this.startsAwaitUsing()) {\n          if (!this.recordAwaitIfAllowed()) {\n            this.raise(Errors.AwaitUsingNotInAsyncContext, node);\n          } else if (!allowDeclaration) {\n            this.raise(Errors.UnexpectedLexicalDeclaration, node);\n          }\n          this.next(); // eat 'await'\n          return this.parseVarStatement(\n            node as Undone<N.VariableDeclaration>,\n            \"await using\",\n          );\n        }\n        break;\n      case tt._using:\n        // using [no LineTerminator here] BindingList[+Using]\n        if (\n          this.state.containsEsc ||\n          !this.hasInLineFollowingBindingIdentifierOrBrace()\n        ) {\n          break;\n        }\n        this.expectPlugin(\"explicitResourceManagement\");\n        if (!this.scope.inModule && this.scope.inTopLevel) {\n          this.raise(Errors.UnexpectedUsingDeclaration, this.state.startLoc);\n        } else if (!allowDeclaration) {\n          this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);\n        }\n        return this.parseVarStatement(\n          node as Undone<N.VariableDeclaration>,\n          \"using\",\n        );\n      case tt._let: {\n        if (this.state.containsEsc) {\n          break;\n        }\n        // `let [` is an explicit negative lookahead for\n        // ExpressionStatement, so special-case it first.\n        const next = this.nextTokenStart();\n        const nextCh = this.codePointAtPos(next);\n        if (nextCh !== charCodes.leftSquareBracket) {\n          if (!allowDeclaration && this.hasFollowingLineBreak()) break;\n          if (\n            !this.chStartsBindingIdentifier(nextCh, next) &&\n            nextCh !== charCodes.leftCurlyBrace\n          ) {\n            break;\n          }\n        }\n      }\n      // fall through\n      case tt._const: {\n        if (!allowDeclaration) {\n          this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);\n        }\n      }\n      // fall through\n      case tt._var: {\n        const kind = this.state.value;\n        return this.parseVarStatement(\n          node as Undone<N.VariableDeclaration>,\n          kind,\n        );\n      }\n      case tt._while:\n        return this.parseWhileStatement(node as Undone<N.WhileStatement>);\n      case tt._with:\n        return this.parseWithStatement(node as Undone<N.WithStatement>);\n      case tt.braceL:\n        return this.parseBlock();\n      case tt.semi:\n        return this.parseEmptyStatement(node as Undone<N.EmptyStatement>);\n      case tt._import: {\n        const nextTokenCharCode = this.lookaheadCharCode();\n        if (\n          nextTokenCharCode === charCodes.leftParenthesis || // import()\n          nextTokenCharCode === charCodes.dot // import.meta\n        ) {\n          break;\n        }\n      }\n      // fall through\n      case tt._export: {\n        if (\n          !(this.optionFlags & OptionFlags.AllowImportExportEverywhere) &&\n          !topLevel\n        ) {\n          this.raise(Errors.UnexpectedImportExport, this.state.startLoc);\n        }\n\n        this.next(); // eat `import`/`export`\n\n        let result;\n        if (startType === tt._import) {\n          result = this.parseImport(node as Undone<N.ImportDeclaration>);\n        } else {\n          result = this.parseExport(\n            node as Undone<\n              | N.ExportAllDeclaration\n              | N.ExportDefaultDeclaration\n              | N.ExportNamedDeclaration\n            >,\n            decorators,\n          );\n        }\n\n        this.assertModuleNodeAllowed(result);\n\n        return result;\n      }\n\n      default: {\n        if (this.isAsyncFunction()) {\n          if (!allowDeclaration) {\n            this.raise(\n              Errors.AsyncFunctionInSingleStatementContext,\n              this.state.startLoc,\n            );\n          }\n          this.next(); // eat 'async'\n          return this.parseFunctionStatement(\n            node as Undone<N.FunctionDeclaration>,\n            true,\n            !allowDeclaration && allowFunctionDeclaration,\n          );\n        }\n      }\n    }\n\n    // If the statement does not start with a statement keyword or a\n    // brace, it's an ExpressionStatement or LabeledStatement. We\n    // simply start parsing an expression, and afterwards, if the\n    // next token is a colon and the expression was a simple\n    // Identifier node, we switch to interpreting it as a label.\n    const maybeName = this.state.value;\n    const expr = this.parseExpression();\n\n    if (\n      tokenIsIdentifier(startType) &&\n      expr.type === \"Identifier\" &&\n      this.eat(tt.colon)\n    ) {\n      return this.parseLabeledStatement(\n        node as Undone<N.LabeledStatement>,\n        maybeName,\n        expr,\n        flags,\n      );\n    } else {\n      return this.parseExpressionStatement(\n        node as Undone<N.ExpressionStatement>,\n        expr,\n        decorators,\n      );\n    }\n  }\n\n  assertModuleNodeAllowed(node: N.Node): void {\n    if (\n      !(this.optionFlags & OptionFlags.AllowImportExportEverywhere) &&\n      !this.inModule\n    ) {\n      this.raise(Errors.ImportOutsideModule, node);\n    }\n  }\n\n  decoratorsEnabledBeforeExport(): boolean {\n    if (this.hasPlugin(\"decorators-legacy\")) return true;\n    return (\n      this.hasPlugin(\"decorators\") &&\n      this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") !== false\n    );\n  }\n\n  // Attach the decorators to the given class.\n  // NOTE: This method changes the .start location of the class, and thus\n  // can affect comment attachment. Calling it before or after finalizing\n  // the class node (and thus finalizing its comments) changes how comments\n  // before the `class` keyword or before the final .start location of the\n  // class are attached.\n  maybeTakeDecorators<T extends Undone<N.Class>>(\n    maybeDecorators: N.Decorator[] | null,\n    classNode: T,\n    exportNode?: Undone<N.ExportDefaultDeclaration | N.ExportNamedDeclaration>,\n  ): T {\n    if (maybeDecorators) {\n      if (classNode.decorators?.length) {\n        // Note: decorators attachment is only attempred multiple times\n        // when the class is part of an export declaration.\n        if (\n          typeof this.getPluginOption(\n            \"decorators\",\n            \"decoratorsBeforeExport\",\n          ) !== \"boolean\"\n        ) {\n          // If `decoratorsBeforeExport` was set to `true` or `false`, we\n          // already threw an error about decorators not being in a valid\n          // position.\n          this.raise(\n            Errors.DecoratorsBeforeAfterExport,\n            classNode.decorators[0],\n          );\n        }\n        classNode.decorators.unshift(...maybeDecorators);\n      } else {\n        classNode.decorators = maybeDecorators;\n      }\n      this.resetStartLocationFromNode(classNode, maybeDecorators[0]);\n      if (exportNode) this.resetStartLocationFromNode(exportNode, classNode);\n    }\n    return classNode;\n  }\n\n  canHaveLeadingDecorator(): boolean {\n    return this.match(tt._class);\n  }\n\n  parseDecorators(this: Parser, allowExport?: boolean): N.Decorator[] {\n    const decorators = [];\n    do {\n      decorators.push(this.parseDecorator());\n    } while (this.match(tt.at));\n\n    if (this.match(tt._export)) {\n      if (!allowExport) {\n        this.unexpected();\n      }\n\n      if (!this.decoratorsEnabledBeforeExport()) {\n        this.raise(Errors.DecoratorExportClass, this.state.startLoc);\n      }\n    } else if (!this.canHaveLeadingDecorator()) {\n      throw this.raise(Errors.UnexpectedLeadingDecorator, this.state.startLoc);\n    }\n\n    return decorators;\n  }\n\n  parseDecorator(this: Parser): N.Decorator {\n    this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]);\n\n    const node = this.startNode<N.Decorator>();\n    this.next();\n\n    if (this.hasPlugin(\"decorators\")) {\n      const startLoc = this.state.startLoc;\n      let expr: N.Expression;\n\n      if (this.match(tt.parenL)) {\n        const startLoc = this.state.startLoc;\n        this.next(); // eat '('\n        expr = this.parseExpression();\n        this.expect(tt.parenR);\n        expr = this.wrapParenthesis(startLoc, expr);\n\n        const paramsStartLoc = this.state.startLoc;\n        node.expression = this.parseMaybeDecoratorArguments(expr, startLoc);\n        if (\n          this.getPluginOption(\"decorators\", \"allowCallParenthesized\") ===\n            false &&\n          node.expression !== expr\n        ) {\n          this.raise(\n            Errors.DecoratorArgumentsOutsideParentheses,\n            paramsStartLoc,\n          );\n        }\n      } else {\n        expr = this.parseIdentifier(false);\n\n        while (this.eat(tt.dot)) {\n          const node = this.startNodeAt<N.MemberExpression>(startLoc);\n          node.object = expr;\n          if (this.match(tt.privateName)) {\n            this.classScope.usePrivateName(\n              this.state.value,\n              this.state.startLoc,\n            );\n            node.property = this.parsePrivateName();\n          } else {\n            node.property = this.parseIdentifier(true);\n          }\n          node.computed = false;\n          expr = this.finishNode(node, \"MemberExpression\");\n        }\n\n        node.expression = this.parseMaybeDecoratorArguments(expr, startLoc);\n      }\n    } else {\n      node.expression = this.parseExprSubscripts();\n    }\n    return this.finishNode(node, \"Decorator\");\n  }\n\n  parseMaybeDecoratorArguments(\n    this: Parser,\n    expr: N.Expression,\n    startLoc: Position,\n  ): N.Expression {\n    if (this.eat(tt.parenL)) {\n      const node = this.startNodeAt<N.CallExpression>(startLoc);\n      node.callee = expr;\n      node.arguments = this.parseCallExpressionArguments(tt.parenR);\n      this.toReferencedList(node.arguments);\n      return this.finishNode(node, \"CallExpression\");\n    }\n\n    return expr;\n  }\n\n  parseBreakContinueStatement(\n    node: Undone<N.Node>,\n    isBreak: true,\n  ): N.BreakStatement;\n  parseBreakContinueStatement(\n    node: Undone<N.Node>,\n    isBreak: false,\n  ): N.ContinueStatement;\n  parseBreakContinueStatement(\n    node: Undone<N.BreakStatement | N.ContinueStatement>,\n    isBreak: boolean,\n  ): N.BreakStatement | N.ContinueStatement {\n    this.next();\n\n    if (this.isLineTerminator()) {\n      node.label = null;\n    } else {\n      node.label = this.parseIdentifier();\n      this.semicolon();\n    }\n\n    this.verifyBreakContinue(node, isBreak);\n\n    return this.finishNode(\n      node,\n      isBreak ? \"BreakStatement\" : \"ContinueStatement\",\n    );\n  }\n\n  verifyBreakContinue(\n    node: Undone<N.BreakStatement | N.ContinueStatement>,\n    isBreak: boolean,\n  ) {\n    let i;\n    for (i = 0; i < this.state.labels.length; ++i) {\n      const lab = this.state.labels[i];\n      if (node.label == null || lab.name === node.label.name) {\n        if (lab.kind != null && (isBreak || lab.kind === LoopLabelKind.Loop)) {\n          break;\n        }\n        if (node.label && isBreak) break;\n      }\n    }\n    if (i === this.state.labels.length) {\n      const type = isBreak ? \"BreakStatement\" : \"ContinueStatement\";\n      this.raise(Errors.IllegalBreakContinue, node, { type });\n    }\n  }\n\n  parseDebuggerStatement(\n    node: Undone<N.DebuggerStatement>,\n  ): N.DebuggerStatement {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\");\n  }\n\n  parseHeaderExpression(this: Parser): N.Expression {\n    this.expect(tt.parenL);\n    const val = this.parseExpression();\n    this.expect(tt.parenR);\n    return val;\n  }\n\n  // https://tc39.es/ecma262/#prod-DoWhileStatement\n  parseDoWhileStatement(\n    this: Parser,\n    node: Undone<N.DoWhileStatement>,\n  ): N.DoWhileStatement {\n    this.next();\n    this.state.labels.push(loopLabel);\n\n    // Parse the loop body's body.\n    node.body =\n      // For the smartPipelines plugin: Disable topic references from outer\n      // contexts within the loop body. They are permitted in test expressions,\n      // outside of the loop body.\n      this.withSmartMixTopicForbiddingContext(() =>\n        // Parse the loop body's body.\n        this.parseStatement(),\n      );\n\n    this.state.labels.pop();\n\n    this.expect(tt._while);\n    node.test = this.parseHeaderExpression();\n    this.eat(tt.semi);\n    return this.finishNode(node, \"DoWhileStatement\");\n  }\n\n  // Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n  // loop is non-trivial. Basically, we have to parse the init `var`\n  // statement or expression, disallowing the `in` operator (see\n  // the second parameter to `parseExpression`), and then check\n  // whether the next token is `in` or `of`. When there is no init\n  // part (semicolon immediately after the opening parenthesis), it\n  // is a regular `for` loop.\n\n  parseForStatement(\n    this: Parser,\n    node: Undone<N.ForStatement | N.ForInOf>,\n  ): N.ForLike {\n    this.next();\n    this.state.labels.push(loopLabel);\n\n    let awaitAt = null;\n\n    if (this.isContextual(tt._await) && this.recordAwaitIfAllowed()) {\n      awaitAt = this.state.startLoc;\n      this.next();\n    }\n    this.scope.enter(ScopeFlag.OTHER);\n    this.expect(tt.parenL);\n\n    if (this.match(tt.semi)) {\n      if (awaitAt !== null) {\n        this.unexpected(awaitAt);\n      }\n      return this.parseFor(node as Undone<N.ForStatement>, null);\n    }\n\n    const startsWithLet = this.isContextual(tt._let);\n    {\n      const startsWithAwaitUsing =\n        this.isContextual(tt._await) && this.startsAwaitUsing();\n      const starsWithUsingDeclaration =\n        startsWithAwaitUsing ||\n        (this.isContextual(tt._using) && this.startsUsingForOf());\n      const isLetOrUsing =\n        (startsWithLet && this.hasFollowingBindingAtom()) ||\n        starsWithUsingDeclaration;\n\n      if (this.match(tt._var) || this.match(tt._const) || isLetOrUsing) {\n        const initNode = this.startNode<N.VariableDeclaration>();\n        let kind;\n        if (startsWithAwaitUsing) {\n          kind = \"await using\";\n          if (!this.recordAwaitIfAllowed()) {\n            this.raise(Errors.AwaitUsingNotInAsyncContext, this.state.startLoc);\n          }\n          this.next(); // eat 'await'\n        } else {\n          kind = this.state.value;\n        }\n        this.next();\n        this.parseVar(initNode, true, kind);\n        const init = this.finishNode(initNode, \"VariableDeclaration\");\n\n        const isForIn = this.match(tt._in);\n        if (isForIn && starsWithUsingDeclaration) {\n          this.raise(Errors.ForInUsing, init);\n        }\n        if (\n          (isForIn || this.isContextual(tt._of)) &&\n          init.declarations.length === 1\n        ) {\n          return this.parseForIn(node as Undone<N.ForInOf>, init, awaitAt);\n        }\n        if (awaitAt !== null) {\n          this.unexpected(awaitAt);\n        }\n        return this.parseFor(node as Undone<N.ForStatement>, init);\n      }\n    }\n\n    // Check whether the first token is possibly a contextual keyword, so that\n    // we can forbid `for (async of` if this turns out to be a for-of loop.\n    const startsWithAsync = this.isContextual(tt._async);\n\n    const refExpressionErrors = new ExpressionErrors();\n    const init = this.parseExpression(true, refExpressionErrors);\n    const isForOf = this.isContextual(tt._of);\n    if (isForOf) {\n      // Check for leading tokens that are forbidden in for-of loops:\n      if (startsWithLet) {\n        this.raise(Errors.ForOfLet, init);\n      }\n\n      if (\n        // `for await (async of []);` is allowed.\n        awaitAt === null &&\n        startsWithAsync &&\n        init.type === \"Identifier\"\n      ) {\n        // This catches the case where the `async` in `for (async of` was\n        // parsed as an identifier. If it was parsed as the start of an async\n        // arrow function (e.g. `for (async of => {} of []);`), the LVal check\n        // further down will raise a more appropriate error.\n        this.raise(Errors.ForOfAsync, init);\n      }\n    }\n    if (isForOf || this.match(tt._in)) {\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.toAssignable(init, /* isLHS */ true);\n      const type = isForOf ? \"ForOfStatement\" : \"ForInStatement\";\n      this.checkLVal(init, { type });\n      return this.parseForIn(\n        node as Undone<N.ForInStatement | N.ForOfStatement>,\n        // @ts-expect-error init has been transformed to an assignable\n        init,\n        awaitAt,\n      );\n    } else {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n    if (awaitAt !== null) {\n      this.unexpected(awaitAt);\n    }\n    return this.parseFor(node as Undone<N.ForStatement>, init);\n  }\n\n  // https://tc39.es/ecma262/#prod-HoistableDeclaration\n  parseFunctionStatement(\n    this: Parser,\n    node: Undone<N.FunctionDeclaration>,\n    isAsync: boolean,\n    isHangingDeclaration: boolean,\n  ): N.FunctionDeclaration {\n    this.next(); // eat 'function'\n    return this.parseFunction(\n      node,\n      ParseFunctionFlag.Declaration |\n        (isHangingDeclaration ? ParseFunctionFlag.HangingDeclaration : 0) |\n        (isAsync ? ParseFunctionFlag.Async : 0),\n    );\n  }\n\n  // https://tc39.es/ecma262/#prod-IfStatement\n  parseIfStatement(this: Parser, node: Undone<N.IfStatement>) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    // Annex B.3.3\n    // https://tc39.es/ecma262/#sec-functiondeclarations-in-ifstatement-statement-clauses\n    node.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration();\n    node.alternate = this.eat(tt._else)\n      ? this.parseStatementOrSloppyAnnexBFunctionDeclaration()\n      : null;\n    return this.finishNode(node, \"IfStatement\");\n  }\n\n  parseReturnStatement(this: Parser, node: Undone<N.ReturnStatement>) {\n    if (\n      !this.prodParam.hasReturn &&\n      !(this.optionFlags & OptionFlags.AllowReturnOutsideFunction)\n    ) {\n      this.raise(Errors.IllegalReturn, this.state.startLoc);\n    }\n\n    this.next();\n\n    // In `return` (and `break`/`continue`), the keywords with\n    // optional arguments, we eagerly look for a semicolon or the\n    // possibility to insert one.\n\n    if (this.isLineTerminator()) {\n      node.argument = null;\n    } else {\n      node.argument = this.parseExpression();\n      this.semicolon();\n    }\n\n    return this.finishNode(node, \"ReturnStatement\");\n  }\n\n  // https://tc39.es/ecma262/#prod-SwitchStatement\n  parseSwitchStatement(this: Parser, node: Undone<N.SwitchStatement>) {\n    this.next();\n    node.discriminant = this.parseHeaderExpression();\n    const cases: N.SwitchStatement[\"cases\"] = (node.cases = []);\n    this.expect(tt.braceL);\n    this.state.labels.push(switchLabel);\n    this.scope.enter(ScopeFlag.OTHER);\n\n    // Statements under must be grouped (by label) in SwitchCase\n    // nodes. `cur` is used to keep the node that we are currently\n    // adding statements to.\n\n    let cur;\n    for (let sawDefault; !this.match(tt.braceR); ) {\n      if (this.match(tt._case) || this.match(tt._default)) {\n        const isCase = this.match(tt._case);\n        if (cur) this.finishNode(cur, \"SwitchCase\");\n        // @ts-expect-error Fixme\n        cases.push((cur = this.startNode<N.SwitchCase>()));\n        cur.consequent = [];\n        this.next();\n        if (isCase) {\n          cur.test = this.parseExpression();\n        } else {\n          if (sawDefault) {\n            this.raise(\n              Errors.MultipleDefaultsInSwitch,\n              this.state.lastTokStartLoc,\n            );\n          }\n          sawDefault = true;\n          cur.test = null;\n        }\n        this.expect(tt.colon);\n      } else {\n        if (cur) {\n          cur.consequent.push(this.parseStatementListItem());\n        } else {\n          this.unexpected();\n        }\n      }\n    }\n    this.scope.exit();\n    if (cur) this.finishNode(cur, \"SwitchCase\");\n    this.next(); // Closing brace\n    this.state.labels.pop();\n    return this.finishNode(node, \"SwitchStatement\");\n  }\n\n  parseThrowStatement(this: Parser, node: Undone<N.ThrowStatement>) {\n    this.next();\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(Errors.NewlineAfterThrow, this.state.lastTokEndLoc);\n    }\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\");\n  }\n\n  parseCatchClauseParam(this: Parser): N.Pattern {\n    const param = this.parseBindingAtom();\n\n    this.scope.enter(\n      this.options.annexB && param.type === \"Identifier\"\n        ? ScopeFlag.SIMPLE_CATCH\n        : 0,\n    );\n    this.checkLVal(\n      param,\n      { type: \"CatchClause\" },\n      BindingFlag.TYPE_CATCH_PARAM,\n    );\n\n    return param;\n  }\n\n  parseTryStatement(\n    this: Parser,\n    node: Undone<N.TryStatement>,\n  ): N.TryStatement {\n    this.next();\n\n    node.block = this.parseBlock();\n    node.handler = null;\n\n    if (this.match(tt._catch)) {\n      const clause = this.startNode<N.CatchClause>();\n      this.next();\n      if (this.match(tt.parenL)) {\n        this.expect(tt.parenL);\n        clause.param = this.parseCatchClauseParam();\n        this.expect(tt.parenR);\n      } else {\n        clause.param = null;\n        this.scope.enter(ScopeFlag.OTHER);\n      }\n\n      // Parse the catch clause's body.\n      clause.body =\n        // For the smartPipelines plugin: Disable topic references from outer\n        // contexts within the catch clause's body.\n        this.withSmartMixTopicForbiddingContext(() =>\n          // Parse the catch clause's body.\n          this.parseBlock(false, false),\n        );\n\n      this.scope.exit();\n      node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n\n    node.finalizer = this.eat(tt._finally) ? this.parseBlock() : null;\n\n    if (!node.handler && !node.finalizer) {\n      this.raise(Errors.NoCatchOrFinally, node);\n    }\n\n    return this.finishNode(node, \"TryStatement\");\n  }\n\n  // https://tc39.es/ecma262/#prod-VariableStatement\n  // https://tc39.es/ecma262/#prod-LexicalDeclaration\n  parseVarStatement(\n    this: Parser,\n    node: Undone<N.VariableDeclaration>,\n    kind: \"var\" | \"let\" | \"const\" | \"using\" | \"await using\",\n    allowMissingInitializer: boolean = false,\n  ): N.VariableDeclaration {\n    this.next();\n    this.parseVar(node, false, kind, allowMissingInitializer);\n    this.semicolon();\n    return this.finishNode(node, \"VariableDeclaration\");\n  }\n\n  // https://tc39.es/ecma262/#prod-WhileStatement\n  parseWhileStatement(\n    this: Parser,\n    node: Undone<N.WhileStatement>,\n  ): N.WhileStatement {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    this.state.labels.push(loopLabel);\n\n    // Parse the loop body.\n    node.body =\n      // For the smartPipelines plugin:\n      // Disable topic references from outer contexts within the loop body.\n      // They are permitted in test expressions, outside of the loop body.\n      this.withSmartMixTopicForbiddingContext(() =>\n        // Parse loop body.\n        this.parseStatement(),\n      );\n\n    this.state.labels.pop();\n\n    return this.finishNode(node, \"WhileStatement\");\n  }\n\n  parseWithStatement(\n    this: Parser,\n    node: Undone<N.WithStatement>,\n  ): N.WithStatement {\n    if (this.state.strict) {\n      this.raise(Errors.StrictWith, this.state.startLoc);\n    }\n    this.next();\n    node.object = this.parseHeaderExpression();\n\n    // Parse the statement body.\n    node.body =\n      // For the smartPipelines plugin:\n      // Disable topic references from outer contexts within the with statement's body.\n      // They are permitted in function default-parameter expressions, which are\n      // part of the outer context, outside of the with statement's body.\n      this.withSmartMixTopicForbiddingContext(() =>\n        // Parse the statement body.\n        this.parseStatement(),\n      );\n\n    return this.finishNode(node, \"WithStatement\");\n  }\n\n  parseEmptyStatement(node: Undone<N.EmptyStatement>): N.EmptyStatement {\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\");\n  }\n\n  // https://tc39.es/ecma262/#prod-LabelledStatement\n  parseLabeledStatement(\n    this: Parser,\n    node: Undone<N.LabeledStatement>,\n    maybeName: string,\n    expr: N.Identifier,\n    flags: ParseStatementFlag,\n  ): N.LabeledStatement {\n    for (const label of this.state.labels) {\n      if (label.name === maybeName) {\n        this.raise(Errors.LabelRedeclaration, expr, {\n          labelName: maybeName,\n        });\n      }\n    }\n\n    const kind = tokenIsLoop(this.state.type)\n      ? LoopLabelKind.Loop\n      : this.match(tt._switch)\n        ? LoopLabelKind.Switch\n        : null;\n    for (let i = this.state.labels.length - 1; i >= 0; i--) {\n      const label = this.state.labels[i];\n      if (label.statementStart === node.start) {\n        label.statementStart = this.sourceToOffsetPos(this.state.start);\n        label.kind = kind;\n      } else {\n        break;\n      }\n    }\n\n    this.state.labels.push({\n      name: maybeName,\n      kind: kind,\n      statementStart: this.sourceToOffsetPos(this.state.start),\n    });\n    // https://tc39.es/ecma262/#prod-LabelledItem\n    node.body =\n      flags & ParseStatementFlag.AllowLabeledFunction\n        ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true)\n        : this.parseStatement();\n\n    this.state.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, \"LabeledStatement\");\n  }\n\n  parseExpressionStatement(\n    node: Undone<N.ExpressionStatement>,\n    expr: N.Expression,\n    /* eslint-disable-next-line @typescript-eslint/no-unused-vars -- used in TypeScript parser */\n    decorators: N.Decorator[] | null,\n  ) {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, \"ExpressionStatement\");\n  }\n\n  // Parse a semicolon-enclosed block of statements, handling `\"use\n  // strict\"` declarations when `allowDirectives` is true (used for\n  // function bodies).\n\n  parseBlock(\n    this: Parser,\n    allowDirectives: boolean = false,\n    createNewLexicalScope: boolean = true,\n    afterBlockParse?: (hasStrictModeDirective: boolean) => void,\n  ): N.BlockStatement {\n    const node = this.startNode<N.BlockStatement>();\n    if (allowDirectives) {\n      this.state.strictErrors.clear();\n    }\n    this.expect(tt.braceL);\n    if (createNewLexicalScope) {\n      this.scope.enter(ScopeFlag.OTHER);\n    }\n    this.parseBlockBody(\n      node,\n      allowDirectives,\n      false,\n      tt.braceR,\n      afterBlockParse,\n    );\n    if (createNewLexicalScope) {\n      this.scope.exit();\n    }\n    return this.finishNode(node, \"BlockStatement\");\n  }\n\n  isValidDirective(stmt: N.Statement): boolean {\n    return (\n      stmt.type === \"ExpressionStatement\" &&\n      stmt.expression.type === \"StringLiteral\" &&\n      !stmt.expression.extra.parenthesized\n    );\n  }\n\n  parseBlockBody(\n    this: Parser,\n    node: Undone<N.BlockStatementLike>,\n    allowDirectives: boolean | undefined | null,\n    topLevel: boolean,\n    end: TokenType,\n    afterBlockParse?: (hasStrictModeDirective: boolean) => void,\n  ): void {\n    const body: N.BlockStatementLike[\"body\"] = (node.body = []);\n    const directives: N.BlockStatementLike[\"directives\"] = (node.directives =\n      []);\n    this.parseBlockOrModuleBlockBody(\n      body,\n      allowDirectives ? directives : undefined,\n      topLevel,\n      end,\n      afterBlockParse,\n    );\n  }\n\n  // Undefined directives means that directives are not allowed.\n  // https://tc39.es/ecma262/#prod-Block\n  // https://tc39.es/ecma262/#prod-ModuleBody\n  parseBlockOrModuleBlockBody(\n    this: Parser,\n    body: N.Statement[],\n    directives: N.Directive[] | undefined | null,\n    topLevel: boolean,\n    end: TokenType,\n    afterBlockParse?: (hasStrictModeDirective: boolean) => void,\n  ): void {\n    const oldStrict = this.state.strict;\n    let hasStrictModeDirective = false;\n    let parsedNonDirective = false;\n\n    while (!this.match(end)) {\n      const stmt = topLevel\n        ? this.parseModuleItem()\n        : this.parseStatementListItem();\n\n      if (directives && !parsedNonDirective) {\n        if (this.isValidDirective(stmt)) {\n          const directive = this.stmtToDirective(stmt);\n          directives.push(directive);\n\n          if (\n            !hasStrictModeDirective &&\n            directive.value.value === \"use strict\"\n          ) {\n            hasStrictModeDirective = true;\n            this.setStrict(true);\n          }\n\n          continue;\n        }\n        parsedNonDirective = true;\n        // clear strict errors since the strict mode will not change within the block\n        this.state.strictErrors.clear();\n      }\n      body.push(stmt);\n    }\n\n    afterBlockParse?.call(this, hasStrictModeDirective);\n\n    if (!oldStrict) {\n      this.setStrict(false);\n    }\n\n    this.next();\n  }\n\n  // Parse a regular `for` loop. The disambiguation code in\n  // `parseStatement` will already have parsed the init statement or\n  // expression.\n\n  parseFor(\n    this: Parser,\n    node: Undone<N.ForStatement>,\n    init?: N.VariableDeclaration | N.Expression | null,\n  ): N.ForStatement {\n    node.init = init;\n    this.semicolon(/* allowAsi */ false);\n    node.test = this.match(tt.semi) ? null : this.parseExpression();\n    this.semicolon(/* allowAsi */ false);\n    node.update = this.match(tt.parenR) ? null : this.parseExpression();\n    this.expect(tt.parenR);\n\n    // Parse the loop body.\n    node.body =\n      // For the smartPipelines plugin: Disable topic references from outer\n      // contexts within the loop body. They are permitted in test expressions,\n      // outside of the loop body.\n      this.withSmartMixTopicForbiddingContext(() =>\n        // Parse the loop body.\n        this.parseStatement(),\n      );\n\n    this.scope.exit();\n    this.state.labels.pop();\n\n    return this.finishNode(node, \"ForStatement\");\n  }\n\n  // Parse a `for`/`in` and `for`/`of` loop, which are almost\n  // same from parser's perspective.\n\n  parseForIn(\n    this: Parser,\n    node: Undone<N.ForInOf>,\n    init: N.VariableDeclaration | N.AssignmentPattern,\n    awaitAt?: Position | null,\n  ): N.ForInOf {\n    const isForIn = this.match(tt._in);\n    this.next();\n\n    if (isForIn) {\n      if (awaitAt !== null) this.unexpected(awaitAt);\n    } else {\n      node.await = awaitAt !== null;\n    }\n\n    if (\n      init.type === \"VariableDeclaration\" &&\n      init.declarations[0].init != null &&\n      (!isForIn ||\n        !this.options.annexB ||\n        this.state.strict ||\n        init.kind !== \"var\" ||\n        init.declarations[0].id.type !== \"Identifier\")\n    ) {\n      this.raise(Errors.ForInOfLoopInitializer, init, {\n        type: isForIn ? \"ForInStatement\" : \"ForOfStatement\",\n      });\n    }\n\n    if (init.type === \"AssignmentPattern\") {\n      this.raise(Errors.InvalidLhs, init, {\n        ancestor: { type: \"ForStatement\" },\n      });\n    }\n\n    node.left = init;\n    node.right = isForIn\n      ? this.parseExpression()\n      : this.parseMaybeAssignAllowIn();\n    this.expect(tt.parenR);\n\n    // Parse the loop body.\n    node.body =\n      // For the smartPipelines plugin:\n      // Disable topic references from outer contexts within the loop body.\n      // They are permitted in test expressions, outside of the loop body.\n      this.withSmartMixTopicForbiddingContext(() =>\n        // Parse loop body.\n        this.parseStatement(),\n      );\n\n    this.scope.exit();\n    this.state.labels.pop();\n\n    return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\");\n  }\n\n  // Parse a list of variable declarations.\n\n  parseVar(\n    this: Parser,\n    node: Undone<N.VariableDeclaration>,\n    isFor: boolean,\n    kind: \"var\" | \"let\" | \"const\" | \"using\" | \"await using\",\n    allowMissingInitializer: boolean = false,\n  ): Undone<N.VariableDeclaration> {\n    const declarations: N.VariableDeclarator[] = (node.declarations = []);\n    node.kind = kind;\n    for (;;) {\n      const decl = this.startNode<N.VariableDeclarator>();\n      this.parseVarId(decl, kind);\n      decl.init = !this.eat(tt.eq)\n        ? null\n        : isFor\n          ? this.parseMaybeAssignDisallowIn()\n          : this.parseMaybeAssignAllowIn();\n\n      if (decl.init === null && !allowMissingInitializer) {\n        if (\n          decl.id.type !== \"Identifier\" &&\n          !(isFor && (this.match(tt._in) || this.isContextual(tt._of)))\n        ) {\n          this.raise(\n            Errors.DeclarationMissingInitializer,\n            this.state.lastTokEndLoc,\n            {\n              kind: \"destructuring\",\n            },\n          );\n        } else if (\n          (kind === \"const\" || kind === \"using\" || kind === \"await using\") &&\n          !(this.match(tt._in) || this.isContextual(tt._of))\n        ) {\n          this.raise(\n            Errors.DeclarationMissingInitializer,\n            this.state.lastTokEndLoc,\n            { kind },\n          );\n        }\n      }\n      declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n      if (!this.eat(tt.comma)) break;\n    }\n    return node;\n  }\n\n  parseVarId(\n    this: Parser,\n    decl: Undone<N.VariableDeclarator>,\n    kind: \"var\" | \"let\" | \"const\" | \"using\" | \"await using\",\n  ): void {\n    const id = this.parseBindingAtom();\n    if (kind === \"using\" || kind === \"await using\") {\n      if (id.type === \"ArrayPattern\" || id.type === \"ObjectPattern\") {\n        this.raise(Errors.UsingDeclarationHasBindingPattern, id.loc.start);\n      }\n    }\n    this.checkLVal(\n      id,\n      { type: \"VariableDeclarator\" },\n      kind === \"var\" ? BindingFlag.TYPE_VAR : BindingFlag.TYPE_LEXICAL,\n    );\n    decl.id = id;\n  }\n\n  // https://tc39.es/ecma262/#prod-AsyncFunctionExpression\n  parseAsyncFunctionExpression(\n    this: Parser,\n    node: Undone<N.FunctionExpression>,\n  ): N.FunctionExpression {\n    return this.parseFunction(node, ParseFunctionFlag.Async);\n  }\n\n  // Parse a function declaration or expression (depending on the\n  // ParseFunctionFlag.Declaration flag).\n\n  parseFunction<T extends N.NormalFunction>(\n    this: Parser,\n    node: Undone<T>,\n    flags: ParseFunctionFlag = ParseFunctionFlag.Expression,\n  ): T {\n    const hangingDeclaration = flags & ParseFunctionFlag.HangingDeclaration;\n    const isDeclaration = !!(flags & ParseFunctionFlag.Declaration);\n    const requireId = isDeclaration && !(flags & ParseFunctionFlag.NullableId);\n    const isAsync = !!(flags & ParseFunctionFlag.Async);\n\n    this.initFunction(node, isAsync);\n\n    if (this.match(tt.star)) {\n      if (hangingDeclaration) {\n        this.raise(\n          Errors.GeneratorInSingleStatementContext,\n          this.state.startLoc,\n        );\n      }\n      this.next(); // eat *\n      node.generator = true;\n    }\n\n    if (isDeclaration) {\n      node.id = this.parseFunctionId(requireId);\n    }\n\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = false;\n    this.scope.enter(ScopeFlag.FUNCTION);\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n\n    if (!isDeclaration) {\n      node.id = this.parseFunctionId();\n    }\n\n    this.parseFunctionParams(node, /* isConstructor */ false);\n\n    // For the smartPipelines plugin: Disable topic references from outer\n    // contexts within the function body. They are permitted in function\n    // default-parameter expressions, outside of the function body.\n    this.withSmartMixTopicForbiddingContext(() => {\n      // Parse the function body.\n      this.parseFunctionBodyAndFinish(\n        node,\n        isDeclaration ? \"FunctionDeclaration\" : \"FunctionExpression\",\n      );\n    });\n\n    this.prodParam.exit();\n    this.scope.exit();\n\n    if (isDeclaration && !hangingDeclaration) {\n      // We need to register this _after_ parsing the function body\n      // because of TypeScript body-less function declarations,\n      // which shouldn't be added to the scope.\n      this.registerFunctionStatementId(node as T);\n    }\n\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return node as T;\n  }\n\n  parseFunctionId(requireId?: boolean): N.Identifier | undefined | null {\n    return requireId || tokenIsIdentifier(this.state.type)\n      ? this.parseIdentifier()\n      : null;\n  }\n\n  parseFunctionParams(\n    this: Parser,\n    node: Undone<N.Function>,\n    isConstructor?: boolean,\n  ): void {\n    this.expect(tt.parenL);\n    this.expressionScope.enter(newParameterDeclarationScope());\n    node.params = this.parseBindingList(\n      tt.parenR,\n      charCodes.rightParenthesis,\n      ParseBindingListFlags.IS_FUNCTION_PARAMS |\n        (isConstructor ? ParseBindingListFlags.IS_CONSTRUCTOR_PARAMS : 0),\n    );\n\n    this.expressionScope.exit();\n  }\n\n  registerFunctionStatementId(node: N.Function): void {\n    if (!node.id) return;\n\n    // If it is a regular function declaration in sloppy mode, then it is\n    // subject to Annex B semantics (BindingFlag.TYPE_FUNCTION). Otherwise, the binding\n    // mode depends on properties of the current scope (see\n    // treatFunctionsAsVar).\n    this.scope.declareName(\n      node.id.name,\n      !this.options.annexB || this.state.strict || node.generator || node.async\n        ? this.scope.treatFunctionsAsVar\n          ? BindingFlag.TYPE_VAR\n          : BindingFlag.TYPE_LEXICAL\n        : BindingFlag.TYPE_FUNCTION,\n      node.id.loc.start,\n    );\n  }\n\n  // Parse a class declaration or literal (depending on the\n  // `isStatement` parameter).\n\n  parseClass<T extends N.Class>(\n    this: Parser,\n    node: Undone<T>,\n    isStatement: /* T === ClassDeclaration */ boolean,\n    optionalId?: boolean,\n  ): T {\n    this.next(); // 'class'\n\n    // A class definition is always strict mode code.\n    const oldStrict = this.state.strict;\n    this.state.strict = true;\n\n    this.parseClassId(node, isStatement, optionalId);\n    this.parseClassSuper(node);\n    // this.state.strict is restored in parseClassBody\n    node.body = this.parseClassBody(!!node.superClass, oldStrict);\n\n    return this.finishNode(\n      node,\n      isStatement ? \"ClassDeclaration\" : \"ClassExpression\",\n    );\n  }\n\n  isClassProperty(): boolean {\n    return this.match(tt.eq) || this.match(tt.semi) || this.match(tt.braceR);\n  }\n\n  isClassMethod(): boolean {\n    return this.match(tt.parenL);\n  }\n\n  nameIsConstructor(key: N.Expression | N.PrivateName): boolean {\n    return (\n      (key.type === \"Identifier\" && key.name === \"constructor\") ||\n      (key.type === \"StringLiteral\" && key.value === \"constructor\")\n    );\n  }\n\n  isNonstaticConstructor(method: N.ClassMethod | N.ClassProperty): boolean {\n    return (\n      !method.computed && !method.static && this.nameIsConstructor(method.key)\n    );\n  }\n\n  // https://tc39.es/ecma262/#prod-ClassBody\n  parseClassBody(\n    this: Parser,\n    hadSuperClass: boolean,\n    oldStrict: boolean,\n  ): N.ClassBody {\n    this.classScope.enter();\n\n    const state: N.ParseClassMemberState = {\n      hadConstructor: false,\n      hadSuperClass,\n    };\n    let decorators: N.Decorator[] = [];\n    const classBody = this.startNode<N.ClassBody>();\n    classBody.body = [];\n\n    this.expect(tt.braceL);\n\n    // For the smartPipelines plugin: Disable topic references from outer\n    // contexts within the class body.\n    this.withSmartMixTopicForbiddingContext(() => {\n      // Parse the contents within the braces.\n      while (!this.match(tt.braceR)) {\n        if (this.eat(tt.semi)) {\n          if (decorators.length > 0) {\n            throw this.raise(\n              Errors.DecoratorSemicolon,\n              this.state.lastTokEndLoc,\n            );\n          }\n          continue;\n        }\n\n        if (this.match(tt.at)) {\n          decorators.push(this.parseDecorator());\n          continue;\n        }\n\n        const member = this.startNode<N.ClassMember>();\n\n        // steal the decorators if there are any\n        if (decorators.length) {\n          // @ts-expect-error Fixme\n          member.decorators = decorators;\n          this.resetStartLocationFromNode(member, decorators[0]);\n          decorators = [];\n        }\n\n        this.parseClassMember(classBody, member, state);\n\n        if (\n          // @ts-expect-error Fixme\n          member.kind === \"constructor\" &&\n          // @ts-expect-error Fixme\n          member.decorators &&\n          // @ts-expect-error Fixme\n          member.decorators.length > 0\n        ) {\n          this.raise(Errors.DecoratorConstructor, member);\n        }\n      }\n    });\n\n    this.state.strict = oldStrict;\n\n    this.next(); // eat `}`\n\n    if (decorators.length) {\n      throw this.raise(Errors.TrailingDecorator, this.state.startLoc);\n    }\n\n    this.classScope.exit();\n\n    return this.finishNode(classBody, \"ClassBody\");\n  }\n\n  // returns true if the current identifier is a method/field name,\n  // false if it is a modifier\n  parseClassMemberFromModifier(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    member: Undone<N.ClassMember>,\n  ): boolean {\n    const key = this.parseIdentifier(true); // eats the modifier\n\n    if (this.isClassMethod()) {\n      const method: N.ClassMethod = member as any;\n\n      // a method named like the modifier\n      method.kind = \"method\";\n      method.computed = false;\n      method.key = key;\n      method.static = false;\n      this.pushClassMethod(\n        classBody,\n        method,\n        false,\n        false,\n        /* isConstructor */ false,\n        false,\n      );\n      return true;\n    } else if (this.isClassProperty()) {\n      const prop: N.ClassProperty = member as any;\n\n      // a property named like the modifier\n      prop.computed = false;\n      prop.key = key;\n      prop.static = false;\n      classBody.body.push(this.parseClassProperty(prop));\n      return true;\n    }\n    this.resetPreviousNodeTrailingComments(key);\n    return false;\n  }\n\n  parseClassMember(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    member: Undone<N.ClassMember>,\n    state: N.ParseClassMemberState,\n  ): void {\n    const isStatic = this.isContextual(tt._static);\n\n    if (isStatic) {\n      if (this.parseClassMemberFromModifier(classBody, member)) {\n        // a class element named 'static'\n        return;\n      }\n      if (this.eat(tt.braceL)) {\n        this.parseClassStaticBlock(classBody, member as any as N.StaticBlock);\n        return;\n      }\n    }\n\n    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n  }\n\n  parseClassMemberWithIsStatic(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    member: Undone<N.ClassMember>,\n    state: N.ParseClassMemberState,\n    isStatic: boolean,\n  ) {\n    const publicMethod = member as N.ClassMethod;\n    const privateMethod = member as N.ClassPrivateMethod;\n    const publicProp = member as N.ClassProperty;\n    const privateProp = member as N.ClassPrivateProperty;\n    const accessorProp = member as N.ClassAccessorProperty;\n\n    const method: typeof publicMethod | typeof privateMethod = publicMethod;\n    const publicMember: typeof publicMethod | typeof publicProp = publicMethod;\n\n    member.static = isStatic;\n    this.parsePropertyNamePrefixOperator(member);\n\n    if (this.eat(tt.star)) {\n      // a generator\n      method.kind = \"method\";\n      const isPrivateName = this.match(tt.privateName);\n      this.parseClassElementName(method);\n\n      if (isPrivateName) {\n        // Private generator method\n        this.pushClassPrivateMethod(classBody, privateMethod, true, false);\n        return;\n      }\n\n      if (this.isNonstaticConstructor(publicMethod)) {\n        this.raise(Errors.ConstructorIsGenerator, publicMethod.key);\n      }\n\n      this.pushClassMethod(\n        classBody,\n        publicMethod,\n        true,\n        false,\n        /* isConstructor */ false,\n        false,\n      );\n\n      return;\n    }\n\n    const isContextual =\n      !this.state.containsEsc && tokenIsIdentifier(this.state.type);\n    const key = this.parseClassElementName(member);\n    const maybeContextualKw = isContextual ? (key as N.Identifier).name : null;\n    const isPrivate = this.isPrivateName(key);\n    const maybeQuestionTokenStartLoc = this.state.startLoc;\n\n    this.parsePostMemberNameModifiers(publicMember);\n\n    if (this.isClassMethod()) {\n      method.kind = \"method\";\n\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n        return;\n      }\n\n      // a normal method\n      const isConstructor = this.isNonstaticConstructor(publicMethod);\n      let allowsDirectSuper = false;\n      if (isConstructor) {\n        publicMethod.kind = \"constructor\";\n\n        // TypeScript allows multiple overloaded constructor declarations.\n        if (state.hadConstructor && !this.hasPlugin(\"typescript\")) {\n          this.raise(Errors.DuplicateConstructor, key);\n        }\n        if (isConstructor && this.hasPlugin(\"typescript\") && member.override) {\n          this.raise(Errors.OverrideOnConstructor, key);\n        }\n        state.hadConstructor = true;\n        allowsDirectSuper = state.hadSuperClass;\n      }\n\n      this.pushClassMethod(\n        classBody,\n        publicMethod,\n        false,\n        false,\n        isConstructor,\n        allowsDirectSuper,\n      );\n    } else if (this.isClassProperty()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else if (maybeContextualKw === \"async\" && !this.isLineTerminator()) {\n      // an async method\n      this.resetPreviousNodeTrailingComments(key);\n      const isGenerator = this.eat(tt.star);\n\n      if (publicMember.optional) {\n        this.unexpected(maybeQuestionTokenStartLoc);\n      }\n\n      method.kind = \"method\";\n      // The so-called parsed name would have been \"async\": get the real name.\n      const isPrivate = this.match(tt.privateName);\n      this.parseClassElementName(method);\n      this.parsePostMemberNameModifiers(publicMember);\n\n      if (isPrivate) {\n        // private async method\n        this.pushClassPrivateMethod(\n          classBody,\n          privateMethod,\n          isGenerator,\n          true,\n        );\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(Errors.ConstructorIsAsync, publicMethod.key);\n        }\n\n        this.pushClassMethod(\n          classBody,\n          publicMethod,\n          isGenerator,\n          true,\n          /* isConstructor */ false,\n          false,\n        );\n      }\n    } else if (\n      (maybeContextualKw === \"get\" || maybeContextualKw === \"set\") &&\n      !(this.match(tt.star) && this.isLineTerminator())\n    ) {\n      // `get\\n*` is an uninitialized property named 'get' followed by a generator.\n      // a getter or setter\n      this.resetPreviousNodeTrailingComments(key);\n      method.kind = maybeContextualKw;\n      // The so-called parsed name would have been \"get/set\": get the real name.\n      const isPrivate = this.match(tt.privateName);\n      this.parseClassElementName(publicMethod);\n\n      if (isPrivate) {\n        // private getter/setter\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(Errors.ConstructorIsAccessor, publicMethod.key);\n        }\n        this.pushClassMethod(\n          classBody,\n          publicMethod,\n          false,\n          false,\n          /* isConstructor */ false,\n          false,\n        );\n      }\n\n      this.checkGetterSetterParams(publicMethod);\n    } else if (maybeContextualKw === \"accessor\" && !this.isLineTerminator()) {\n      this.expectPlugin(\"decoratorAutoAccessors\");\n      this.resetPreviousNodeTrailingComments(key);\n\n      // The so-called parsed name would have been \"accessor\": get the real name.\n      const isPrivate = this.match(tt.privateName);\n      this.parseClassElementName(publicProp);\n      this.pushClassAccessorProperty(classBody, accessorProp, isPrivate);\n    } else if (this.isLineTerminator()) {\n      // an uninitialized class property (due to ASI, since we don't otherwise recognize the next token)\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else {\n      this.unexpected();\n    }\n  }\n\n  // https://tc39.es/ecma262/#prod-ClassElementName\n  parseClassElementName(\n    this: Parser,\n    member: Undone<N.ClassMember>,\n  ): N.Expression | N.Identifier | N.PrivateName {\n    const { type, value } = this.state;\n    if (\n      (type === tt.name || type === tt.string) &&\n      member.static &&\n      value === \"prototype\"\n    ) {\n      this.raise(Errors.StaticPrototype, this.state.startLoc);\n    }\n\n    if (type === tt.privateName) {\n      if (value === \"constructor\") {\n        this.raise(Errors.ConstructorClassPrivateField, this.state.startLoc);\n      }\n      const key = this.parsePrivateName();\n      member.key = key;\n      return key;\n    }\n\n    this.parsePropertyName(member);\n    return member.key;\n  }\n\n  parseClassStaticBlock(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    member: Undone<\n      N.StaticBlock & {\n        decorators?: Array<N.Decorator>;\n      }\n    >,\n  ) {\n    // Start a new lexical scope\n    this.scope.enter(\n      ScopeFlag.CLASS | ScopeFlag.STATIC_BLOCK | ScopeFlag.SUPER,\n    );\n    // Start a new scope with regard to loop labels\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    // ClassStaticBlockStatementList:\n    //   StatementList[~Yield, ~Await, ~Return] opt\n    this.prodParam.enter(ParamKind.PARAM);\n    const body: N.Statement[] = (member.body = []);\n    this.parseBlockOrModuleBlockBody(body, undefined, false, tt.braceR);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.labels = oldLabels;\n    classBody.body.push(this.finishNode<N.StaticBlock>(member, \"StaticBlock\"));\n    if (member.decorators?.length) {\n      this.raise(Errors.DecoratorStaticBlock, member);\n    }\n  }\n\n  pushClassProperty(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    prop: N.ClassProperty,\n  ) {\n    if (!prop.computed && this.nameIsConstructor(prop.key)) {\n      // Non-computed field, which is either an identifier named \"constructor\"\n      // or a string literal named \"constructor\"\n      this.raise(Errors.ConstructorClassField, prop.key);\n    }\n\n    classBody.body.push(this.parseClassProperty(prop));\n  }\n\n  pushClassPrivateProperty(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    prop: Undone<N.ClassPrivateProperty>,\n  ) {\n    const node = this.parseClassPrivateProperty(prop);\n    classBody.body.push(node);\n\n    this.classScope.declarePrivateName(\n      this.getPrivateNameSV(node.key),\n      ClassElementType.OTHER,\n      node.key.loc.start,\n    );\n  }\n\n  pushClassAccessorProperty(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    prop: N.ClassAccessorProperty,\n    isPrivate: boolean,\n  ) {\n    if (!isPrivate && !prop.computed && this.nameIsConstructor(prop.key)) {\n      // Non-computed field, which is either an identifier named \"constructor\"\n      // or a string literal named \"constructor\"\n      this.raise(Errors.ConstructorClassField, prop.key);\n    }\n\n    const node = this.parseClassAccessorProperty(prop);\n    classBody.body.push(node);\n\n    if (isPrivate) {\n      this.classScope.declarePrivateName(\n        this.getPrivateNameSV(node.key as N.PrivateName),\n        ClassElementType.OTHER,\n        node.key.loc.start,\n      );\n    }\n  }\n\n  pushClassMethod(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    method: Undone<N.ClassMethod>,\n    isGenerator: boolean,\n    isAsync: boolean,\n    isConstructor: boolean,\n    allowsDirectSuper: boolean,\n  ): void {\n    classBody.body.push(\n      this.parseMethod(\n        method,\n        isGenerator,\n        isAsync,\n        isConstructor,\n        allowsDirectSuper,\n        \"ClassMethod\",\n        true,\n      ),\n    );\n  }\n\n  pushClassPrivateMethod(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    method: Undone<N.ClassPrivateMethod>,\n    isGenerator: boolean,\n    isAsync: boolean,\n  ): void {\n    const node = this.parseMethod(\n      method,\n      isGenerator,\n      isAsync,\n      /* isConstructor */ false,\n      false,\n      \"ClassPrivateMethod\",\n      true,\n    );\n    classBody.body.push(node);\n\n    const kind =\n      node.kind === \"get\"\n        ? node.static\n          ? ClassElementType.STATIC_GETTER\n          : ClassElementType.INSTANCE_GETTER\n        : node.kind === \"set\"\n          ? node.static\n            ? ClassElementType.STATIC_SETTER\n            : ClassElementType.INSTANCE_SETTER\n          : ClassElementType.OTHER;\n    this.declareClassPrivateMethodInScope(node, kind);\n  }\n\n  declareClassPrivateMethodInScope(\n    node: Undone<N.ClassPrivateMethod | N.TSDeclareMethod>,\n    kind: number,\n  ) {\n    this.classScope.declarePrivateName(\n      this.getPrivateNameSV(node.key as N.PrivateName),\n      kind,\n      node.key.loc.start,\n    );\n  }\n\n  // Overridden in typescript.js\n  parsePostMemberNameModifiers(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    methodOrProp: Undone<N.ClassMethod | N.ClassProperty>,\n  ): void {}\n\n  // https://tc39.es/ecma262/#prod-FieldDefinition\n  parseClassPrivateProperty(\n    this: Parser,\n    node: Undone<N.ClassPrivateProperty>,\n  ): N.ClassPrivateProperty {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassPrivateProperty\");\n  }\n\n  // https://tc39.es/ecma262/#prod-FieldDefinition\n  parseClassProperty(this: Parser, node: N.ClassProperty): N.ClassProperty {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassProperty\");\n  }\n\n  parseClassAccessorProperty(\n    this: Parser,\n    node: N.ClassAccessorProperty,\n  ): N.ClassAccessorProperty {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassAccessorProperty\");\n  }\n\n  // https://tc39.es/ecma262/#prod-Initializer\n  parseInitializer(\n    this: Parser,\n    node: Undone<\n      N.ClassProperty | N.ClassPrivateProperty | N.ClassAccessorProperty\n    >,\n  ): void {\n    this.scope.enter(ScopeFlag.CLASS | ScopeFlag.SUPER);\n    this.expressionScope.enter(newExpressionScope());\n    this.prodParam.enter(ParamKind.PARAM);\n    node.value = this.eat(tt.eq) ? this.parseMaybeAssignAllowIn() : null;\n    this.expressionScope.exit();\n    this.prodParam.exit();\n    this.scope.exit();\n  }\n\n  parseClassId(\n    node: Undone<N.Class>,\n    isStatement: boolean,\n    optionalId?: boolean | null,\n    bindingType: BindingFlag = BindingFlag.TYPE_CLASS,\n  ): void {\n    if (tokenIsIdentifier(this.state.type)) {\n      node.id = this.parseIdentifier();\n      if (isStatement) {\n        this.declareNameFromIdentifier(node.id, bindingType);\n      }\n    } else {\n      if (optionalId || !isStatement) {\n        node.id = null;\n      } else {\n        throw this.raise(Errors.MissingClassName, this.state.startLoc);\n      }\n    }\n  }\n\n  // https://tc39.es/ecma262/#prod-ClassHeritage\n  parseClassSuper(this: Parser, node: Undone<N.Class>): void {\n    node.superClass = this.eat(tt._extends) ? this.parseExprSubscripts() : null;\n  }\n\n  // Parses module export declaration.\n  // https://tc39.es/ecma262/#prod-ExportDeclaration\n\n  parseExport(\n    this: Parser,\n    node: Undone<\n      | N.ExportDefaultDeclaration\n      | N.ExportAllDeclaration\n      | N.ExportNamedDeclaration\n    >,\n    decorators: N.Decorator[] | null,\n  ): N.AnyExport {\n    const maybeDefaultIdentifier = this.parseMaybeImportPhase(\n      node,\n      /* isExport */ true,\n    );\n    const hasDefault = this.maybeParseExportDefaultSpecifier(\n      node,\n      maybeDefaultIdentifier,\n    );\n    const parseAfterDefault = !hasDefault || this.eat(tt.comma);\n    const hasStar = parseAfterDefault && this.eatExportStar(node);\n    const hasNamespace =\n      hasStar && this.maybeParseExportNamespaceSpecifier(node);\n    const parseAfterNamespace =\n      parseAfterDefault && (!hasNamespace || this.eat(tt.comma));\n    const isFromRequired = hasDefault || hasStar;\n\n    if (hasStar && !hasNamespace) {\n      if (hasDefault) this.unexpected();\n      if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, node);\n      }\n      this.parseExportFrom(node, true);\n\n      this.sawUnambiguousESM = true;\n\n      return this.finishNode(node, \"ExportAllDeclaration\");\n    }\n\n    const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);\n\n    if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) {\n      this.unexpected(null, tt.braceL);\n    }\n\n    if (hasNamespace && parseAfterNamespace) {\n      this.unexpected(null, tt._from);\n    }\n\n    let hasDeclaration;\n    if (isFromRequired || hasSpecifiers) {\n      hasDeclaration = false;\n      if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, node);\n      }\n      this.parseExportFrom(\n        node as Undone<N.ExportNamedDeclaration>,\n        isFromRequired,\n      );\n    } else {\n      hasDeclaration = this.maybeParseExportDeclaration(\n        node as Undone<N.ExportNamedDeclaration>,\n      );\n    }\n\n    if (isFromRequired || hasSpecifiers || hasDeclaration) {\n      const node2 = node as Undone<N.ExportNamedDeclaration>;\n      this.checkExport(node2, true, false, !!node2.source);\n      if (node2.declaration?.type === \"ClassDeclaration\") {\n        this.maybeTakeDecorators(decorators, node2.declaration, node2);\n      } else if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, node);\n      }\n      this.sawUnambiguousESM = true;\n      return this.finishNode(node2, \"ExportNamedDeclaration\");\n    }\n\n    if (this.eat(tt._default)) {\n      const node2 = node as Undone<N.ExportDefaultDeclaration>;\n      // export default ...\n      const decl = this.parseExportDefaultExpression();\n      node2.declaration = decl;\n\n      if (decl.type === \"ClassDeclaration\") {\n        this.maybeTakeDecorators(decorators, decl as N.ClassDeclaration, node2);\n      } else if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, node);\n      }\n\n      this.checkExport(node2, true, true);\n      this.sawUnambiguousESM = true;\n      return this.finishNode(node2, \"ExportDefaultDeclaration\");\n    }\n\n    this.unexpected(null, tt.braceL);\n  }\n\n  eatExportStar(\n    node: Undone<N.Node>,\n  ): node is Undone<N.ExportNamedDeclaration | N.ExportAllDeclaration> {\n    return this.eat(tt.star);\n  }\n\n  maybeParseExportDefaultSpecifier(\n    node: Undone<\n      | N.ExportDefaultDeclaration\n      | N.ExportAllDeclaration\n      | N.ExportNamedDeclaration\n    >,\n    maybeDefaultIdentifier: N.Identifier | null,\n  ): node is Undone<N.ExportNamedDeclaration> {\n    if (maybeDefaultIdentifier || this.isExportDefaultSpecifier()) {\n      // export defaultObj ...\n      this.expectPlugin(\"exportDefaultFrom\", maybeDefaultIdentifier?.loc.start);\n      const id = maybeDefaultIdentifier || this.parseIdentifier(true);\n      const specifier = this.startNodeAtNode<N.ExportDefaultSpecifier>(id);\n      specifier.exported = id;\n      (node as Undone<N.ExportNamedDeclaration>).specifiers = [\n        this.finishNode(specifier, \"ExportDefaultSpecifier\"),\n      ];\n      return true;\n    }\n    return false;\n  }\n\n  maybeParseExportNamespaceSpecifier(\n    node: Undone<N.ExportNamedDeclaration | N.ExportAllDeclaration>,\n  ): node is Undone<N.ExportNamedDeclaration> {\n    if (this.isContextual(tt._as)) {\n      (node as Undone<N.ExportNamedDeclaration>).specifiers ??= [];\n\n      const specifier = this.startNodeAt<N.ExportNamespaceSpecifier>(\n        this.state.lastTokStartLoc,\n      );\n\n      this.next();\n\n      specifier.exported = this.parseModuleExportName();\n      (node as Undone<N.ExportNamedDeclaration>).specifiers.push(\n        this.finishNode(specifier, \"ExportNamespaceSpecifier\"),\n      );\n      return true;\n    }\n    return false;\n  }\n\n  maybeParseExportNamedSpecifiers(\n    node: Undone<N.Node>,\n  ): node is Undone<N.ExportNamedDeclaration> {\n    if (this.match(tt.braceL)) {\n      const node2 = node as Undone<N.ExportNamedDeclaration>;\n\n      if (!node2.specifiers) node2.specifiers = [];\n      const isTypeExport = node2.exportKind === \"type\";\n      node2.specifiers.push(...this.parseExportSpecifiers(isTypeExport));\n      node2.source = null;\n      if (!process.env.BABEL_8_BREAKING && this.hasPlugin(\"importAssertions\")) {\n        node2.assertions = [];\n      } else {\n        node2.attributes = [];\n      }\n      node2.declaration = null;\n      return true;\n    }\n    return false;\n  }\n\n  maybeParseExportDeclaration(\n    this: Parser,\n    node: Undone<N.ExportNamedDeclaration>,\n  ): boolean {\n    if (this.shouldParseExportDeclaration()) {\n      node.specifiers = [];\n      node.source = null;\n      if (!process.env.BABEL_8_BREAKING && this.hasPlugin(\"importAssertions\")) {\n        node.assertions = [];\n      } else {\n        node.attributes = [];\n      }\n      node.declaration = this.parseExportDeclaration(node);\n      return true;\n    }\n    return false;\n  }\n\n  isAsyncFunction(): boolean {\n    if (!this.isContextual(tt._async)) return false;\n    const next = this.nextTokenInLineStart();\n    return this.isUnparsedContextual(next, \"function\");\n  }\n\n  parseExportDefaultExpression(\n    this: Parser,\n  ): N.ExportDefaultDeclaration[\"declaration\"] {\n    const expr = this.startNode();\n\n    if (this.match(tt._function)) {\n      this.next();\n      return this.parseFunction(\n        expr as Undone<N.FunctionDeclaration>,\n        ParseFunctionFlag.Declaration | ParseFunctionFlag.NullableId,\n      );\n    } else if (this.isAsyncFunction()) {\n      this.next(); // eat 'async'\n      this.next(); // eat 'function'\n      return this.parseFunction(\n        expr as Undone<N.FunctionDeclaration>,\n        ParseFunctionFlag.Declaration |\n          ParseFunctionFlag.NullableId |\n          ParseFunctionFlag.Async,\n      );\n    }\n\n    if (this.match(tt._class)) {\n      return this.parseClass(expr as Undone<N.ClassExpression>, true, true);\n    }\n\n    if (this.match(tt.at)) {\n      if (\n        this.hasPlugin(\"decorators\") &&\n        this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") === true\n      ) {\n        this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);\n      }\n      return this.parseClass(\n        this.maybeTakeDecorators(\n          this.parseDecorators(false),\n          this.startNode<N.ClassDeclaration>(),\n        ),\n        true,\n        true,\n      );\n    }\n\n    if (this.match(tt._const) || this.match(tt._var) || this.isLet()) {\n      throw this.raise(Errors.UnsupportedDefaultExport, this.state.startLoc);\n    }\n\n    const res = this.parseMaybeAssignAllowIn();\n    this.semicolon();\n    return res;\n  }\n\n  // https://tc39.es/ecma262/#prod-ExportDeclaration\n  parseExportDeclaration(\n    this: Parser,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    node: Undone<N.ExportNamedDeclaration>,\n  ): N.Declaration | undefined | null {\n    if (this.match(tt._class)) {\n      const node = this.parseClass(\n        this.startNode<N.ClassDeclaration>(),\n        true,\n        false,\n      );\n      return node;\n    }\n    return this.parseStatementListItem() as N.Declaration;\n  }\n\n  isExportDefaultSpecifier(): boolean {\n    const { type } = this.state;\n    if (tokenIsIdentifier(type)) {\n      if ((type === tt._async && !this.state.containsEsc) || type === tt._let) {\n        return false;\n      }\n      if (\n        (type === tt._type || type === tt._interface) &&\n        !this.state.containsEsc\n      ) {\n        const { type: nextType } = this.lookahead();\n        // If we see any variable name other than `from` after `type` keyword,\n        // we consider it as flow/typescript type exports\n        // note that this approach may fail on some pedantic cases\n        // export type from = number\n        if (\n          (tokenIsIdentifier(nextType) && nextType !== tt._from) ||\n          nextType === tt.braceL\n        ) {\n          this.expectOnePlugin([\"flow\", \"typescript\"]);\n          return false;\n        }\n      }\n    } else if (!this.match(tt._default)) {\n      return false;\n    }\n\n    const next = this.nextTokenStart();\n    const hasFrom = this.isUnparsedContextual(next, \"from\");\n    if (\n      this.input.charCodeAt(next) === charCodes.comma ||\n      (tokenIsIdentifier(this.state.type) && hasFrom)\n    ) {\n      return true;\n    }\n    // lookahead again when `export default from` is seen\n    if (this.match(tt._default) && hasFrom) {\n      const nextAfterFrom = this.input.charCodeAt(\n        this.nextTokenStartSince(next + 4),\n      );\n      return (\n        nextAfterFrom === charCodes.quotationMark ||\n        nextAfterFrom === charCodes.apostrophe\n      );\n    }\n    return false;\n  }\n\n  parseExportFrom(\n    this: Parser,\n    node: Undone<N.ExportNamedDeclaration | N.ExportAllDeclaration>,\n    expect?: boolean,\n  ): void {\n    if (this.eatContextual(tt._from)) {\n      node.source = this.parseImportSource();\n      this.checkExport(node);\n      this.maybeParseImportAttributes(node);\n      this.checkJSONModuleImport(node);\n    } else if (expect) {\n      this.unexpected();\n    }\n\n    this.semicolon();\n  }\n\n  shouldParseExportDeclaration(): boolean {\n    const { type } = this.state;\n    if (type === tt.at) {\n      this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]);\n      if (this.hasPlugin(\"decorators\")) {\n        if (\n          this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") === true\n        ) {\n          this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);\n        }\n\n        return true;\n      }\n    }\n\n    if (this.isContextual(tt._using)) {\n      this.raise(Errors.UsingDeclarationExport, this.state.startLoc);\n      return true;\n    }\n\n    if (this.isContextual(tt._await) && this.startsAwaitUsing()) {\n      this.raise(Errors.UsingDeclarationExport, this.state.startLoc);\n      return true;\n    }\n\n    return (\n      type === tt._var ||\n      type === tt._const ||\n      type === tt._function ||\n      type === tt._class ||\n      this.isLet() ||\n      this.isAsyncFunction()\n    );\n  }\n\n  checkExport(\n    node: Undone<\n      | N.ExportNamedDeclaration\n      | N.ExportAllDeclaration\n      | N.ExportDefaultDeclaration\n    >,\n    checkNames?: boolean,\n    isDefault?: boolean,\n    isFrom?: boolean,\n  ): void {\n    if (checkNames) {\n      // Check for duplicate exports\n      if (isDefault) {\n        // Default exports\n        this.checkDuplicateExports(node, \"default\");\n        if (this.hasPlugin(\"exportDefaultFrom\")) {\n          const declaration = (node as any as N.ExportDefaultDeclaration)\n            .declaration;\n          if (\n            declaration.type === \"Identifier\" &&\n            declaration.name === \"from\" &&\n            declaration.end - declaration.start === 4 && // does not contain escape\n            !declaration.extra?.parenthesized\n          ) {\n            this.raise(Errors.ExportDefaultFromAsIdentifier, declaration);\n          }\n        }\n        // @ts-expect-error node.specifiers may not exist\n      } else if (node.specifiers?.length) {\n        // Named exports\n        // @ts-expect-error node.specifiers may not exist\n        for (const specifier of node.specifiers) {\n          const { exported } = specifier;\n          const exportName =\n            exported.type === \"Identifier\" ? exported.name : exported.value;\n          this.checkDuplicateExports(specifier, exportName);\n          if (!isFrom && specifier.local) {\n            const { local } = specifier;\n            if (local.type !== \"Identifier\") {\n              this.raise(Errors.ExportBindingIsString, specifier, {\n                localName: local.value,\n                exportName,\n              });\n            } else {\n              // check for keywords used as local names\n              this.checkReservedWord(local.name, local.loc.start, true, false);\n              // check if export is defined\n              this.scope.checkLocalExport(local);\n            }\n          }\n        }\n      } else if ((node as Undone<N.ExportNamedDeclaration>).declaration) {\n        const decl = (node as Undone<N.ExportNamedDeclaration>).declaration;\n        // Exported declarations\n        if (\n          decl.type === \"FunctionDeclaration\" ||\n          decl.type === \"ClassDeclaration\"\n        ) {\n          const { id } = decl;\n          if (!id) throw new Error(\"Assertion failure\");\n\n          this.checkDuplicateExports(node, id.name);\n        } else if (decl.type === \"VariableDeclaration\") {\n          for (const declaration of decl.declarations) {\n            this.checkDeclaration(declaration.id);\n          }\n        }\n      }\n    }\n  }\n\n  checkDeclaration(node: N.Pattern | N.ObjectProperty): void {\n    if (node.type === \"Identifier\") {\n      this.checkDuplicateExports(node, node.name);\n    } else if (node.type === \"ObjectPattern\") {\n      for (const prop of node.properties) {\n        this.checkDeclaration(prop);\n      }\n    } else if (node.type === \"ArrayPattern\") {\n      for (const elem of node.elements) {\n        if (elem) {\n          this.checkDeclaration(elem);\n        }\n      }\n    } else if (node.type === \"ObjectProperty\") {\n      // @ts-expect-error migrate to Babel types\n      this.checkDeclaration(node.value);\n    } else if (node.type === \"RestElement\") {\n      this.checkDeclaration(node.argument);\n    } else if (node.type === \"AssignmentPattern\") {\n      this.checkDeclaration(node.left);\n    }\n  }\n\n  checkDuplicateExports(\n    node: Undone<\n      | N.Identifier\n      | N.StringLiteral\n      | N.ExportNamedDeclaration\n      | N.ExportSpecifier\n      | N.ExportDefaultSpecifier\n    >,\n    exportName: string,\n  ): void {\n    if (this.exportedIdentifiers.has(exportName)) {\n      if (exportName === \"default\") {\n        this.raise(Errors.DuplicateDefaultExport, node);\n      } else {\n        this.raise(Errors.DuplicateExport, node, { exportName });\n      }\n    }\n    this.exportedIdentifiers.add(exportName);\n  }\n\n  // Parses a comma-separated list of module exports.\n\n  parseExportSpecifiers(isInTypeExport: boolean): Array<N.ExportSpecifier> {\n    const nodes = [];\n    let first = true;\n\n    // export { x, y as z } [from '...']\n    this.expect(tt.braceL);\n\n    while (!this.eat(tt.braceR)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(tt.comma);\n        if (this.eat(tt.braceR)) break;\n      }\n      const isMaybeTypeOnly = this.isContextual(tt._type);\n      const isString = this.match(tt.string);\n      const node = this.startNode<N.ExportSpecifier>();\n      node.local = this.parseModuleExportName() as N.Identifier;\n      nodes.push(\n        this.parseExportSpecifier(\n          node,\n          isString,\n          isInTypeExport,\n          isMaybeTypeOnly,\n        ),\n      );\n    }\n\n    return nodes;\n  }\n\n  parseExportSpecifier(\n    node: any,\n    isString: boolean,\n    /* eslint-disable @typescript-eslint/no-unused-vars -- used in TypeScript parser */\n    isInTypeExport: boolean,\n    isMaybeTypeOnly: boolean,\n    /* eslint-enable @typescript-eslint/no-unused-vars */\n  ): N.ExportSpecifier {\n    if (this.eatContextual(tt._as)) {\n      node.exported = this.parseModuleExportName();\n    } else if (isString) {\n      node.exported = cloneStringLiteral(node.local);\n    } else if (!node.exported) {\n      node.exported = cloneIdentifier(node.local);\n    }\n    return this.finishNode<N.ExportSpecifier>(node, \"ExportSpecifier\");\n  }\n\n  // https://tc39.es/ecma262/#prod-ModuleExportName\n  parseModuleExportName(): N.StringLiteral | N.Identifier {\n    if (this.match(tt.string)) {\n      const result = this.parseStringLiteral(this.state.value);\n      const surrogate = loneSurrogate.exec(result.value);\n      if (surrogate) {\n        this.raise(Errors.ModuleExportNameHasLoneSurrogate, result, {\n          surrogateCharCode: surrogate[0].charCodeAt(0),\n        });\n      }\n      return result;\n    }\n    return this.parseIdentifier(true);\n  }\n\n  isJSONModuleImport(\n    node: Undone<\n      N.ExportAllDeclaration | N.ExportNamedDeclaration | N.ImportDeclaration\n    >,\n  ): boolean {\n    if (node.assertions != null) {\n      return node.assertions.some(({ key, value }) => {\n        return (\n          value.value === \"json\" &&\n          (key.type === \"Identifier\"\n            ? key.name === \"type\"\n            : key.value === \"type\")\n        );\n      });\n    }\n    return false;\n  }\n\n  checkImportReflection(node: Undone<N.ImportDeclaration>) {\n    const { specifiers } = node;\n    const singleBindingType =\n      specifiers.length === 1 ? specifiers[0].type : null;\n\n    if (node.phase === \"source\") {\n      if (singleBindingType !== \"ImportDefaultSpecifier\") {\n        this.raise(\n          Errors.SourcePhaseImportRequiresDefault,\n          specifiers[0].loc.start,\n        );\n      }\n    } else if (node.phase === \"defer\") {\n      if (singleBindingType !== \"ImportNamespaceSpecifier\") {\n        this.raise(\n          Errors.DeferImportRequiresNamespace,\n          specifiers[0].loc.start,\n        );\n      }\n    } else if (node.module) {\n      if (singleBindingType !== \"ImportDefaultSpecifier\") {\n        this.raise(Errors.ImportReflectionNotBinding, specifiers[0].loc.start);\n      }\n      if (node.assertions?.length > 0) {\n        this.raise(\n          Errors.ImportReflectionHasAssertion,\n          specifiers[0].loc.start,\n        );\n      }\n    }\n  }\n\n  checkJSONModuleImport(\n    node: Undone<\n      N.ExportAllDeclaration | N.ExportNamedDeclaration | N.ImportDeclaration\n    >,\n  ) {\n    // @ts-expect-error Fixme: node.type must be undefined because they are undone\n    if (this.isJSONModuleImport(node) && node.type !== \"ExportAllDeclaration\") {\n      // @ts-expect-error specifiers may not index node\n      const { specifiers } = node;\n      if (specifiers != null) {\n        // @ts-expect-error refine specifier types\n        const nonDefaultNamedSpecifier = specifiers.find(specifier => {\n          let imported;\n          if (specifier.type === \"ExportSpecifier\") {\n            imported = specifier.local;\n          } else if (specifier.type === \"ImportSpecifier\") {\n            imported = specifier.imported;\n          }\n          if (imported !== undefined) {\n            return imported.type === \"Identifier\"\n              ? imported.name !== \"default\"\n              : imported.value !== \"default\";\n          }\n        });\n        if (nonDefaultNamedSpecifier !== undefined) {\n          this.raise(\n            Errors.ImportJSONBindingNotDefault,\n            nonDefaultNamedSpecifier.loc.start,\n          );\n        }\n      }\n    }\n  }\n\n  isPotentialImportPhase(isExport: boolean): boolean {\n    if (isExport) return false;\n    return (\n      this.isContextual(tt._source) ||\n      this.isContextual(tt._defer) ||\n      (!process.env.BABEL_8_BREAKING && this.isContextual(tt._module))\n    );\n  }\n\n  applyImportPhase(\n    node: Undone<N.ImportDeclaration | N.ExportNamedDeclaration>,\n    isExport: boolean,\n    phase: string | null,\n    loc?: Position,\n  ): void {\n    if (isExport) {\n      if (!process.env.IS_PUBLISH) {\n        if (\n          (!process.env.BABEL_8_BREAKING && phase === \"module\") ||\n          phase === \"source\"\n        ) {\n          throw new Error(\n            `Assertion failure: export declarations do not support the '${phase}' phase.`,\n          );\n        }\n      }\n      return;\n    }\n\n    if (!process.env.BABEL_8_BREAKING && phase === \"module\") {\n      this.expectPlugin(\"importReflection\", loc);\n      (node as N.ImportDeclaration).module = true;\n    } else if (this.hasPlugin(\"importReflection\")) {\n      (node as N.ImportDeclaration).module = false;\n    }\n\n    if (phase === \"source\") {\n      this.expectPlugin(\"sourcePhaseImports\", loc);\n      (node as N.ImportDeclaration).phase = \"source\";\n    } else if (phase === \"defer\") {\n      this.expectPlugin(\"deferredImportEvaluation\", loc);\n      (node as N.ImportDeclaration).phase = \"defer\";\n    } else if (this.hasPlugin(\"sourcePhaseImports\")) {\n      (node as N.ImportDeclaration).phase = null;\n    }\n  }\n\n  /*\n   * Parse `source` in `import source x from \"x\"`, disambiguating\n   * `import source from \"x\"` and `import source from from \"x\"`.\n   *\n   * This function might return an identifier representing the `source`\n   * if it eats `source` and then discovers that it was the default import\n   * binding and not the import reflection.\n   *\n   * This function is also used to parse `import type` and `import typeof`\n   * in the TS and Flow plugins, and for parsing `import defer`.\n   */\n  parseMaybeImportPhase(\n    node: Undone<N.ImportDeclaration | N.TsImportEqualsDeclaration>,\n    isExport: boolean,\n  ): N.Identifier | null {\n    if (!this.isPotentialImportPhase(isExport)) {\n      this.applyImportPhase(\n        node as Undone<N.ImportDeclaration>,\n        isExport,\n        null,\n      );\n      return null;\n    }\n\n    const phaseIdentifier = this.parseIdentifier(true);\n\n    const { type } = this.state;\n    const isImportPhase = tokenIsKeywordOrIdentifier(type)\n      ? // OK: import <phase> x from \"foo\";\n        // OK: import <phase> from from \"foo\";\n        // NO: import <phase> from \"foo\";\n        // NO: import <phase> from 'foo';\n        // With the module declarations proposals, we will need further disambiguation\n        // for `import module from from;`.\n        type !== tt._from || this.lookaheadCharCode() === charCodes.lowercaseF\n      : // OK: import <phase> { x } from \"foo\";\n        // OK: import <phase> x from \"foo\";\n        // OK: import <phase> * as T from \"foo\";\n        // NO: import <phase> from \"foo\";\n        // OK: import <phase> \"foo\";\n        // The last one is invalid, we will continue parsing and throw\n        // an error later\n        type !== tt.comma;\n\n    if (isImportPhase) {\n      this.resetPreviousIdentifierLeadingComments(phaseIdentifier);\n      this.applyImportPhase(\n        node as Undone<N.ImportDeclaration>,\n        isExport,\n        phaseIdentifier.name,\n        phaseIdentifier.loc.start,\n      );\n      return null;\n    } else {\n      this.applyImportPhase(\n        node as Undone<N.ImportDeclaration>,\n        isExport,\n        null,\n      );\n      // `<phase>` is a default binding, return it to the main import declaration parser\n      return phaseIdentifier;\n    }\n  }\n\n  isPrecedingIdImportPhase(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    phase: string,\n  ) {\n    const { type } = this.state;\n    return tokenIsIdentifier(type)\n      ? // OK: import <phase> x from \"foo\";\n        // OK: import <phase> from from \"foo\";\n        // NO: import <phase> from \"foo\";\n        // NO: import <phase> from 'foo';\n        // With the module declarations proposals, we will need further disambiguation\n        // for `import module from from;`.\n        type !== tt._from || this.lookaheadCharCode() === charCodes.lowercaseF\n      : // OK: import <phase> { x } from \"foo\";\n        // OK: import <phase> x from \"foo\";\n        // OK: import <phase> * as T from \"foo\";\n        // NO: import <phase> from \"foo\";\n        // OK: import <phase> \"foo\";\n        // The last one is invalid, we will continue parsing and throw\n        // an error later\n        type !== tt.comma;\n  }\n\n  // Parses import declaration.\n  // https://tc39.es/ecma262/#prod-ImportDeclaration\n\n  parseImport(this: Parser, node: Undone<N.ImportDeclaration>): N.AnyImport {\n    if (this.match(tt.string)) {\n      // import '...'\n      return this.parseImportSourceAndAttributes(node);\n    }\n\n    return this.parseImportSpecifiersAndAfter(\n      node,\n      this.parseMaybeImportPhase(node, /* isExport */ false),\n    );\n  }\n\n  parseImportSpecifiersAndAfter(\n    this: Parser,\n    node: Undone<N.ImportDeclaration>,\n    maybeDefaultIdentifier: N.Identifier | null,\n  ): N.AnyImport {\n    node.specifiers = [];\n\n    // check if we have a default import like\n    // import React from \"react\";\n    const hasDefault = this.maybeParseDefaultImportSpecifier(\n      node,\n      maybeDefaultIdentifier,\n    );\n    /* we are checking if we do not have a default import, then it is obvious that we need named imports\n     * import { get } from \"axios\";\n     * but if we do have a default import\n     * we need to check if we have a comma after that and\n     * that is where this `|| this.eat` condition comes into play\n     */\n    const parseNext = !hasDefault || this.eat(tt.comma);\n    // if we do have to parse the next set of specifiers, we first check for star imports\n    // import React, * from \"react\";\n    const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);\n    // now we check if we need to parse the next imports\n    // but only if they are not importing * (everything)\n    if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);\n    this.expectContextual(tt._from);\n\n    return this.parseImportSourceAndAttributes(node);\n  }\n\n  parseImportSourceAndAttributes(\n    this: Parser,\n    node: Undone<N.ImportDeclaration>,\n  ): N.AnyImport {\n    node.specifiers ??= [];\n    node.source = this.parseImportSource();\n    this.maybeParseImportAttributes(node);\n    this.checkImportReflection(node);\n    this.checkJSONModuleImport(node);\n\n    this.semicolon();\n    this.sawUnambiguousESM = true;\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n\n  parseImportSource(this: Parser): N.StringLiteral {\n    if (!this.match(tt.string)) this.unexpected();\n    return this.parseExprAtom() as N.StringLiteral;\n  }\n\n  parseImportSpecifierLocal<\n    T extends\n      | N.ImportSpecifier\n      | N.ImportDefaultSpecifier\n      | N.ImportNamespaceSpecifier,\n  >(\n    node: Undone<N.ImportDeclaration>,\n    specifier: Undone<T>,\n    type: T[\"type\"],\n  ): void {\n    specifier.local = this.parseIdentifier();\n    node.specifiers.push(this.finishImportSpecifier(specifier, type));\n  }\n\n  finishImportSpecifier<\n    T extends\n      | N.ImportSpecifier\n      | N.ImportDefaultSpecifier\n      | N.ImportNamespaceSpecifier,\n  >(\n    specifier: Undone<T>,\n    type: T[\"type\"],\n    bindingType: BindingFlag = BindingFlag.TYPE_LEXICAL,\n  ) {\n    this.checkLVal(specifier.local, { type }, bindingType);\n    return this.finishNode(specifier, type);\n  }\n\n  /**\n   * parse assert entries\n   *\n   * @see {@link https://tc39.es/proposal-import-attributes/#prod-WithEntries WithEntries}\n   */\n  parseImportAttributes(): N.ImportAttribute[] {\n    this.expect(tt.braceL);\n\n    const attrs = [];\n    const attrNames = new Set();\n\n    do {\n      if (this.match(tt.braceR)) {\n        break;\n      }\n\n      const node = this.startNode<N.ImportAttribute>();\n\n      // parse AssertionKey : IdentifierName, StringLiteral\n      const keyName = this.state.value;\n      // check if we already have an entry for an attribute\n      // if a duplicate entry is found, throw an error\n      // for now this logic will come into play only when someone declares `type` twice\n      if (attrNames.has(keyName)) {\n        this.raise(\n          Errors.ModuleAttributesWithDuplicateKeys,\n          this.state.startLoc,\n          {\n            key: keyName,\n          },\n        );\n      }\n      attrNames.add(keyName);\n      if (this.match(tt.string)) {\n        node.key = this.parseStringLiteral(keyName);\n      } else {\n        node.key = this.parseIdentifier(true);\n      }\n      this.expect(tt.colon);\n\n      if (!this.match(tt.string)) {\n        throw this.raise(\n          Errors.ModuleAttributeInvalidValue,\n          this.state.startLoc,\n        );\n      }\n      node.value = this.parseStringLiteral(this.state.value);\n      attrs.push(this.finishNode(node, \"ImportAttribute\"));\n    } while (this.eat(tt.comma));\n\n    this.expect(tt.braceR);\n\n    return attrs;\n  }\n\n  /**\n   * parse module attributes\n   * @deprecated It will be removed in Babel 8\n   */\n  parseModuleAttributes() {\n    const attrs: N.ImportAttribute[] = [];\n    const attributes = new Set();\n    do {\n      const node = this.startNode<N.ImportAttribute>();\n      node.key = this.parseIdentifier(true);\n\n      if (node.key.name !== \"type\") {\n        this.raise(Errors.ModuleAttributeDifferentFromType, node.key);\n      }\n\n      if (attributes.has(node.key.name)) {\n        this.raise(Errors.ModuleAttributesWithDuplicateKeys, node.key, {\n          key: node.key.name,\n        });\n      }\n      attributes.add(node.key.name);\n      this.expect(tt.colon);\n      if (!this.match(tt.string)) {\n        throw this.raise(\n          Errors.ModuleAttributeInvalidValue,\n          this.state.startLoc,\n        );\n      }\n      node.value = this.parseStringLiteral(this.state.value);\n      attrs.push(this.finishNode(node, \"ImportAttribute\"));\n    } while (this.eat(tt.comma));\n\n    return attrs;\n  }\n\n  maybeParseImportAttributes(\n    node: Undone<\n      N.ImportDeclaration | N.ExportNamedDeclaration | N.ExportAllDeclaration\n    >,\n  ) {\n    let attributes: N.ImportAttribute[];\n    if (!process.env.BABEL_8_BREAKING) {\n      // eslint-disable-next-line no-var\n      var useWith = false;\n    }\n\n    // https://tc39.es/proposal-import-attributes/#prod-WithClause\n    if (this.match(tt._with)) {\n      if (\n        this.hasPrecedingLineBreak() &&\n        this.lookaheadCharCode() === charCodes.leftParenthesis\n      ) {\n        // This will be parsed as a with statement, and we will throw a\n        // better error about it not being supported in strict mode.\n        return;\n      }\n\n      this.next(); // eat `with`\n\n      if (!process.env.BABEL_8_BREAKING && this.hasPlugin(\"moduleAttributes\")) {\n        attributes = this.parseModuleAttributes();\n      } else {\n        attributes = this.parseImportAttributes();\n      }\n      if (!process.env.BABEL_8_BREAKING) {\n        useWith = true;\n      }\n    } else if (this.isContextual(tt._assert) && !this.hasPrecedingLineBreak()) {\n      if (\n        !this.hasPlugin(\"deprecatedImportAssert\") &&\n        (process.env.BABEL_8_BREAKING || !this.hasPlugin(\"importAssertions\"))\n      ) {\n        this.raise(Errors.ImportAttributesUseAssert, this.state.startLoc);\n      }\n      if (process.env.BABEL_8_BREAKING || !this.hasPlugin(\"importAssertions\")) {\n        this.addExtra(node, \"deprecatedAssertSyntax\", true);\n      }\n      this.next(); // eat `assert`\n      attributes = this.parseImportAttributes();\n    } else {\n      attributes = [];\n    }\n\n    if (\n      !process.env.BABEL_8_BREAKING &&\n      !useWith &&\n      this.hasPlugin(\"importAssertions\")\n    ) {\n      node.assertions = attributes;\n    } else {\n      node.attributes = attributes;\n    }\n  }\n\n  maybeParseDefaultImportSpecifier(\n    node: Undone<N.ImportDeclaration>,\n    maybeDefaultIdentifier: N.Identifier | null,\n  ): boolean {\n    // import defaultObj, { x, y as z } from '...'\n    if (maybeDefaultIdentifier) {\n      const specifier = this.startNodeAtNode<N.ImportDefaultSpecifier>(\n        maybeDefaultIdentifier,\n      );\n      specifier.local = maybeDefaultIdentifier;\n      node.specifiers.push(\n        this.finishImportSpecifier(specifier, \"ImportDefaultSpecifier\"),\n      );\n      return true;\n    } else if (\n      // We allow keywords, and parseImportSpecifierLocal will report a recoverable error\n      tokenIsKeywordOrIdentifier(this.state.type)\n    ) {\n      this.parseImportSpecifierLocal(\n        node,\n        this.startNode<N.ImportDefaultSpecifier>(),\n        \"ImportDefaultSpecifier\",\n      );\n      return true;\n    }\n    return false;\n  }\n\n  maybeParseStarImportSpecifier(node: Undone<N.ImportDeclaration>): boolean {\n    if (this.match(tt.star)) {\n      const specifier = this.startNode<N.ImportNamespaceSpecifier>();\n      this.next();\n      this.expectContextual(tt._as);\n\n      this.parseImportSpecifierLocal(\n        node,\n        specifier,\n        \"ImportNamespaceSpecifier\",\n      );\n      return true;\n    }\n    return false;\n  }\n\n  parseNamedImportSpecifiers(node: Undone<N.ImportDeclaration>) {\n    let first = true;\n    this.expect(tt.braceL);\n    while (!this.eat(tt.braceR)) {\n      if (first) {\n        first = false;\n      } else {\n        // Detect an attempt to deep destructure\n        if (this.eat(tt.colon)) {\n          throw this.raise(Errors.DestructureNamedImport, this.state.startLoc);\n        }\n\n        this.expect(tt.comma);\n        if (this.eat(tt.braceR)) break;\n      }\n\n      const specifier = this.startNode<N.ImportSpecifier>();\n      const importedIsString = this.match(tt.string);\n      const isMaybeTypeOnly = this.isContextual(tt._type);\n      specifier.imported = this.parseModuleExportName();\n      const importSpecifier = this.parseImportSpecifier(\n        specifier,\n        importedIsString,\n        node.importKind === \"type\" || node.importKind === \"typeof\",\n        isMaybeTypeOnly,\n        undefined,\n      );\n      node.specifiers.push(importSpecifier);\n    }\n  }\n\n  // https://tc39.es/ecma262/#prod-ImportSpecifier\n  parseImportSpecifier(\n    specifier: Undone<N.ImportSpecifier>,\n    importedIsString: boolean,\n    /* used in TypeScript and Flow parser */\n    isInTypeOnlyImport: boolean,\n    isMaybeTypeOnly: boolean,\n    bindingType: BindingFlag | undefined,\n  ): N.ImportSpecifier {\n    if (this.eatContextual(tt._as)) {\n      specifier.local = this.parseIdentifier();\n    } else {\n      const { imported } = specifier;\n      if (importedIsString) {\n        throw this.raise(Errors.ImportBindingIsString, specifier, {\n          importName: (imported as N.StringLiteral).value,\n        });\n      }\n      this.checkReservedWord(\n        (imported as N.Identifier).name,\n        specifier.loc.start,\n        true,\n        true,\n      );\n      if (!specifier.local) {\n        specifier.local = cloneIdentifier(imported);\n      }\n    }\n    return this.finishImportSpecifier(\n      specifier,\n      \"ImportSpecifier\",\n      bindingType,\n    );\n  }\n\n  // This is used in flow and typescript plugin\n  // Determine whether a parameter is a this param\n  isThisParam(\n    param: N.Pattern | N.Identifier | N.TSParameterProperty,\n  ): boolean {\n    return param.type === \"Identifier\" && param.name === \"this\";\n  }\n}\n"],"mappings":"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","ignoreList":[]}