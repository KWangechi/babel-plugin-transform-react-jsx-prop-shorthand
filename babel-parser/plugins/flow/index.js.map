{"version":3,"names":["_types","require","_context","_identifier","_scope","_scopeflags","_parseError","_node","reservedTypes","Set","FlowErrors","ParseErrorEnum","AmbiguousConditionalArrow","AmbiguousDeclareModuleKind","AssignReservedType","reservedType","DeclareClassElement","DeclareClassFieldInitializer","DuplicateDeclareModuleExports","EnumBooleanMemberNotInitialized","memberName","enumName","EnumDuplicateMemberName","EnumInconsistentMemberValues","EnumInvalidExplicitType","invalidEnumType","EnumInvalidExplicitTypeUnknownSupplied","EnumInvalidMemberInitializerPrimaryType","explicitType","EnumInvalidMemberInitializerSymbolType","EnumInvalidMemberInitializerUnknownType","EnumInvalidMemberName","suggestion","EnumNumberMemberNotInitialized","EnumStringMemberInconsistentlyInitialized","GetterMayNotHaveThisParam","ImportReflectionHasImportType","ImportTypeShorthandOnlyInPureImport","InexactInsideExact","InexactInsideNonObject","InexactVariance","InvalidNonTypeImportInDeclareModule","MissingTypeParamDefault","NestedDeclareModule","NestedFlowComment","PatternIsOptional","Object","assign","message","process","env","BABEL_8_BREAKING","reasonCode","SetterMayNotHaveThisParam","SpreadVariance","ThisParamAnnotationRequired","ThisParamBannedInConstructor","ThisParamMayNotBeOptional","ThisParamMustBeFirst","ThisParamNoDefault","TypeBeforeInitializer","TypeCastInPattern","UnexpectedExplicitInexactInObject","UnexpectedReservedType","UnexpectedReservedUnderscore","UnexpectedSpaceBetweenModuloChecks","UnexpectedSpreadType","UnexpectedSubtractionOperand","UnexpectedTokenAfterTypeParameter","UnexpectedTypeParameterBeforeAsyncArrowFunction","UnsupportedDeclareExportKind","unsupportedExportKind","UnsupportedStatementInDeclareModule","UnterminatedFlowComment","isEsModuleType","bodyElement","type","declaration","hasTypeImportKind","node","importKind","exportSuggestions","const","let","interface","partition","list","test","list1","list2","i","length","push","FLOW_PRAGMA_REGEX","_default","superClass","FlowParserMixin","flowPragma","undefined","getScopeHandler","FlowScopeHandler","shouldParseTypes","getPluginOption","finishToken","val","addComment","comment","matches","exec","value","Error","flowParseTypeInitialiser","tok","oldInType","state","inType","expect","flowParseType","flowParsePredicate","startNode","moduloLoc","startLoc","next","expectContextual","lastTokStartLoc","index","raise","eat","parseExpression","finishNode","flowParseTypeAndPredicateInitialiser","predicate","match","flowParseDeclareClass","flowParseInterfaceish","flowParseDeclareFunction","id","parseIdentifier","typeNode","typeContainer","typeParameters","flowParseTypeParameterDeclaration","tmp","flowParseFunctionTypeParams","params","rest","this","_this","returnType","typeAnnotation","resetEndLocation","semicolon","scope","declareName","name","BindingFlag","TYPE_FLOW_DECLARE_FN","loc","start","flowParseDeclare","insideModule","flowParseDeclareVariable","eatContextual","flowParseDeclareModuleExports","flowParseDeclareModule","isContextual","flowParseDeclareTypeAlias","flowParseDeclareOpaqueType","flowParseDeclareInterface","flowParseDeclareExportDeclaration","unexpected","flowParseTypeAnnotatableIdentifier","TYPE_VAR","enter","ScopeFlag","OTHER","parseExprAtom","bodyNode","body","parseImport","exit","kind","hasModuleExport","forEach","default","isLet","label","parseExport","exportKind","flowParseTypeAnnotation","finished","flowParseTypeAlias","flowParseOpaqueType","isClass","flowParseRestrictedIdentifier","TYPE_FUNCTION","TYPE_LEXICAL","extends","flowParseInterfaceExtends","implements","mixins","flowParseObjectType","allowStatic","allowExact","allowSpread","allowProto","allowInexact","flowParseQualifiedTypeIdentifier","flowParseTypeParameterInstantiation","flowParseInterface","checkNotUnderscore","word","checkReservedType","has","liberal","right","declare","supertype","impltype","flowParseTypeParameter","requireDefault","nodeStartLoc","variance","flowParseVariance","ident","bound","defaultRequired","typeParameter","flowInTopLevelContext","cb","curContext","tc","brace","oldContext","context","flowParseTypeParameterInstantiationInExpression","reScan_lt","oldNoAnonFunctionType","noAnonFunctionType","reScan_lt_gt","flowParseTypeParameterInstantiationCallOrNew","flowParseTypeOrImplicitInstantiation","flowParseInterfaceType","flowParseObjectPropertyKey","flowParseObjectTypeIndexer","isStatic","static","lookahead","key","flowParseObjectTypeInternalSlot","method","optional","flowParseObjectTypeMethodish","startNodeAt","flowParseFunctionTypeParam","flowParseObjectTypeCallProperty","valueNode","nodeStart","callProperties","properties","indexers","internalSlots","endDelim","exact","inexact","protoStartLoc","inexactStartLoc","tokenIsLiteralPropertyName","propOrInexact","flowParseObjectTypeProperty","flowObjectTypeSemicolon","out","isInexactToken","argument","proto","flowCheckGetterSetterParams","property","paramCount","Errors","BadGetterArity","BadSetterArity","BadSetterRestParameter","node2","qualification","flowParseGenericType","flowParseTypeofType","flowParsePrimaryType","flowParseTupleType","types","pos","first","lh","isThis","reinterpretTypeAsFunctionTypeParam","flowIdentToTypeAnnotation","isGroupedType","tokenIsIdentifier","token","parseLiteral","parseLiteralAtNode","tokenIsKeyword","tokenLabelName","createIdentifier","flowParsePostfixType","seenOptionalIndexedAccess","canInsertSemicolon","elementType","objectType","indexType","flowParsePrefixType","flowParseAnonFunctionWithoutParens","param","flowParseIntersectionType","flowParseUnionType","allowPrimitiveOverride","typeCastToParameter","expression","end","parseFunctionBody","allowExpressionBody","isMethod","forwardNoArrowParamsConversionAt","parseFunctionBodyAndFinish","parseStatementLike","flags","strict","tokenIsKeywordOrIdentifier","flowParseEnumDeclaration","stmt","isValidDirective","parseExpressionStatement","expr","decorators","shouldParseExportDeclaration","tokenIsFlowInterfaceOrTypeOrOpaque","containsEsc","isExportDefaultSpecifier","parseExportDefaultExpression","parseConditional","refExpressionErrors","maybeInArrowParameters","nextCh","lookaheadCharCode","setOptionalParametersError","clone","originalNoArrowAt","noArrowAt","consequent","failed","tryParseConditionalConsequent","valid","invalid","getArrowLikeExpressions","alternate","parseMaybeAssign","noArrowParamsConversionAt","parseMaybeAssignAllowIn","pop","disallowInvalid","stack","arrows","finishArrowValidation","every","isAssignable","toAssignableList","extra","trailingCommaLoc","FUNCTION","ARROW","checkParams","parse","result","includes","offsetToSourcePos","parseParenItem","newNode","typeCastNode","assertModuleNodeAllowed","parseExportDeclaration","declarationNode","specifiers","parseExportSpecifiers","parseExportFrom","eatExportStar","maybeParseExportNamespaceSpecifier","hasNamespace","parseClassId","isStatement","optionalId","parseClassMember","classBody","member","parseClassMemberFromModifier","isIterator","readIterator","readWord1","fullWord","InvalidIdentifier","curPosition","identifierName","getTokenFromCode","code","input","charCodeAt","finishOp","isIteratorStart","isBinding","toAssignable","isLHS","left","exprList","toReferencedList","isParenthesizedExpr","parenthesized","parseArrayLike","close","canBePattern","isTuple","elements","isValidLVal","isParenthesized","binding","parseClassProperty","parseClassPrivateProperty","isClassMethod","isClassProperty","isNonstaticConstructor","pushClassMethod","isGenerator","isAsync","isConstructor","allowsDirectSuper","isThisParam","pushClassPrivateMethod","parseClassSuper","superTypeArguments","superTypeParameters","implemented","checkGetterSetterParams","getObjectOrClassMethodParams","parsePropertyNamePrefixOperator","parseObjPropValue","prop","isPattern","isAccessor","parseFunctionParamType","parseMaybeDefault","checkImportReflection","module","parseImportSpecifierLocal","specifier","local","finishImportSpecifier","isPotentialImportPhase","isExport","ch","applyImportPhase","phase","parseImportSpecifier","importedIsString","isInTypeOnlyImport","isMaybeTypeOnly","bindingType","firstIdent","imported","specifierTypeKind","isLookaheadContextual","as_ident","cloneIdentifier","ImportBindingIsString","importName","specifierIsTypeImport","checkReservedWord","parseBindingAtom","parseFunctionParams","parseVarId","decl","parseAsyncArrowFromCallExpression","call","shouldParseAsyncArrow","afterLeftParse","jsx","hasPlugin","tryParse","error","currentContext","j_oTag","j_expr","arrow","abort","arrowExpression","resetStartLocationFromNode","maybeUnwrapTypeCastExpression","aborted","async","failState","thrown","parseArrow","shouldParseArrow","setArrowFunctionParameters","allowDuplicates","isArrowFunction","strictModeChanged","parseParenAndDistinguishExpression","canBeArrow","sourceToOffsetPos","parseSubscripts","base","noCalls","callee","arguments","parseCallExpressionArguments","parseAsyncArrowWithTypeParameters","parseSubscript","subscriptState","isLookaheadToken_lt","optionalChainMember","stop","typeArguments","finishCallExpression","parseNewCallee","targs","parseArrowExpression","readToken_mult_modulo","hasFlowComment","nextToken","readToken_pipe_amp","parseTopLevel","file","program","fileNode","skipBlockComment","skipFlowComment","hasFlowCommentCompletion","commentSkip","shiftToFirstNonWhiteSpace","ch2","ch3","slice","indexOf","UnterminatedComment","flowEnumErrorBooleanMemberNotInitialized","flowEnumErrorInvalidMemberInitializer","enumContext","flowEnumErrorNumberMemberNotInitialized","details","flowEnumErrorStringMemberInconsistentlyInitialized","flowEnumMemberInit","endOfInit","literal","parseNumericLiteral","parseStringLiteral","parseBooleanLiteral","flowEnumMemberRaw","init","flowEnumCheckExplicitTypeMismatch","expectedType","flowEnumMembers","seenNames","members","booleanMembers","numberMembers","stringMembers","defaultedMembers","hasUnknownMembers","memberNode","toUpperCase","add","flowEnumStringMembers","initializedMembers","flowEnumParseExplicitType","flowEnumBody","nameLoc","empty","boolsLen","numsLen","strsLen","defaultedLen","jsxParseOpeningElementAfterName","nextTokenStart","afterNext","readToken_lt","readToken_gt","exports"],"sources":["../../../src/plugins/flow/index.ts"],"sourcesContent":["/*:: declare var invariant; */\n\nimport type Parser from \"../../parser/index.ts\";\nimport {\n  tokenIsIdentifier,\n  tokenIsKeyword,\n  tokenIsKeywordOrIdentifier,\n  tokenIsLiteralPropertyName,\n  tokenLabelName,\n  tt,\n  type TokenType,\n  tokenIsFlowInterfaceOrTypeOrOpaque,\n} from \"../../tokenizer/types.ts\";\nimport type * as N from \"../../types.ts\";\nimport type { Position } from \"../../util/location.ts\";\nimport { types as tc } from \"../../tokenizer/context.ts\";\nimport * as charCodes from \"charcodes\";\nimport { isIteratorStart } from \"../../util/identifier.ts\";\nimport FlowScopeHandler from \"./scope.ts\";\nimport { BindingFlag, ScopeFlag } from \"../../util/scopeflags.ts\";\nimport type { ExpressionErrors } from \"../../parser/util.ts\";\nimport type { ParseStatementFlag } from \"../../parser/statement.ts\";\nimport { Errors, ParseErrorEnum } from \"../../parse-error.ts\";\nimport { cloneIdentifier, type Undone } from \"../../parser/node.ts\";\nimport type { ClassWithMixin, IJSXParserMixin } from \"../jsx/index.ts\";\n\nconst reservedTypes = new Set([\n  \"_\",\n  \"any\",\n  \"bool\",\n  \"boolean\",\n  \"empty\",\n  \"extends\",\n  \"false\",\n  \"interface\",\n  \"mixed\",\n  \"null\",\n  \"number\",\n  \"static\",\n  \"string\",\n  \"true\",\n  \"typeof\",\n  \"void\",\n]);\n\n/* eslint sort-keys: \"error\" */\n// The Errors key follows https://github.com/facebook/flow/blob/master/src/parser/parse_error.ml unless it does not exist\nconst FlowErrors = ParseErrorEnum`flow`({\n  AmbiguousConditionalArrow:\n    \"Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.\",\n  AmbiguousDeclareModuleKind:\n    \"Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.\",\n  // TODO: When we get proper string enums in typescript make this ReservedType.\n  // Not really worth it to do the whole $Values dance with reservedTypes set.\n  AssignReservedType: ({ reservedType }: { reservedType: string }) =>\n    `Cannot overwrite reserved type ${reservedType}.`,\n  DeclareClassElement:\n    \"The `declare` modifier can only appear on class fields.\",\n  DeclareClassFieldInitializer:\n    \"Initializers are not allowed in fields with the `declare` modifier.\",\n  DuplicateDeclareModuleExports:\n    \"Duplicate `declare module.exports` statement.\",\n  EnumBooleanMemberNotInitialized: ({\n    memberName,\n    enumName,\n  }: {\n    memberName: string;\n    enumName: string;\n  }) =>\n    `Boolean enum members need to be initialized. Use either \\`${memberName} = true,\\` or \\`${memberName} = false,\\` in enum \\`${enumName}\\`.`,\n  EnumDuplicateMemberName: ({\n    memberName,\n    enumName,\n  }: {\n    memberName: string;\n    enumName: string;\n  }) =>\n    `Enum member names need to be unique, but the name \\`${memberName}\\` has already been used before in enum \\`${enumName}\\`.`,\n  EnumInconsistentMemberValues: ({ enumName }: { enumName: string }) =>\n    `Enum \\`${enumName}\\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,\n  EnumInvalidExplicitType: ({\n    invalidEnumType,\n    enumName,\n  }: {\n    invalidEnumType: string;\n    enumName: string;\n  }) =>\n    `Enum type \\`${invalidEnumType}\\` is not valid. Use one of \\`boolean\\`, \\`number\\`, \\`string\\`, or \\`symbol\\` in enum \\`${enumName}\\`.`,\n  EnumInvalidExplicitTypeUnknownSupplied: ({\n    enumName,\n  }: {\n    enumName: string;\n  }) =>\n    `Supplied enum type is not valid. Use one of \\`boolean\\`, \\`number\\`, \\`string\\`, or \\`symbol\\` in enum \\`${enumName}\\`.`,\n\n  // TODO: When moving to typescript, we should either have each of the\n  // following errors only accept the specific strings they want:\n  //\n  // ...PrimaryType: explicitType: \"string\" | \"number\" | \"boolean\"\n  // ...SymbolType: explicitType: \"symbol\"\n  // ...UnknownType: explicitType: null\n  //\n  // Or, alternatively, merge these three errors together into one\n  // `EnumInvalidMemberInitializer` error that can accept `EnumExplicitType`\n  // without alteration, and then just have its message change based on the\n  // explicitType.\n  EnumInvalidMemberInitializerPrimaryType: ({\n    enumName,\n    memberName,\n    explicitType,\n  }: {\n    enumName: string;\n    memberName: string;\n    explicitType: EnumExplicitType;\n  }) =>\n    `Enum \\`${enumName}\\` has type \\`${explicitType}\\`, so the initializer of \\`${memberName}\\` needs to be a ${explicitType} literal.`,\n  EnumInvalidMemberInitializerSymbolType: ({\n    enumName,\n    memberName,\n  }: {\n    enumName: string;\n    memberName: string;\n    explicitType: EnumExplicitType;\n  }) =>\n    `Symbol enum members cannot be initialized. Use \\`${memberName},\\` in enum \\`${enumName}\\`.`,\n  EnumInvalidMemberInitializerUnknownType: ({\n    enumName,\n    memberName,\n  }: {\n    enumName: string;\n    memberName: string;\n    explicitType: EnumExplicitType;\n  }) =>\n    `The enum member initializer for \\`${memberName}\\` needs to be a literal (either a boolean, number, or string) in enum \\`${enumName}\\`.`,\n  EnumInvalidMemberName: ({\n    enumName,\n    memberName,\n    suggestion,\n  }: {\n    enumName: string;\n    memberName: string;\n    suggestion: string;\n  }) =>\n    `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \\`${memberName}\\`, consider using \\`${suggestion}\\`, in enum \\`${enumName}\\`.`,\n  EnumNumberMemberNotInitialized: ({\n    enumName,\n    memberName,\n  }: {\n    enumName: string;\n    memberName: string;\n  }) =>\n    `Number enum members need to be initialized, e.g. \\`${memberName} = 1\\` in enum \\`${enumName}\\`.`,\n  EnumStringMemberInconsistentlyInitialized: ({\n    enumName,\n  }: {\n    enumName: string;\n  }) =>\n    `String enum members need to consistently either all use initializers, or use no initializers, in enum \\`${enumName}\\`.`,\n  GetterMayNotHaveThisParam: \"A getter cannot have a `this` parameter.\",\n  ImportReflectionHasImportType:\n    \"An `import module` declaration can not use `type` or `typeof` keyword.\",\n  ImportTypeShorthandOnlyInPureImport:\n    \"The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.\",\n  InexactInsideExact:\n    \"Explicit inexact syntax cannot appear inside an explicit exact object type.\",\n  InexactInsideNonObject:\n    \"Explicit inexact syntax cannot appear in class or interface definitions.\",\n  InexactVariance: \"Explicit inexact syntax cannot have variance.\",\n  InvalidNonTypeImportInDeclareModule:\n    \"Imports within a `declare module` body must always be `import type` or `import typeof`.\",\n  MissingTypeParamDefault:\n    \"Type parameter declaration needs a default, since a preceding type parameter declaration has a default.\",\n  NestedDeclareModule:\n    \"`declare module` cannot be used inside another `declare module`.\",\n  NestedFlowComment: \"Cannot have a flow comment inside another flow comment.\",\n  PatternIsOptional: {\n    message:\n      \"A binding pattern parameter cannot be optional in an implementation signature.\",\n    // For consistency in TypeScript and Flow error codes\n    ...(!process.env.BABEL_8_BREAKING\n      ? { reasonCode: \"OptionalBindingPattern\" }\n      : {}),\n  },\n  SetterMayNotHaveThisParam: \"A setter cannot have a `this` parameter.\",\n  SpreadVariance: \"Spread properties cannot have variance.\",\n  ThisParamAnnotationRequired:\n    \"A type annotation is required for the `this` parameter.\",\n  ThisParamBannedInConstructor:\n    \"Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.\",\n  ThisParamMayNotBeOptional: \"The `this` parameter cannot be optional.\",\n  ThisParamMustBeFirst:\n    \"The `this` parameter must be the first function parameter.\",\n  ThisParamNoDefault: \"The `this` parameter may not have a default value.\",\n  TypeBeforeInitializer:\n    \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.\",\n  TypeCastInPattern:\n    \"The type cast expression is expected to be wrapped with parenthesis.\",\n  UnexpectedExplicitInexactInObject:\n    \"Explicit inexact syntax must appear at the end of an inexact object.\",\n  UnexpectedReservedType: ({ reservedType }: { reservedType: string }) =>\n    `Unexpected reserved type ${reservedType}.`,\n  UnexpectedReservedUnderscore:\n    \"`_` is only allowed as a type argument to call or new.\",\n  UnexpectedSpaceBetweenModuloChecks:\n    \"Spaces between `%` and `checks` are not allowed here.\",\n  UnexpectedSpreadType:\n    \"Spread operator cannot appear in class or interface definitions.\",\n  UnexpectedSubtractionOperand:\n    'Unexpected token, expected \"number\" or \"bigint\".',\n  UnexpectedTokenAfterTypeParameter:\n    \"Expected an arrow function after this type parameter declaration.\",\n  UnexpectedTypeParameterBeforeAsyncArrowFunction:\n    \"Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.\",\n  UnsupportedDeclareExportKind: ({\n    unsupportedExportKind,\n    suggestion,\n  }: {\n    unsupportedExportKind: string;\n    suggestion: string;\n  }) =>\n    `\\`declare export ${unsupportedExportKind}\\` is not supported. Use \\`${suggestion}\\` instead.`,\n  UnsupportedStatementInDeclareModule:\n    \"Only declares and type imports are allowed inside declare module.\",\n  UnterminatedFlowComment: \"Unterminated flow-comment.\",\n});\n/* eslint-disable sort-keys */\n\nfunction isEsModuleType(bodyElement: N.Node): boolean {\n  return (\n    bodyElement.type === \"DeclareExportAllDeclaration\" ||\n    (bodyElement.type === \"DeclareExportDeclaration\" &&\n      (!bodyElement.declaration ||\n        (bodyElement.declaration.type !== \"TypeAlias\" &&\n          bodyElement.declaration.type !== \"InterfaceDeclaration\")))\n  );\n}\n\nfunction hasTypeImportKind(\n  node: Undone<N.ImportSpecifier | N.ImportDeclaration>,\n): boolean {\n  return node.importKind === \"type\" || node.importKind === \"typeof\";\n}\n\nconst exportSuggestions = {\n  const: \"declare export var\",\n  let: \"declare export var\",\n  type: \"export type\",\n  interface: \"export interface\",\n};\n\n// Like Array#filter, but returns a tuple [ acceptedElements, discardedElements ]\nfunction partition<T>(\n  list: T[],\n  test: (c: T, b: number, a: T[]) => boolean | undefined | null,\n): [T[], T[]] {\n  const list1: T[] = [];\n  const list2: T[] = [];\n  for (let i = 0; i < list.length; i++) {\n    (test(list[i], i, list) ? list1 : list2).push(list[i]);\n  }\n  return [list1, list2];\n}\n\nconst FLOW_PRAGMA_REGEX = /\\*?\\s*@((?:no)?flow)\\b/;\n\n// Flow enums types\ntype EnumExplicitType = null | \"boolean\" | \"number\" | \"string\" | \"symbol\";\n\ntype EnumContext = {\n  enumName: string;\n  explicitType: EnumExplicitType;\n  memberName: string;\n};\n\ntype EnumMemberInit =\n  | {\n      type: \"number\";\n      loc: Position;\n      value: N.Node;\n    }\n  | {\n      type: \"string\";\n      loc: Position;\n      value: N.Node;\n    }\n  | {\n      type: \"boolean\";\n      loc: Position;\n      value: N.Node;\n    }\n  | {\n      type: \"invalid\";\n      loc: Position;\n    }\n  | {\n      type: \"none\";\n      loc: Position;\n    };\n\nexport default (superClass: ClassWithMixin<typeof Parser, IJSXParserMixin>) =>\n  class FlowParserMixin extends superClass implements Parser {\n    // The value of the @flow/@noflow pragma. Initially undefined, transitions\n    // to \"@flow\" or \"@noflow\" if we see a pragma. Transitions to null if we are\n    // past the initial comment.\n    flowPragma: void | null | \"flow\" | \"noflow\" = undefined;\n\n    getScopeHandler(): new (...args: any) => FlowScopeHandler {\n      return FlowScopeHandler;\n    }\n\n    shouldParseTypes(): boolean {\n      return this.getPluginOption(\"flow\", \"all\") || this.flowPragma === \"flow\";\n    }\n\n    finishToken(type: TokenType, val: any): void {\n      if (\n        type !== tt.string &&\n        type !== tt.semi &&\n        type !== tt.interpreterDirective\n      ) {\n        if (this.flowPragma === undefined) {\n          this.flowPragma = null;\n        }\n      }\n      super.finishToken(type, val);\n    }\n\n    addComment(comment: N.Comment): void {\n      if (this.flowPragma === undefined) {\n        // Try to parse a flow pragma.\n        const matches = FLOW_PRAGMA_REGEX.exec(comment.value);\n        if (!matches) {\n          // do nothing\n        } else if (matches[1] === \"flow\") {\n          this.flowPragma = \"flow\";\n        } else if (matches[1] === \"noflow\") {\n          this.flowPragma = \"noflow\";\n        } else {\n          throw new Error(\"Unexpected flow pragma\");\n        }\n      }\n      super.addComment(comment);\n    }\n\n    flowParseTypeInitialiser(tok?: TokenType): N.FlowType {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n      this.expect(tok || tt.colon);\n\n      const type = this.flowParseType();\n      this.state.inType = oldInType;\n      return type;\n    }\n\n    flowParsePredicate(): N.FlowPredicate {\n      const node = this.startNode<N.FlowPredicate>();\n      const moduloLoc = this.state.startLoc;\n      this.next(); // eat `%`\n      this.expectContextual(tt._checks);\n      // Force '%' and 'checks' to be adjacent\n      if (this.state.lastTokStartLoc.index > moduloLoc.index + 1) {\n        this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, moduloLoc);\n      }\n      if (this.eat(tt.parenL)) {\n        node.value = super.parseExpression();\n        this.expect(tt.parenR);\n        return this.finishNode(node, \"DeclaredPredicate\");\n      } else {\n        return this.finishNode(node, \"InferredPredicate\");\n      }\n    }\n\n    flowParseTypeAndPredicateInitialiser(): [\n      N.FlowType | undefined | null,\n      N.FlowPredicate | undefined | null,\n    ] {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n      this.expect(tt.colon);\n      let type = null;\n      let predicate = null;\n      if (this.match(tt.modulo)) {\n        this.state.inType = oldInType;\n        predicate = this.flowParsePredicate();\n      } else {\n        type = this.flowParseType();\n        this.state.inType = oldInType;\n        if (this.match(tt.modulo)) {\n          predicate = this.flowParsePredicate();\n        }\n      }\n      return [type, predicate];\n    }\n\n    flowParseDeclareClass(\n      node: Undone<N.FlowDeclareClass>,\n    ): N.FlowDeclareClass {\n      this.next();\n      this.flowParseInterfaceish(node, /*isClass*/ true);\n      return this.finishNode(node, \"DeclareClass\");\n    }\n\n    flowParseDeclareFunction(\n      node: Undone<N.FlowDeclareFunction>,\n    ): N.FlowDeclareFunction {\n      this.next();\n\n      const id = (node.id = this.parseIdentifier());\n\n      const typeNode = this.startNode<N.FlowFunctionTypeAnnotation>();\n      const typeContainer = this.startNode<N.TypeAnnotation>();\n\n      if (this.match(tt.lt)) {\n        typeNode.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        typeNode.typeParameters = null;\n      }\n\n      this.expect(tt.parenL);\n      const tmp = this.flowParseFunctionTypeParams();\n      typeNode.params = tmp.params;\n      typeNode.rest = tmp.rest;\n      typeNode.this = tmp._this;\n      this.expect(tt.parenR);\n\n      [typeNode.returnType, node.predicate] =\n        this.flowParseTypeAndPredicateInitialiser();\n\n      typeContainer.typeAnnotation = this.finishNode(\n        typeNode,\n        \"FunctionTypeAnnotation\",\n      );\n\n      id.typeAnnotation = this.finishNode(typeContainer, \"TypeAnnotation\");\n\n      this.resetEndLocation(id);\n      this.semicolon();\n\n      this.scope.declareName(\n        node.id.name,\n        BindingFlag.TYPE_FLOW_DECLARE_FN,\n        node.id.loc.start,\n      );\n\n      return this.finishNode(node, \"DeclareFunction\");\n    }\n\n    flowParseDeclare(\n      node: Undone<N.FlowDeclare>,\n      insideModule?: boolean,\n    ): N.FlowDeclare {\n      if (this.match(tt._class)) {\n        return this.flowParseDeclareClass(node);\n      } else if (this.match(tt._function)) {\n        return this.flowParseDeclareFunction(node);\n      } else if (this.match(tt._var)) {\n        return this.flowParseDeclareVariable(node);\n      } else if (this.eatContextual(tt._module)) {\n        if (this.match(tt.dot)) {\n          return this.flowParseDeclareModuleExports(node);\n        } else {\n          if (insideModule) {\n            this.raise(\n              FlowErrors.NestedDeclareModule,\n              this.state.lastTokStartLoc,\n            );\n          }\n          return this.flowParseDeclareModule(node);\n        }\n      } else if (this.isContextual(tt._type)) {\n        return this.flowParseDeclareTypeAlias(node);\n      } else if (this.isContextual(tt._opaque)) {\n        return this.flowParseDeclareOpaqueType(node);\n      } else if (this.isContextual(tt._interface)) {\n        return this.flowParseDeclareInterface(node);\n      } else if (this.match(tt._export)) {\n        return this.flowParseDeclareExportDeclaration(node, insideModule);\n      } else {\n        this.unexpected();\n      }\n    }\n\n    flowParseDeclareVariable(\n      node: Undone<N.FlowDeclareVariable>,\n    ): N.FlowDeclareVariable {\n      this.next();\n      node.id = this.flowParseTypeAnnotatableIdentifier(\n        /*allowPrimitiveOverride*/ true,\n      );\n      this.scope.declareName(\n        node.id.name,\n        BindingFlag.TYPE_VAR,\n        node.id.loc.start,\n      );\n      this.semicolon();\n      return this.finishNode(node, \"DeclareVariable\");\n    }\n\n    flowParseDeclareModule(\n      node: Undone<N.FlowDeclareModule>,\n    ): N.FlowDeclareModule {\n      this.scope.enter(ScopeFlag.OTHER);\n\n      if (this.match(tt.string)) {\n        node.id = super.parseExprAtom();\n      } else {\n        node.id = this.parseIdentifier();\n      }\n\n      const bodyNode = (node.body = this.startNode<N.BlockStatement>());\n      // @ts-expect-error refine typings\n      const body = (bodyNode.body = []);\n      this.expect(tt.braceL);\n      while (!this.match(tt.braceR)) {\n        let bodyNode = this.startNode<N.ImportDeclaration>();\n\n        if (this.match(tt._import)) {\n          this.next();\n          if (!this.isContextual(tt._type) && !this.match(tt._typeof)) {\n            this.raise(\n              FlowErrors.InvalidNonTypeImportInDeclareModule,\n              this.state.lastTokStartLoc,\n            );\n          }\n          super.parseImport(bodyNode);\n        } else {\n          this.expectContextual(\n            tt._declare,\n            FlowErrors.UnsupportedStatementInDeclareModule,\n          );\n          // @ts-expect-error refine typings\n          bodyNode = this.flowParseDeclare(bodyNode, true);\n        }\n\n        body.push(bodyNode);\n      }\n\n      this.scope.exit();\n\n      this.expect(tt.braceR);\n\n      this.finishNode(bodyNode, \"BlockStatement\");\n\n      let kind: \"CommonJS\" | \"ES\" | null = null;\n      let hasModuleExport = false;\n      body.forEach(bodyElement => {\n        if (isEsModuleType(bodyElement)) {\n          if (kind === \"CommonJS\") {\n            this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);\n          }\n          kind = \"ES\";\n        } else if (bodyElement.type === \"DeclareModuleExports\") {\n          if (hasModuleExport) {\n            this.raise(FlowErrors.DuplicateDeclareModuleExports, bodyElement);\n          }\n          if (kind === \"ES\") {\n            this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);\n          }\n          kind = \"CommonJS\";\n          hasModuleExport = true;\n        }\n      });\n\n      node.kind = kind || \"CommonJS\";\n      return this.finishNode(node, \"DeclareModule\");\n    }\n\n    flowParseDeclareExportDeclaration(\n      node: Undone<N.FlowDeclareExportDeclaration>,\n      insideModule?: boolean | null,\n    ): N.FlowDeclareExportDeclaration {\n      this.expect(tt._export);\n\n      if (this.eat(tt._default)) {\n        if (this.match(tt._function) || this.match(tt._class)) {\n          // declare export default class ...\n          // declare export default function ...\n          node.declaration = this.flowParseDeclare(this.startNode());\n        } else {\n          // declare export default [type];\n          node.declaration = this.flowParseType();\n          this.semicolon();\n        }\n        node.default = true;\n\n        return this.finishNode(node, \"DeclareExportDeclaration\");\n      } else {\n        if (\n          this.match(tt._const) ||\n          this.isLet() ||\n          ((this.isContextual(tt._type) || this.isContextual(tt._interface)) &&\n            !insideModule)\n        ) {\n          const label = this.state.value as\n            | \"const\"\n            | \"let\"\n            | \"type\"\n            | \"interface\";\n          throw this.raise(\n            FlowErrors.UnsupportedDeclareExportKind,\n            this.state.startLoc,\n            {\n              unsupportedExportKind: label,\n              suggestion: exportSuggestions[label],\n            },\n          );\n        }\n\n        if (\n          this.match(tt._var) || // declare export var ...\n          this.match(tt._function) || // declare export function ...\n          this.match(tt._class) || // declare export class ...\n          this.isContextual(tt._opaque) // declare export opaque ..\n        ) {\n          node.declaration = this.flowParseDeclare(this.startNode());\n          node.default = false;\n\n          return this.finishNode(node, \"DeclareExportDeclaration\");\n        } else if (\n          this.match(tt.star) || // declare export * from ''\n          this.match(tt.braceL) || // declare export {} ...\n          this.isContextual(tt._interface) || // declare export interface ...\n          this.isContextual(tt._type) || // declare export type ...\n          this.isContextual(tt._opaque) // declare export opaque type ...\n        ) {\n          node = this.parseExport(\n            node as Undone<N.ExportNamedDeclaration | N.ExportAllDeclaration>,\n            /* decorators */ null,\n          );\n          if (node.type === \"ExportNamedDeclaration\") {\n            node.type = \"ExportDeclaration\";\n            node.default = false;\n            delete node.exportKind;\n          }\n\n          node.type = \"Declare\" + node.type;\n\n          return node as N.FlowDeclareExportDeclaration;\n        }\n      }\n\n      this.unexpected();\n    }\n\n    flowParseDeclareModuleExports(\n      node: Undone<N.FlowDeclareModuleExports>,\n    ): N.FlowDeclareModuleExports {\n      this.next();\n      this.expectContextual(tt._exports);\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n      this.semicolon();\n\n      return this.finishNode(node, \"DeclareModuleExports\");\n    }\n\n    flowParseDeclareTypeAlias(\n      node: Undone<N.FlowDeclareTypeAlias>,\n    ): N.FlowDeclareTypeAlias {\n      this.next();\n      const finished = this.flowParseTypeAlias(\n        node,\n      ) as unknown as N.FlowDeclareTypeAlias;\n      // Don't do finishNode as we don't want to process comments twice\n      finished.type = \"DeclareTypeAlias\";\n      return finished;\n    }\n\n    flowParseDeclareOpaqueType(\n      node: Undone<N.FlowDeclareOpaqueType>,\n    ): N.FlowDeclareOpaqueType {\n      this.next();\n      const finished = this.flowParseOpaqueType(\n        node,\n        true,\n      ) as unknown as N.FlowDeclareOpaqueType;\n      // Don't do finishNode as we don't want to process comments twice\n      finished.type = \"DeclareOpaqueType\";\n      return finished;\n    }\n\n    flowParseDeclareInterface(\n      node: Undone<N.FlowDeclareInterface>,\n    ): N.FlowDeclareInterface {\n      this.next();\n      this.flowParseInterfaceish(node, /* isClass */ false);\n      return this.finishNode(node, \"DeclareInterface\");\n    }\n\n    // Interfaces\n\n    flowParseInterfaceish(node: Undone<N.FlowDeclare>, isClass: boolean): void {\n      node.id = this.flowParseRestrictedIdentifier(\n        /* liberal */ !isClass,\n        /* declaration */ true,\n      );\n\n      this.scope.declareName(\n        node.id.name,\n        isClass ? BindingFlag.TYPE_FUNCTION : BindingFlag.TYPE_LEXICAL,\n        node.id.loc.start,\n      );\n\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        node.typeParameters = null;\n      }\n\n      node.extends = [];\n\n      if (this.eat(tt._extends)) {\n        do {\n          node.extends.push(this.flowParseInterfaceExtends());\n        } while (!isClass && this.eat(tt.comma));\n      }\n\n      if (isClass) {\n        node.implements = [];\n        node.mixins = [];\n\n        if (this.eatContextual(tt._mixins)) {\n          do {\n            node.mixins.push(this.flowParseInterfaceExtends());\n          } while (this.eat(tt.comma));\n        }\n\n        if (this.eatContextual(tt._implements)) {\n          do {\n            node.implements.push(this.flowParseInterfaceExtends());\n          } while (this.eat(tt.comma));\n        }\n      }\n\n      node.body = this.flowParseObjectType({\n        allowStatic: isClass,\n        allowExact: false,\n        allowSpread: false,\n        allowProto: isClass,\n        allowInexact: false,\n      });\n    }\n\n    flowParseInterfaceExtends(): N.FlowInterfaceExtends {\n      const node = this.startNode<N.FlowInterfaceExtends>();\n\n      node.id = this.flowParseQualifiedTypeIdentifier();\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterInstantiation();\n      } else {\n        node.typeParameters = null;\n      }\n\n      return this.finishNode(node, \"InterfaceExtends\");\n    }\n\n    flowParseInterface(node: Undone<N.FlowInterface>): N.FlowInterface {\n      this.flowParseInterfaceish(node, /* isClass */ false);\n      return this.finishNode(node, \"InterfaceDeclaration\");\n    }\n\n    checkNotUnderscore(word: string) {\n      if (word === \"_\") {\n        this.raise(\n          FlowErrors.UnexpectedReservedUnderscore,\n          this.state.startLoc,\n        );\n      }\n    }\n\n    checkReservedType(word: string, startLoc: Position, declaration?: boolean) {\n      if (!reservedTypes.has(word)) return;\n\n      this.raise(\n        declaration\n          ? FlowErrors.AssignReservedType\n          : FlowErrors.UnexpectedReservedType,\n        startLoc,\n        {\n          reservedType: word,\n        },\n      );\n    }\n\n    flowParseRestrictedIdentifier(\n      liberal?: boolean,\n      declaration?: boolean,\n    ): N.Identifier {\n      this.checkReservedType(\n        this.state.value,\n        this.state.startLoc,\n        declaration,\n      );\n      return this.parseIdentifier(liberal);\n    }\n\n    // Type aliases\n\n    flowParseTypeAlias(node: Undone<N.FlowTypeAlias>): N.FlowTypeAlias {\n      node.id = this.flowParseRestrictedIdentifier(\n        /* liberal */ false,\n        /* declaration */ true,\n      );\n      this.scope.declareName(\n        node.id.name,\n        BindingFlag.TYPE_LEXICAL,\n        node.id.loc.start,\n      );\n\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        node.typeParameters = null;\n      }\n\n      node.right = this.flowParseTypeInitialiser(tt.eq);\n      this.semicolon();\n\n      return this.finishNode(node, \"TypeAlias\");\n    }\n\n    flowParseOpaqueType(\n      node: Undone<N.FlowOpaqueType>,\n      declare: boolean,\n    ): N.FlowOpaqueType {\n      this.expectContextual(tt._type);\n      node.id = this.flowParseRestrictedIdentifier(\n        /* liberal */ true,\n        /* declaration */ true,\n      );\n      this.scope.declareName(\n        node.id.name,\n        BindingFlag.TYPE_LEXICAL,\n        node.id.loc.start,\n      );\n\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        node.typeParameters = null;\n      }\n\n      // Parse the supertype\n      node.supertype = null;\n      if (this.match(tt.colon)) {\n        node.supertype = this.flowParseTypeInitialiser(tt.colon);\n      }\n\n      node.impltype = null;\n      if (!declare) {\n        node.impltype = this.flowParseTypeInitialiser(tt.eq);\n      }\n      this.semicolon();\n\n      return this.finishNode(node, \"OpaqueType\");\n    }\n\n    // Type annotations\n\n    flowParseTypeParameter(requireDefault: boolean = false): N.TypeParameter {\n      const nodeStartLoc = this.state.startLoc;\n\n      const node = this.startNode<N.TypeParameter>();\n\n      const variance = this.flowParseVariance();\n\n      const ident = this.flowParseTypeAnnotatableIdentifier();\n      node.name = ident.name;\n      // @ts-expect-error migrate to Babel types\n      node.variance = variance;\n      // @ts-expect-error migrate to Babel types\n      node.bound = ident.typeAnnotation;\n\n      if (this.match(tt.eq)) {\n        this.eat(tt.eq);\n        // @ts-expect-error migrate to Babel types\n        node.default = this.flowParseType();\n      } else {\n        if (requireDefault) {\n          this.raise(FlowErrors.MissingTypeParamDefault, nodeStartLoc);\n        }\n      }\n\n      return this.finishNode(node, \"TypeParameter\");\n    }\n\n    flowParseTypeParameterDeclaration(): N.TypeParameterDeclaration {\n      const oldInType = this.state.inType;\n      const node = this.startNode<N.TypeParameterDeclaration>();\n      node.params = [];\n\n      this.state.inType = true;\n\n      // istanbul ignore else: this condition is already checked at all call sites\n      if (this.match(tt.lt) || this.match(tt.jsxTagStart)) {\n        this.next();\n      } else {\n        this.unexpected();\n      }\n\n      let defaultRequired = false;\n\n      do {\n        const typeParameter = this.flowParseTypeParameter(defaultRequired);\n\n        node.params.push(typeParameter);\n\n        if (typeParameter.default) {\n          defaultRequired = true;\n        }\n\n        if (!this.match(tt.gt)) {\n          this.expect(tt.comma);\n        }\n      } while (!this.match(tt.gt));\n      this.expect(tt.gt);\n\n      this.state.inType = oldInType;\n\n      return this.finishNode(node, \"TypeParameterDeclaration\");\n    }\n\n    // Parse in top level normal context if we are in a JSX context\n    flowInTopLevelContext<T>(cb: () => T): T {\n      if (this.curContext() !== tc.brace) {\n        const oldContext = this.state.context;\n        this.state.context = [oldContext[0]];\n        try {\n          return cb();\n        } finally {\n          this.state.context = oldContext;\n        }\n      } else {\n        return cb();\n      }\n    }\n\n    // Used when parsing type arguments from ES or JSX productions, where the first token\n    // has been created without state.inType. Thus we need to re-scan the lt token.\n    flowParseTypeParameterInstantiationInExpression():\n      | N.TypeParameterInstantiation\n      | undefined {\n      if (this.reScan_lt() !== tt.lt) return;\n      return this.flowParseTypeParameterInstantiation();\n    }\n\n    flowParseTypeParameterInstantiation(): N.TypeParameterInstantiation {\n      const node = this.startNode<N.TypeParameterInstantiation>();\n      const oldInType = this.state.inType;\n\n      this.state.inType = true;\n      node.params = [];\n      this.flowInTopLevelContext(() => {\n        this.expect(tt.lt);\n        const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n        this.state.noAnonFunctionType = false;\n        while (!this.match(tt.gt)) {\n          node.params.push(this.flowParseType());\n          if (!this.match(tt.gt)) {\n            this.expect(tt.comma);\n          }\n        }\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n      });\n\n      this.state.inType = oldInType;\n      if (!this.state.inType && this.curContext() === tc.brace) {\n        // rescan `>` when we are no longer in type context and JSX parsing context\n        // since it was tokenized when `inType` is `true`.\n        this.reScan_lt_gt();\n      }\n      this.expect(tt.gt);\n\n      return this.finishNode(node, \"TypeParameterInstantiation\");\n    }\n\n    flowParseTypeParameterInstantiationCallOrNew(): N.TypeParameterInstantiation {\n      if (this.reScan_lt() !== tt.lt) return;\n      const node = this.startNode<N.TypeParameterInstantiation>();\n      const oldInType = this.state.inType;\n      node.params = [];\n\n      this.state.inType = true;\n\n      this.expect(tt.lt);\n      while (!this.match(tt.gt)) {\n        node.params.push(this.flowParseTypeOrImplicitInstantiation());\n        if (!this.match(tt.gt)) {\n          this.expect(tt.comma);\n        }\n      }\n      this.expect(tt.gt);\n\n      this.state.inType = oldInType;\n\n      return this.finishNode(node, \"TypeParameterInstantiation\");\n    }\n\n    flowParseInterfaceType(): N.FlowInterfaceType {\n      const node = this.startNode<N.FlowInterfaceType>();\n      this.expectContextual(tt._interface);\n\n      node.extends = [];\n      if (this.eat(tt._extends)) {\n        do {\n          node.extends.push(this.flowParseInterfaceExtends());\n        } while (this.eat(tt.comma));\n      }\n\n      node.body = this.flowParseObjectType({\n        allowStatic: false,\n        allowExact: false,\n        allowSpread: false,\n        allowProto: false,\n        allowInexact: false,\n      });\n\n      return this.finishNode(node, \"InterfaceTypeAnnotation\");\n    }\n\n    flowParseObjectPropertyKey(): N.Expression {\n      return this.match(tt.num) || this.match(tt.string)\n        ? super.parseExprAtom()\n        : this.parseIdentifier(true);\n    }\n\n    flowParseObjectTypeIndexer(\n      node: Undone<N.FlowObjectTypeIndexer>,\n      isStatic: boolean,\n      variance?: N.FlowVariance | null,\n    ): N.FlowObjectTypeIndexer {\n      node.static = isStatic;\n\n      // Note: bracketL has already been consumed\n      if (this.lookahead().type === tt.colon) {\n        node.id = this.flowParseObjectPropertyKey();\n        node.key = this.flowParseTypeInitialiser();\n      } else {\n        node.id = null;\n        node.key = this.flowParseType();\n      }\n      this.expect(tt.bracketR);\n      node.value = this.flowParseTypeInitialiser();\n      node.variance = variance;\n\n      return this.finishNode(node, \"ObjectTypeIndexer\");\n    }\n\n    flowParseObjectTypeInternalSlot(\n      node: Undone<N.FlowObjectTypeInternalSlot>,\n      isStatic: boolean,\n    ): N.FlowObjectTypeInternalSlot {\n      node.static = isStatic;\n      // Note: both bracketL have already been consumed\n      node.id = this.flowParseObjectPropertyKey();\n      this.expect(tt.bracketR);\n      this.expect(tt.bracketR);\n      if (this.match(tt.lt) || this.match(tt.parenL)) {\n        node.method = true;\n        node.optional = false;\n        node.value = this.flowParseObjectTypeMethodish(\n          this.startNodeAt(node.loc.start),\n        );\n      } else {\n        node.method = false;\n        if (this.eat(tt.question)) {\n          node.optional = true;\n        }\n        node.value = this.flowParseTypeInitialiser();\n      }\n      return this.finishNode(node, \"ObjectTypeInternalSlot\");\n    }\n\n    flowParseObjectTypeMethodish(\n      node: Undone<N.FlowFunctionTypeAnnotation>,\n    ): N.FlowFunctionTypeAnnotation {\n      node.params = [];\n      node.rest = null;\n      node.typeParameters = null;\n      node.this = null;\n\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n\n      this.expect(tt.parenL);\n      if (this.match(tt._this)) {\n        node.this = this.flowParseFunctionTypeParam(/* first */ true);\n        // match Flow parser behavior\n        node.this.name = null;\n        if (!this.match(tt.parenR)) {\n          this.expect(tt.comma);\n        }\n      }\n      while (!this.match(tt.parenR) && !this.match(tt.ellipsis)) {\n        node.params.push(this.flowParseFunctionTypeParam(false));\n        if (!this.match(tt.parenR)) {\n          this.expect(tt.comma);\n        }\n      }\n\n      if (this.eat(tt.ellipsis)) {\n        node.rest = this.flowParseFunctionTypeParam(false);\n      }\n      this.expect(tt.parenR);\n      node.returnType = this.flowParseTypeInitialiser();\n\n      return this.finishNode(node, \"FunctionTypeAnnotation\");\n    }\n\n    flowParseObjectTypeCallProperty(\n      node: Undone<N.FlowObjectTypeCallProperty>,\n      isStatic: boolean,\n    ): N.FlowObjectTypeCallProperty {\n      const valueNode = this.startNode();\n      node.static = isStatic;\n      node.value = this.flowParseObjectTypeMethodish(valueNode);\n      return this.finishNode(node, \"ObjectTypeCallProperty\");\n    }\n\n    flowParseObjectType({\n      allowStatic,\n      allowExact,\n      allowSpread,\n      allowProto,\n      allowInexact,\n    }: {\n      allowStatic: boolean;\n      allowExact: boolean;\n      allowSpread: boolean;\n      allowProto: boolean;\n      allowInexact: boolean;\n    }): N.FlowObjectTypeAnnotation {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n\n      const nodeStart = this.startNode<N.FlowObjectTypeAnnotation>();\n\n      nodeStart.callProperties = [];\n      nodeStart.properties = [];\n      nodeStart.indexers = [];\n      nodeStart.internalSlots = [];\n\n      let endDelim;\n      let exact;\n      let inexact = false;\n      if (allowExact && this.match(tt.braceBarL)) {\n        this.expect(tt.braceBarL);\n        endDelim = tt.braceBarR;\n        exact = true;\n      } else {\n        this.expect(tt.braceL);\n        endDelim = tt.braceR;\n        exact = false;\n      }\n\n      nodeStart.exact = exact;\n\n      while (!this.match(endDelim)) {\n        let isStatic = false;\n        let protoStartLoc: Position | undefined | null = null;\n        let inexactStartLoc: Position | undefined | null = null;\n        const node = this.startNode();\n\n        if (allowProto && this.isContextual(tt._proto)) {\n          const lookahead = this.lookahead();\n\n          if (lookahead.type !== tt.colon && lookahead.type !== tt.question) {\n            this.next();\n            protoStartLoc = this.state.startLoc;\n            allowStatic = false;\n          }\n        }\n\n        if (allowStatic && this.isContextual(tt._static)) {\n          const lookahead = this.lookahead();\n\n          // static is a valid identifier name\n          if (lookahead.type !== tt.colon && lookahead.type !== tt.question) {\n            this.next();\n            isStatic = true;\n          }\n        }\n\n        const variance = this.flowParseVariance();\n\n        if (this.eat(tt.bracketL)) {\n          if (protoStartLoc != null) {\n            this.unexpected(protoStartLoc);\n          }\n          if (this.eat(tt.bracketL)) {\n            if (variance) {\n              this.unexpected(variance.loc.start);\n            }\n            nodeStart.internalSlots.push(\n              this.flowParseObjectTypeInternalSlot(node, isStatic),\n            );\n          } else {\n            nodeStart.indexers.push(\n              this.flowParseObjectTypeIndexer(node, isStatic, variance),\n            );\n          }\n        } else if (this.match(tt.parenL) || this.match(tt.lt)) {\n          if (protoStartLoc != null) {\n            this.unexpected(protoStartLoc);\n          }\n          if (variance) {\n            this.unexpected(variance.loc.start);\n          }\n          nodeStart.callProperties.push(\n            this.flowParseObjectTypeCallProperty(node, isStatic),\n          );\n        } else {\n          let kind = \"init\";\n\n          if (this.isContextual(tt._get) || this.isContextual(tt._set)) {\n            const lookahead = this.lookahead();\n            if (tokenIsLiteralPropertyName(lookahead.type)) {\n              kind = this.state.value;\n              this.next();\n            }\n          }\n\n          const propOrInexact = this.flowParseObjectTypeProperty(\n            node,\n            isStatic,\n            protoStartLoc,\n            variance,\n            kind,\n            allowSpread,\n            allowInexact ?? !exact,\n          );\n\n          if (propOrInexact === null) {\n            inexact = true;\n            inexactStartLoc = this.state.lastTokStartLoc;\n          } else {\n            nodeStart.properties.push(propOrInexact);\n          }\n        }\n\n        this.flowObjectTypeSemicolon();\n\n        if (\n          inexactStartLoc &&\n          !this.match(tt.braceR) &&\n          !this.match(tt.braceBarR)\n        ) {\n          this.raise(\n            FlowErrors.UnexpectedExplicitInexactInObject,\n            inexactStartLoc,\n          );\n        }\n      }\n\n      this.expect(endDelim);\n\n      /* The inexact flag should only be added on ObjectTypeAnnotations that\n       * are not the body of an interface, declare interface, or declare class.\n       * Since spreads are only allowed in object types, checking that is\n       * sufficient here.\n       */\n      if (allowSpread) {\n        nodeStart.inexact = inexact;\n      }\n\n      const out = this.finishNode(nodeStart, \"ObjectTypeAnnotation\");\n\n      this.state.inType = oldInType;\n\n      return out;\n    }\n\n    flowParseObjectTypeProperty(\n      node: Undone<N.FlowObjectTypeProperty | N.FlowObjectTypeSpreadProperty>,\n      isStatic: boolean,\n      protoStartLoc: Position | undefined | null,\n      variance: N.FlowVariance | undefined | null,\n      kind: string,\n      allowSpread: boolean,\n      allowInexact: boolean,\n    ): N.FlowObjectTypeProperty | N.FlowObjectTypeSpreadProperty | null {\n      if (this.eat(tt.ellipsis)) {\n        const isInexactToken =\n          this.match(tt.comma) ||\n          this.match(tt.semi) ||\n          this.match(tt.braceR) ||\n          this.match(tt.braceBarR);\n\n        if (isInexactToken) {\n          if (!allowSpread) {\n            this.raise(\n              FlowErrors.InexactInsideNonObject,\n              this.state.lastTokStartLoc,\n            );\n          } else if (!allowInexact) {\n            this.raise(\n              FlowErrors.InexactInsideExact,\n              this.state.lastTokStartLoc,\n            );\n          }\n          if (variance) {\n            this.raise(FlowErrors.InexactVariance, variance);\n          }\n\n          return null;\n        }\n\n        if (!allowSpread) {\n          this.raise(\n            FlowErrors.UnexpectedSpreadType,\n            this.state.lastTokStartLoc,\n          );\n        }\n        if (protoStartLoc != null) {\n          this.unexpected(protoStartLoc);\n        }\n        if (variance) {\n          this.raise(FlowErrors.SpreadVariance, variance);\n        }\n\n        node.argument = this.flowParseType();\n        return this.finishNode(node, \"ObjectTypeSpreadProperty\");\n      } else {\n        node.key = this.flowParseObjectPropertyKey();\n        node.static = isStatic;\n        node.proto = protoStartLoc != null;\n        node.kind = kind;\n\n        let optional = false;\n        if (this.match(tt.lt) || this.match(tt.parenL)) {\n          // This is a method property\n          node.method = true;\n\n          if (protoStartLoc != null) {\n            this.unexpected(protoStartLoc);\n          }\n          if (variance) {\n            this.unexpected(variance.loc.start);\n          }\n\n          node.value = this.flowParseObjectTypeMethodish(\n            this.startNodeAt(node.loc.start),\n          );\n          if (kind === \"get\" || kind === \"set\") {\n            this.flowCheckGetterSetterParams(node);\n          }\n          /** Declared classes/interfaces do not allow spread */\n          if (\n            !allowSpread &&\n            node.key.name === \"constructor\" &&\n            node.value.this\n          ) {\n            this.raise(\n              FlowErrors.ThisParamBannedInConstructor,\n              node.value.this,\n            );\n          }\n        } else {\n          if (kind !== \"init\") this.unexpected();\n\n          node.method = false;\n\n          if (this.eat(tt.question)) {\n            optional = true;\n          }\n          node.value = this.flowParseTypeInitialiser();\n          node.variance = variance;\n        }\n\n        node.optional = optional;\n\n        return this.finishNode(node, \"ObjectTypeProperty\");\n      }\n    }\n\n    // This is similar to checkGetterSetterParams, but as\n    // @babel/parser uses non estree properties we cannot reuse it here\n    flowCheckGetterSetterParams(\n      property: Undone<\n        N.FlowObjectTypeProperty | N.FlowObjectTypeSpreadProperty\n      >,\n    ): void {\n      const paramCount = property.kind === \"get\" ? 0 : 1;\n      const length =\n        property.value.params.length + (property.value.rest ? 1 : 0);\n\n      if (property.value.this) {\n        this.raise(\n          property.kind === \"get\"\n            ? FlowErrors.GetterMayNotHaveThisParam\n            : FlowErrors.SetterMayNotHaveThisParam,\n          property.value.this,\n        );\n      }\n\n      if (length !== paramCount) {\n        this.raise(\n          property.kind === \"get\"\n            ? Errors.BadGetterArity\n            : Errors.BadSetterArity,\n          property,\n        );\n      }\n\n      if (property.kind === \"set\" && property.value.rest) {\n        this.raise(Errors.BadSetterRestParameter, property);\n      }\n    }\n\n    flowObjectTypeSemicolon(): void {\n      if (\n        !this.eat(tt.semi) &&\n        !this.eat(tt.comma) &&\n        !this.match(tt.braceR) &&\n        !this.match(tt.braceBarR)\n      ) {\n        this.unexpected();\n      }\n    }\n\n    flowParseQualifiedTypeIdentifier(\n      startLoc?: Position,\n      id?: N.Identifier,\n    ): N.FlowQualifiedTypeIdentifier | N.Identifier {\n      startLoc ??= this.state.startLoc;\n      let node: N.Identifier | N.FlowQualifiedTypeIdentifier =\n        id || this.flowParseRestrictedIdentifier(true);\n\n      while (this.eat(tt.dot)) {\n        const node2 = this.startNodeAt<N.FlowQualifiedTypeIdentifier>(startLoc);\n        node2.qualification = node;\n        node2.id = this.flowParseRestrictedIdentifier(true);\n        node = this.finishNode(node2, \"QualifiedTypeIdentifier\");\n      }\n\n      return node;\n    }\n\n    flowParseGenericType(\n      startLoc: Position,\n      id: N.Identifier,\n    ): N.FlowGenericTypeAnnotation {\n      const node = this.startNodeAt<N.FlowGenericTypeAnnotation>(startLoc);\n\n      node.typeParameters = null;\n      node.id = this.flowParseQualifiedTypeIdentifier(startLoc, id);\n\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterInstantiation();\n      }\n\n      return this.finishNode(node, \"GenericTypeAnnotation\");\n    }\n\n    flowParseTypeofType(): N.FlowTypeofTypeAnnotation {\n      const node = this.startNode<N.FlowTypeofTypeAnnotation>();\n      this.expect(tt._typeof);\n      node.argument = this.flowParsePrimaryType();\n      return this.finishNode(node, \"TypeofTypeAnnotation\");\n    }\n\n    flowParseTupleType(): N.FlowTupleTypeAnnotation {\n      const node = this.startNode<N.FlowTupleTypeAnnotation>();\n      node.types = [];\n      this.expect(tt.bracketL);\n      // We allow trailing commas\n      while (this.state.pos < this.length && !this.match(tt.bracketR)) {\n        node.types.push(this.flowParseType());\n        if (this.match(tt.bracketR)) break;\n        this.expect(tt.comma);\n      }\n      this.expect(tt.bracketR);\n      return this.finishNode(node, \"TupleTypeAnnotation\");\n    }\n\n    flowParseFunctionTypeParam(first: boolean): N.FlowFunctionTypeParam {\n      let name = null;\n      let optional = false;\n      let typeAnnotation = null;\n      const node = this.startNode<N.FlowFunctionTypeParam>();\n      const lh = this.lookahead();\n      const isThis = this.state.type === tt._this;\n\n      if (lh.type === tt.colon || lh.type === tt.question) {\n        if (isThis && !first) {\n          this.raise(FlowErrors.ThisParamMustBeFirst, node);\n        }\n        name = this.parseIdentifier(isThis);\n        if (this.eat(tt.question)) {\n          optional = true;\n          if (isThis) {\n            this.raise(FlowErrors.ThisParamMayNotBeOptional, node);\n          }\n        }\n        typeAnnotation = this.flowParseTypeInitialiser();\n      } else {\n        typeAnnotation = this.flowParseType();\n      }\n      node.name = name;\n      node.optional = optional;\n      node.typeAnnotation = typeAnnotation;\n      return this.finishNode(node, \"FunctionTypeParam\");\n    }\n\n    reinterpretTypeAsFunctionTypeParam(\n      type: N.FlowType,\n    ): N.FlowFunctionTypeParam {\n      const node = this.startNodeAt<N.FlowFunctionTypeParam>(type.loc.start);\n      node.name = null;\n      node.optional = false;\n      node.typeAnnotation = type;\n      return this.finishNode(node, \"FunctionTypeParam\");\n    }\n\n    flowParseFunctionTypeParams(params: N.FlowFunctionTypeParam[] = []): {\n      params: N.FlowFunctionTypeParam[];\n      rest: N.FlowFunctionTypeParam | undefined | null;\n      _this: N.FlowFunctionTypeParam | undefined | null;\n    } {\n      let rest: N.FlowFunctionTypeParam | undefined | null = null;\n      let _this: N.FlowFunctionTypeParam | undefined | null = null;\n      if (this.match(tt._this)) {\n        _this = this.flowParseFunctionTypeParam(/* first */ true);\n        // match Flow parser behavior\n        _this.name = null;\n        if (!this.match(tt.parenR)) {\n          this.expect(tt.comma);\n        }\n      }\n      while (!this.match(tt.parenR) && !this.match(tt.ellipsis)) {\n        params.push(this.flowParseFunctionTypeParam(false));\n        if (!this.match(tt.parenR)) {\n          this.expect(tt.comma);\n        }\n      }\n      if (this.eat(tt.ellipsis)) {\n        rest = this.flowParseFunctionTypeParam(false);\n      }\n      return { params, rest, _this };\n    }\n\n    flowIdentToTypeAnnotation(\n      startLoc: Position,\n      node: Undone<N.FlowType>,\n      id: N.Identifier,\n    ): N.FlowType {\n      switch (id.name) {\n        case \"any\":\n          return this.finishNode(node, \"AnyTypeAnnotation\");\n\n        case \"bool\":\n        case \"boolean\":\n          return this.finishNode(node, \"BooleanTypeAnnotation\");\n\n        case \"mixed\":\n          return this.finishNode(node, \"MixedTypeAnnotation\");\n\n        case \"empty\":\n          return this.finishNode(node, \"EmptyTypeAnnotation\");\n\n        case \"number\":\n          return this.finishNode(node, \"NumberTypeAnnotation\");\n\n        case \"string\":\n          return this.finishNode(node, \"StringTypeAnnotation\");\n\n        case \"symbol\":\n          return this.finishNode(node, \"SymbolTypeAnnotation\");\n\n        default:\n          this.checkNotUnderscore(id.name);\n          return this.flowParseGenericType(startLoc, id);\n      }\n    }\n\n    // The parsing of types roughly parallels the parsing of expressions, and\n    // primary types are kind of like primary expressions...they're the\n    // primitives with which other types are constructed.\n    flowParsePrimaryType(): N.FlowType {\n      const startLoc = this.state.startLoc;\n      const node = this.startNode<N.FlowOtherTypeAnnotation>();\n      let tmp;\n      let type;\n      let isGroupedType = false;\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n\n      switch (this.state.type) {\n        case tt.braceL:\n          return this.flowParseObjectType({\n            allowStatic: false,\n            allowExact: false,\n            allowSpread: true,\n            allowProto: false,\n            allowInexact: true,\n          });\n\n        case tt.braceBarL:\n          return this.flowParseObjectType({\n            allowStatic: false,\n            allowExact: true,\n            allowSpread: true,\n            allowProto: false,\n            allowInexact: false,\n          });\n\n        case tt.bracketL:\n          this.state.noAnonFunctionType = false;\n          type = this.flowParseTupleType();\n          this.state.noAnonFunctionType = oldNoAnonFunctionType;\n          return type;\n\n        case tt.lt: {\n          const node = this.startNode<N.FlowFunctionTypeAnnotation>();\n          node.typeParameters = this.flowParseTypeParameterDeclaration();\n          this.expect(tt.parenL);\n          tmp = this.flowParseFunctionTypeParams();\n          node.params = tmp.params;\n          node.rest = tmp.rest;\n          node.this = tmp._this;\n          this.expect(tt.parenR);\n\n          this.expect(tt.arrow);\n\n          node.returnType = this.flowParseType();\n\n          return this.finishNode(node, \"FunctionTypeAnnotation\");\n        }\n\n        case tt.parenL: {\n          const node = this.startNode<N.FlowFunctionTypeAnnotation>();\n          this.next();\n\n          // Check to see if this is actually a grouped type\n          if (!this.match(tt.parenR) && !this.match(tt.ellipsis)) {\n            if (tokenIsIdentifier(this.state.type) || this.match(tt._this)) {\n              const token = this.lookahead().type;\n              isGroupedType = token !== tt.question && token !== tt.colon;\n            } else {\n              isGroupedType = true;\n            }\n          }\n\n          if (isGroupedType) {\n            this.state.noAnonFunctionType = false;\n            type = this.flowParseType();\n            this.state.noAnonFunctionType = oldNoAnonFunctionType;\n\n            // A `,` or a `) =>` means this is an anonymous function type\n            if (\n              this.state.noAnonFunctionType ||\n              !(\n                this.match(tt.comma) ||\n                (this.match(tt.parenR) && this.lookahead().type === tt.arrow)\n              )\n            ) {\n              this.expect(tt.parenR);\n              return type;\n            } else {\n              // Eat a comma if there is one\n              this.eat(tt.comma);\n            }\n          }\n\n          if (type) {\n            tmp = this.flowParseFunctionTypeParams([\n              this.reinterpretTypeAsFunctionTypeParam(type),\n            ]);\n          } else {\n            tmp = this.flowParseFunctionTypeParams();\n          }\n\n          node.params = tmp.params;\n          node.rest = tmp.rest;\n          node.this = tmp._this;\n\n          this.expect(tt.parenR);\n\n          this.expect(tt.arrow);\n\n          node.returnType = this.flowParseType();\n\n          node.typeParameters = null;\n\n          return this.finishNode(node, \"FunctionTypeAnnotation\");\n        }\n\n        case tt.string:\n          return this.parseLiteral<N.StringLiteralTypeAnnotation>(\n            this.state.value,\n            \"StringLiteralTypeAnnotation\",\n          );\n\n        case tt._true:\n        case tt._false:\n          node.value = this.match(tt._true);\n          this.next();\n          return this.finishNode(\n            node as Undone<N.BooleanLiteralTypeAnnotation>,\n            \"BooleanLiteralTypeAnnotation\",\n          );\n\n        case tt.plusMin:\n          if (this.state.value === \"-\") {\n            this.next();\n            if (this.match(tt.num)) {\n              return this.parseLiteralAtNode<N.NumberLiteralTypeAnnotation>(\n                -this.state.value,\n                \"NumberLiteralTypeAnnotation\",\n                node,\n              );\n            }\n\n            if (this.match(tt.bigint)) {\n              return this.parseLiteralAtNode<N.BigIntLiteralTypeAnnotation>(\n                -this.state.value,\n                \"BigIntLiteralTypeAnnotation\",\n                node,\n              );\n            }\n\n            throw this.raise(\n              FlowErrors.UnexpectedSubtractionOperand,\n              this.state.startLoc,\n            );\n          }\n          this.unexpected();\n          return;\n        case tt.num:\n          return this.parseLiteral(\n            this.state.value,\n            \"NumberLiteralTypeAnnotation\",\n          );\n\n        case tt.bigint:\n          return this.parseLiteral(\n            this.state.value,\n            \"BigIntLiteralTypeAnnotation\",\n          );\n\n        case tt._void:\n          this.next();\n          return this.finishNode(node, \"VoidTypeAnnotation\");\n\n        case tt._null:\n          this.next();\n          return this.finishNode(node, \"NullLiteralTypeAnnotation\");\n\n        case tt._this:\n          this.next();\n          return this.finishNode(node, \"ThisTypeAnnotation\");\n\n        case tt.star:\n          this.next();\n          return this.finishNode(node, \"ExistsTypeAnnotation\");\n\n        case tt._typeof:\n          return this.flowParseTypeofType();\n\n        default:\n          if (tokenIsKeyword(this.state.type)) {\n            const label = tokenLabelName(this.state.type);\n            this.next();\n            return super.createIdentifier(node as Undone<N.Identifier>, label);\n          } else if (tokenIsIdentifier(this.state.type)) {\n            if (this.isContextual(tt._interface)) {\n              return this.flowParseInterfaceType();\n            }\n\n            return this.flowIdentToTypeAnnotation(\n              startLoc,\n              node,\n              this.parseIdentifier(),\n            );\n          }\n      }\n\n      this.unexpected();\n    }\n\n    flowParsePostfixType(): N.FlowType {\n      const startLoc = this.state.startLoc;\n      let type = this.flowParsePrimaryType();\n      let seenOptionalIndexedAccess = false;\n      while (\n        (this.match(tt.bracketL) || this.match(tt.questionDot)) &&\n        !this.canInsertSemicolon()\n      ) {\n        const node = this.startNodeAt<N.FlowOtherTypeAnnotation>(startLoc);\n        const optional = this.eat(tt.questionDot);\n        seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;\n        this.expect(tt.bracketL);\n        if (!optional && this.match(tt.bracketR)) {\n          node.elementType = type;\n          this.next(); // eat `]`\n          type = this.finishNode(node, \"ArrayTypeAnnotation\");\n        } else {\n          node.objectType = type;\n          node.indexType = this.flowParseType();\n          this.expect(tt.bracketR);\n          if (seenOptionalIndexedAccess) {\n            node.optional = optional;\n            type = this.finishNode<N.FlowOptionalIndexedAccessType>(\n              // @ts-expect-error todo(flow->ts)\n              node,\n              \"OptionalIndexedAccessType\",\n            );\n          } else {\n            type = this.finishNode<N.FlowIndexedAccessType>(\n              // @ts-expect-error todo(flow->ts)\n              node,\n              \"IndexedAccessType\",\n            );\n          }\n        }\n      }\n      return type;\n    }\n\n    flowParsePrefixType(): N.FlowType {\n      const node = this.startNode<N.FlowOtherTypeAnnotation>();\n      if (this.eat(tt.question)) {\n        node.typeAnnotation = this.flowParsePrefixType();\n        return this.finishNode(node, \"NullableTypeAnnotation\");\n      } else {\n        return this.flowParsePostfixType();\n      }\n    }\n\n    flowParseAnonFunctionWithoutParens(): N.FlowType {\n      const param = this.flowParsePrefixType();\n      if (!this.state.noAnonFunctionType && this.eat(tt.arrow)) {\n        // TODO: This should be a type error. Passing in a SourceLocation, and it expects a Position.\n        const node = this.startNodeAt<N.FlowFunctionTypeAnnotation>(\n          param.loc.start,\n        );\n        node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];\n        node.rest = null;\n        node.this = null;\n        node.returnType = this.flowParseType();\n        node.typeParameters = null;\n        return this.finishNode(node, \"FunctionTypeAnnotation\");\n      }\n      return param;\n    }\n\n    flowParseIntersectionType(): N.FlowType {\n      const node = this.startNode<N.FlowOtherTypeAnnotation>();\n      this.eat(tt.bitwiseAND);\n      const type = this.flowParseAnonFunctionWithoutParens();\n      node.types = [type];\n      while (this.eat(tt.bitwiseAND)) {\n        node.types.push(this.flowParseAnonFunctionWithoutParens());\n      }\n      return node.types.length === 1\n        ? type\n        : this.finishNode(node, \"IntersectionTypeAnnotation\");\n    }\n\n    flowParseUnionType(): N.FlowType {\n      const node = this.startNode<N.FlowOtherTypeAnnotation>();\n      this.eat(tt.bitwiseOR);\n      const type = this.flowParseIntersectionType();\n      node.types = [type];\n      while (this.eat(tt.bitwiseOR)) {\n        node.types.push(this.flowParseIntersectionType());\n      }\n      return node.types.length === 1\n        ? type\n        : this.finishNode(node, \"UnionTypeAnnotation\");\n    }\n\n    flowParseType(): N.FlowType {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n      const type = this.flowParseUnionType();\n      this.state.inType = oldInType;\n      return type;\n    }\n\n    flowParseTypeOrImplicitInstantiation(): N.FlowType {\n      if (this.state.type === tt.name && this.state.value === \"_\") {\n        const startLoc = this.state.startLoc;\n        const node = this.parseIdentifier();\n        return this.flowParseGenericType(startLoc, node);\n      } else {\n        return this.flowParseType();\n      }\n    }\n\n    flowParseTypeAnnotation(): N.TypeAnnotation {\n      const node = this.startNode<N.TypeAnnotation>();\n      node.typeAnnotation = this.flowParseTypeInitialiser();\n      return this.finishNode(node, \"TypeAnnotation\");\n    }\n\n    flowParseTypeAnnotatableIdentifier(\n      allowPrimitiveOverride?: boolean,\n    ): N.Identifier {\n      const ident = allowPrimitiveOverride\n        ? this.parseIdentifier()\n        : this.flowParseRestrictedIdentifier();\n      if (this.match(tt.colon)) {\n        ident.typeAnnotation = this.flowParseTypeAnnotation();\n        this.resetEndLocation(ident);\n      }\n      return ident;\n    }\n\n    typeCastToParameter(node: N.TypeCastExpression): N.Expression {\n      (node.expression as N.Identifier).typeAnnotation = node.typeAnnotation;\n\n      this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);\n\n      return node.expression;\n    }\n\n    flowParseVariance(): N.FlowVariance | undefined | null {\n      let variance = null;\n      if (this.match(tt.plusMin)) {\n        variance = this.startNode<N.FlowVariance>();\n        if (this.state.value === \"+\") {\n          variance.kind = \"plus\";\n        } else {\n          variance.kind = \"minus\";\n        }\n        this.next();\n        return this.finishNode(variance, \"Variance\");\n      }\n      return variance;\n    }\n\n    // ==================================\n    // Overrides\n    // ==================================\n\n    parseFunctionBody(\n      node: N.Function,\n      allowExpressionBody?: boolean | null,\n      isMethod: boolean = false,\n    ): void {\n      if (allowExpressionBody) {\n        this.forwardNoArrowParamsConversionAt(node, () =>\n          super.parseFunctionBody(node, true, isMethod),\n        );\n        return;\n      }\n\n      super.parseFunctionBody(node, false, isMethod);\n    }\n\n    parseFunctionBodyAndFinish<\n      T extends\n        | N.Function\n        | N.TSDeclareMethod\n        | N.TSDeclareFunction\n        | N.ClassPrivateMethod,\n    >(node: Undone<T>, type: T[\"type\"], isMethod: boolean = false): T {\n      if (this.match(tt.colon)) {\n        const typeNode = this.startNode<N.TypeAnnotation>();\n\n        [\n          typeNode.typeAnnotation,\n          // @ts-expect-error predicate may not exist\n          node.predicate,\n        ] = this.flowParseTypeAndPredicateInitialiser();\n\n        node.returnType = typeNode.typeAnnotation\n          ? this.finishNode(typeNode, \"TypeAnnotation\")\n          : null;\n      }\n\n      return super.parseFunctionBodyAndFinish(node, type, isMethod);\n    }\n\n    // interfaces and enums\n    parseStatementLike(flags: ParseStatementFlag): N.Statement {\n      // strict mode handling of `interface` since it's a reserved word\n      if (this.state.strict && this.isContextual(tt._interface)) {\n        const lookahead = this.lookahead();\n        if (tokenIsKeywordOrIdentifier(lookahead.type)) {\n          const node = this.startNode<N.FlowInterface>();\n          this.next();\n          return this.flowParseInterface(node);\n        }\n      } else if (this.isContextual(tt._enum)) {\n        const node = this.startNode();\n        this.next();\n        return this.flowParseEnumDeclaration(node);\n      }\n      const stmt = super.parseStatementLike(flags);\n      // We will parse a flow pragma in any comment before the first statement.\n      if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {\n        this.flowPragma = null;\n      }\n      return stmt;\n    }\n\n    // declares, interfaces and type aliases\n    parseExpressionStatement(\n      node: N.ExpressionStatement,\n      expr: N.Expression,\n      decorators: N.Decorator[] | null,\n    ): N.ExpressionStatement {\n      if (expr.type === \"Identifier\") {\n        if (expr.name === \"declare\") {\n          if (\n            this.match(tt._class) ||\n            tokenIsIdentifier(this.state.type) ||\n            this.match(tt._function) ||\n            this.match(tt._var) ||\n            this.match(tt._export)\n          ) {\n            // @ts-expect-error: refine typings\n            return this.flowParseDeclare(node);\n          }\n        } else if (tokenIsIdentifier(this.state.type)) {\n          if (expr.name === \"interface\") {\n            // @ts-expect-error: refine typings\n            return this.flowParseInterface(node);\n          } else if (expr.name === \"type\") {\n            // @ts-expect-error: refine typings\n            return this.flowParseTypeAlias(node);\n          } else if (expr.name === \"opaque\") {\n            // @ts-expect-error: refine typings\n            return this.flowParseOpaqueType(node, false);\n          }\n        }\n      }\n\n      return super.parseExpressionStatement(node, expr, decorators);\n    }\n\n    // export type\n    shouldParseExportDeclaration(): boolean {\n      const { type } = this.state;\n      if (type === tt._enum || tokenIsFlowInterfaceOrTypeOrOpaque(type)) {\n        return !this.state.containsEsc;\n      }\n      return super.shouldParseExportDeclaration();\n    }\n\n    isExportDefaultSpecifier(): boolean {\n      const { type } = this.state;\n      if (type === tt._enum || tokenIsFlowInterfaceOrTypeOrOpaque(type)) {\n        return this.state.containsEsc;\n      }\n\n      return super.isExportDefaultSpecifier();\n    }\n\n    parseExportDefaultExpression() {\n      if (this.isContextual(tt._enum)) {\n        const node = this.startNode();\n        this.next();\n        return this.flowParseEnumDeclaration(node);\n      }\n      return super.parseExportDefaultExpression();\n    }\n\n    parseConditional(\n      expr: N.Expression,\n\n      startLoc: Position,\n      refExpressionErrors?: ExpressionErrors | null,\n    ): N.Expression {\n      if (!this.match(tt.question)) return expr;\n\n      if (this.state.maybeInArrowParameters) {\n        const nextCh = this.lookaheadCharCode();\n        // These tokens cannot start an expression, so if one of them follows\n        // ? then we are probably in an arrow function parameters list and we\n        // don't parse the conditional expression.\n        if (\n          nextCh === charCodes.comma || // (a?, b) => c\n          nextCh === charCodes.equalsTo || // (a? = b) => c\n          nextCh === charCodes.colon || // (a?: b) => c\n          nextCh === charCodes.rightParenthesis // (a?) => c\n        ) {\n          /*:: invariant(refExpressionErrors != null) */\n          this.setOptionalParametersError(refExpressionErrors);\n          return expr;\n        }\n      }\n\n      this.expect(tt.question);\n      const state = this.state.clone();\n      const originalNoArrowAt = this.state.noArrowAt;\n      const node = this.startNodeAt<N.ConditionalExpression>(startLoc);\n      let { consequent, failed } = this.tryParseConditionalConsequent();\n      let [valid, invalid] = this.getArrowLikeExpressions(consequent);\n\n      if (failed || invalid.length > 0) {\n        const noArrowAt = [...originalNoArrowAt];\n\n        if (invalid.length > 0) {\n          this.state = state;\n          this.state.noArrowAt = noArrowAt;\n\n          for (let i = 0; i < invalid.length; i++) {\n            noArrowAt.push(invalid[i].start);\n          }\n\n          ({ consequent, failed } = this.tryParseConditionalConsequent());\n          [valid, invalid] = this.getArrowLikeExpressions(consequent);\n        }\n\n        if (failed && valid.length > 1) {\n          // if there are two or more possible correct ways of parsing, throw an\n          // error.\n          // e.g.   Source: a ? (b): c => (d): e => f\n          //      Result 1: a ? b : (c => ((d): e => f))\n          //      Result 2: a ? ((b): c => d) : (e => f)\n          this.raise(FlowErrors.AmbiguousConditionalArrow, state.startLoc);\n        }\n\n        if (failed && valid.length === 1) {\n          this.state = state;\n          noArrowAt.push(valid[0].start);\n          this.state.noArrowAt = noArrowAt;\n          ({ consequent, failed } = this.tryParseConditionalConsequent());\n        }\n      }\n\n      this.getArrowLikeExpressions(consequent, true);\n\n      this.state.noArrowAt = originalNoArrowAt;\n      this.expect(tt.colon);\n\n      node.test = expr;\n      node.consequent = consequent;\n      node.alternate = this.forwardNoArrowParamsConversionAt(node, () =>\n        this.parseMaybeAssign(undefined, undefined),\n      );\n\n      return this.finishNode(node, \"ConditionalExpression\");\n    }\n\n    tryParseConditionalConsequent(): {\n      consequent: N.Expression;\n      failed: boolean;\n    } {\n      this.state.noArrowParamsConversionAt.push(this.state.start);\n\n      const consequent = this.parseMaybeAssignAllowIn();\n      const failed = !this.match(tt.colon);\n\n      this.state.noArrowParamsConversionAt.pop();\n\n      return { consequent, failed };\n    }\n\n    // Given an expression, walks through out its arrow functions whose body is\n    // an expression and through out conditional expressions. It returns every\n    // function which has been parsed with a return type but could have been\n    // parenthesized expressions.\n    // These functions are separated into two arrays: one containing the ones\n    // whose parameters can be converted to assignable lists, one containing the\n    // others.\n    getArrowLikeExpressions(\n      node: N.Expression,\n      disallowInvalid?: boolean,\n    ): [N.ArrowFunctionExpression[], N.ArrowFunctionExpression[]] {\n      const stack = [node];\n      const arrows: N.ArrowFunctionExpression[] = [];\n\n      while (stack.length !== 0) {\n        const node = stack.pop();\n        if (\n          node.type === \"ArrowFunctionExpression\" &&\n          node.body.type !== \"BlockStatement\"\n        ) {\n          if (node.typeParameters || !node.returnType) {\n            // This is an arrow expression without ambiguity, so check its parameters\n            this.finishArrowValidation(node);\n          } else {\n            arrows.push(node);\n          }\n          stack.push(node.body);\n        } else if (node.type === \"ConditionalExpression\") {\n          stack.push(node.consequent);\n          stack.push(node.alternate);\n        }\n      }\n\n      if (disallowInvalid) {\n        arrows.forEach(node => this.finishArrowValidation(node));\n        return [arrows, []];\n      }\n\n      return partition(arrows, node =>\n        node.params.every(param => this.isAssignable(param, true)),\n      );\n    }\n\n    finishArrowValidation(node: N.ArrowFunctionExpression) {\n      this.toAssignableList(\n        // node.params is Expression[] instead of $ReadOnlyArray<Pattern> because it\n        // has not been converted yet.\n        node.params as any as N.Expression[],\n        node.extra?.trailingCommaLoc,\n        /* isLHS */ false,\n      );\n      // Enter scope, as checkParams defines bindings\n      this.scope.enter(ScopeFlag.FUNCTION | ScopeFlag.ARROW);\n      // Use super's method to force the parameters to be checked\n      super.checkParams(node, false, true);\n      this.scope.exit();\n    }\n\n    forwardNoArrowParamsConversionAt<T>(\n      node: Undone<N.Node>,\n      parse: () => T,\n    ): T {\n      let result: T;\n      if (\n        this.state.noArrowParamsConversionAt.includes(\n          this.offsetToSourcePos(node.start),\n        )\n      ) {\n        this.state.noArrowParamsConversionAt.push(this.state.start);\n        result = parse();\n        this.state.noArrowParamsConversionAt.pop();\n      } else {\n        result = parse();\n      }\n\n      return result;\n    }\n\n    parseParenItem<T extends N.Expression | N.RestElement | N.SpreadElement>(\n      node: T,\n      startLoc: Position,\n    ): T | N.TypeCastExpression | N.TsTypeCastExpression {\n      const newNode = super.parseParenItem(node, startLoc);\n      if (this.eat(tt.question)) {\n        (newNode as N.Identifier).optional = true;\n        // Include questionmark in location of node\n        // Don't use this.finishNode() as otherwise we might process comments twice and\n        // include already consumed parens\n        this.resetEndLocation(node);\n      }\n\n      if (this.match(tt.colon)) {\n        const typeCastNode = this.startNodeAt<N.TypeCastExpression>(startLoc);\n        typeCastNode.expression = newNode as N.Expression;\n        typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();\n\n        return this.finishNode(typeCastNode, \"TypeCastExpression\");\n      }\n\n      return newNode;\n    }\n\n    assertModuleNodeAllowed(node: N.Node) {\n      if (\n        (node.type === \"ImportDeclaration\" &&\n          (node.importKind === \"type\" || node.importKind === \"typeof\")) ||\n        (node.type === \"ExportNamedDeclaration\" &&\n          node.exportKind === \"type\") ||\n        (node.type === \"ExportAllDeclaration\" && node.exportKind === \"type\")\n      ) {\n        // Allow Flowtype imports and exports in all conditions because\n        // Flow itself does not care about 'sourceType'.\n        return;\n      }\n\n      super.assertModuleNodeAllowed(node);\n    }\n\n    parseExportDeclaration(\n      node: N.ExportNamedDeclaration,\n    ): N.Declaration | undefined | null {\n      if (this.isContextual(tt._type)) {\n        node.exportKind = \"type\";\n\n        const declarationNode = this.startNode();\n        this.next();\n\n        if (this.match(tt.braceL)) {\n          // export type { foo, bar };\n          node.specifiers = this.parseExportSpecifiers(\n            /* isInTypeExport */ true,\n          );\n          super.parseExportFrom(node);\n          return null;\n        } else {\n          // export type Foo = Bar;\n          // @ts-expect-error: refine typings\n          return this.flowParseTypeAlias(declarationNode);\n        }\n      } else if (this.isContextual(tt._opaque)) {\n        node.exportKind = \"type\";\n\n        const declarationNode = this.startNode();\n        this.next();\n        // export opaque type Foo = Bar;\n        // @ts-expect-error: refine typings\n        return this.flowParseOpaqueType(declarationNode, false);\n      } else if (this.isContextual(tt._interface)) {\n        node.exportKind = \"type\";\n        const declarationNode = this.startNode();\n        this.next();\n        // @ts-expect-error: refine typings\n        return this.flowParseInterface(declarationNode);\n      } else if (this.isContextual(tt._enum)) {\n        node.exportKind = \"value\";\n        const declarationNode = this.startNode();\n        this.next();\n        // @ts-expect-error: refine typings\n        return this.flowParseEnumDeclaration(declarationNode);\n      } else {\n        return super.parseExportDeclaration(node);\n      }\n    }\n\n    eatExportStar(\n      node: Undone<N.Node>,\n    ): node is Undone<N.ExportNamedDeclaration | N.ExportAllDeclaration> {\n      if (super.eatExportStar(node)) return true;\n\n      if (this.isContextual(tt._type) && this.lookahead().type === tt.star) {\n        (\n          node as Undone<N.ExportNamedDeclaration | N.ExportAllDeclaration>\n        ).exportKind = \"type\";\n        this.next();\n        this.next();\n        return true;\n      }\n\n      return false;\n    }\n\n    maybeParseExportNamespaceSpecifier(\n      node: Undone<N.ExportNamedDeclaration | N.ExportAllDeclaration>,\n    ): node is Undone<N.ExportNamedDeclaration> {\n      const { startLoc } = this.state;\n      const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);\n      if (hasNamespace && node.exportKind === \"type\") {\n        this.unexpected(startLoc);\n      }\n      return hasNamespace;\n    }\n\n    parseClassId(\n      node: N.Class,\n      isStatement: boolean,\n      optionalId?: boolean | null,\n    ) {\n      super.parseClassId(node, isStatement, optionalId);\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n    }\n\n    parseClassMember(\n      classBody: N.ClassBody,\n      member: any,\n      state: N.ParseClassMemberState,\n    ): void {\n      const { startLoc } = this.state;\n      if (this.isContextual(tt._declare)) {\n        if (super.parseClassMemberFromModifier(classBody, member)) {\n          // 'declare' is a class element name\n          return;\n        }\n\n        member.declare = true;\n      }\n\n      super.parseClassMember(classBody, member, state);\n\n      if (member.declare) {\n        if (\n          member.type !== \"ClassProperty\" &&\n          member.type !== \"ClassPrivateProperty\" &&\n          member.type !== \"PropertyDefinition\" // Used by estree plugin\n        ) {\n          this.raise(FlowErrors.DeclareClassElement, startLoc);\n        } else if (member.value) {\n          this.raise(FlowErrors.DeclareClassFieldInitializer, member.value);\n        }\n      }\n    }\n\n    isIterator(word: string): boolean {\n      return word === \"iterator\" || word === \"asyncIterator\";\n    }\n\n    readIterator(): void {\n      const word = super.readWord1();\n      const fullWord = \"@@\" + word;\n\n      // Allow @@iterator and @@asyncIterator as a identifier only inside type\n      if (!this.isIterator(word) || !this.state.inType) {\n        this.raise(Errors.InvalidIdentifier, this.state.curPosition(), {\n          identifierName: fullWord,\n        });\n      }\n\n      this.finishToken(tt.name, fullWord);\n    }\n\n    // ensure that inside flow types, we bypass the jsx parser plugin\n    getTokenFromCode(code: number): void {\n      const next = this.input.charCodeAt(this.state.pos + 1);\n      if (code === charCodes.leftCurlyBrace && next === charCodes.verticalBar) {\n        this.finishOp(tt.braceBarL, 2);\n      } else if (\n        this.state.inType &&\n        (code === charCodes.greaterThan || code === charCodes.lessThan)\n      ) {\n        this.finishOp(code === charCodes.greaterThan ? tt.gt : tt.lt, 1);\n      } else if (this.state.inType && code === charCodes.questionMark) {\n        if (next === charCodes.dot) {\n          this.finishOp(tt.questionDot, 2);\n        } else {\n          // allow double nullable types in Flow: ??string\n          this.finishOp(tt.question, 1);\n        }\n      } else if (\n        isIteratorStart(code, next, this.input.charCodeAt(this.state.pos + 2))\n      ) {\n        this.state.pos += 2; // eat \"@@\"\n        this.readIterator();\n      } else {\n        super.getTokenFromCode(code);\n      }\n    }\n\n    isAssignable(node: N.Node, isBinding?: boolean): boolean {\n      if (node.type === \"TypeCastExpression\") {\n        return this.isAssignable(node.expression, isBinding);\n      } else {\n        return super.isAssignable(node, isBinding);\n      }\n    }\n\n    toAssignable(node: N.Node, isLHS: boolean = false): void {\n      if (\n        !isLHS &&\n        node.type === \"AssignmentExpression\" &&\n        node.left.type === \"TypeCastExpression\"\n      ) {\n        node.left = this.typeCastToParameter(node.left) as N.Assignable;\n      }\n      super.toAssignable(node, isLHS);\n    }\n\n    // turn type casts that we found in function parameter head into type annotated params\n    toAssignableList(\n      exprList: N.Expression[],\n      trailingCommaLoc: Position | undefined | null,\n      isLHS: boolean,\n    ): void {\n      for (let i = 0; i < exprList.length; i++) {\n        const expr = exprList[i];\n        if (expr?.type === \"TypeCastExpression\") {\n          exprList[i] = this.typeCastToParameter(expr);\n        }\n      }\n      super.toAssignableList(exprList, trailingCommaLoc, isLHS);\n    }\n\n    // this is a list of nodes, from something like a call expression, we need to filter the\n    // type casts that we've found that are illegal in this context\n    toReferencedList(\n      exprList:\n        | ReadonlyArray<N.Expression | N.SpreadElement>\n        | ReadonlyArray<N.Expression | N.RestElement>,\n      isParenthesizedExpr?: boolean,\n    ):\n      | ReadonlyArray<N.Expression | N.SpreadElement>\n      | ReadonlyArray<N.Expression | N.RestElement> {\n      for (let i = 0; i < exprList.length; i++) {\n        const expr = exprList[i];\n        if (\n          expr &&\n          expr.type === \"TypeCastExpression\" &&\n          !expr.extra?.parenthesized &&\n          (exprList.length > 1 || !isParenthesizedExpr)\n        ) {\n          this.raise(FlowErrors.TypeCastInPattern, expr.typeAnnotation);\n        }\n      }\n\n      return exprList;\n    }\n\n    parseArrayLike(\n      close: TokenType,\n      canBePattern: boolean,\n      isTuple: boolean,\n      refExpressionErrors?: ExpressionErrors | null,\n    ): N.ArrayExpression | N.TupleExpression {\n      const node = super.parseArrayLike(\n        close,\n        canBePattern,\n        isTuple,\n        refExpressionErrors,\n      );\n\n      // This could be an array pattern:\n      //   ([a: string, b: string]) => {}\n      // In this case, we don't have to call toReferencedList. We will\n      // call it, if needed, when we are sure that it is a parenthesized\n      // expression by calling toReferencedListDeep.\n      if (canBePattern && !this.state.maybeInArrowParameters) {\n        this.toReferencedList(node.elements);\n      }\n\n      return node;\n    }\n\n    isValidLVal(type: string, isParenthesized: boolean, binding: BindingFlag) {\n      return (\n        type === \"TypeCastExpression\" ||\n        super.isValidLVal(type, isParenthesized, binding)\n      );\n    }\n\n    // parse class property type annotations\n    parseClassProperty(node: N.ClassProperty): N.ClassProperty {\n      if (this.match(tt.colon)) {\n        node.typeAnnotation = this.flowParseTypeAnnotation();\n      }\n      return super.parseClassProperty(node);\n    }\n\n    parseClassPrivateProperty(\n      node: N.ClassPrivateProperty,\n    ): N.ClassPrivateProperty {\n      if (this.match(tt.colon)) {\n        node.typeAnnotation = this.flowParseTypeAnnotation();\n      }\n      return super.parseClassPrivateProperty(node);\n    }\n\n    // determine whether or not we're currently in the position where a class method would appear\n    isClassMethod(): boolean {\n      return this.match(tt.lt) || super.isClassMethod();\n    }\n\n    // determine whether or not we're currently in the position where a class property would appear\n    isClassProperty(): boolean {\n      return this.match(tt.colon) || super.isClassProperty();\n    }\n\n    isNonstaticConstructor(method: N.ClassMethod | N.ClassProperty): boolean {\n      return !this.match(tt.colon) && super.isNonstaticConstructor(method);\n    }\n\n    // parse type parameters for class methods\n    pushClassMethod(\n      classBody: N.ClassBody,\n      method: N.ClassMethod,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isConstructor: boolean,\n      allowsDirectSuper: boolean,\n    ): void {\n      if ((method as any).variance) {\n        this.unexpected((method as any).variance.loc.start);\n      }\n      delete (method as any).variance;\n      if (this.match(tt.lt)) {\n        method.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n\n      super.pushClassMethod(\n        classBody,\n        method,\n        isGenerator,\n        isAsync,\n        isConstructor,\n        allowsDirectSuper,\n      );\n\n      if (method.params && isConstructor) {\n        const params = method.params;\n        if (params.length > 0 && this.isThisParam(params[0])) {\n          this.raise(FlowErrors.ThisParamBannedInConstructor, method);\n        }\n        // estree support\n      } else if (\n        // @ts-expect-error TS does not know about the fact that estree can replace ClassMethod with MethodDefinition\n        method.type === \"MethodDefinition\" &&\n        isConstructor &&\n        // @ts-expect-error estree\n        method.value.params\n      ) {\n        // @ts-expect-error estree\n        const params = method.value.params;\n        if (params.length > 0 && this.isThisParam(params[0])) {\n          this.raise(FlowErrors.ThisParamBannedInConstructor, method);\n        }\n      }\n    }\n\n    pushClassPrivateMethod(\n      classBody: N.ClassBody,\n      method: N.ClassPrivateMethod,\n      isGenerator: boolean,\n      isAsync: boolean,\n    ): void {\n      if ((method as any).variance) {\n        this.unexpected((method as any).variance.loc.start);\n      }\n      delete (method as any).variance;\n      if (this.match(tt.lt)) {\n        method.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n\n      super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n    }\n\n    // parse a the super class type parameters and implements\n    parseClassSuper(node: N.Class): void {\n      super.parseClassSuper(node);\n      if (\n        node.superClass &&\n        (this.match(tt.lt) ||\n          // handles `class extends C<<T>`\n          this.match(tt.bitShiftL))\n      ) {\n        if (process.env.BABEL_8_BREAKING) {\n          node.superTypeArguments =\n            this.flowParseTypeParameterInstantiationInExpression();\n        } else {\n          node.superTypeParameters =\n            this.flowParseTypeParameterInstantiationInExpression();\n        }\n      }\n      if (this.isContextual(tt._implements)) {\n        this.next();\n        const implemented: N.FlowClassImplements[] = (node.implements = []);\n        do {\n          const node = this.startNode<N.FlowClassImplements>();\n          node.id = this.flowParseRestrictedIdentifier(/*liberal*/ true);\n          if (this.match(tt.lt)) {\n            node.typeParameters = this.flowParseTypeParameterInstantiation();\n          } else {\n            node.typeParameters = null;\n          }\n          implemented.push(this.finishNode(node, \"ClassImplements\"));\n        } while (this.eat(tt.comma));\n      }\n    }\n\n    checkGetterSetterParams(method: N.ObjectMethod | N.ClassMethod): void {\n      super.checkGetterSetterParams(method);\n      const params = this.getObjectOrClassMethodParams(method);\n      if (params.length > 0) {\n        const param = params[0];\n        if (this.isThisParam(param) && method.kind === \"get\") {\n          this.raise(FlowErrors.GetterMayNotHaveThisParam, param);\n        } else if (this.isThisParam(param)) {\n          this.raise(FlowErrors.SetterMayNotHaveThisParam, param);\n        }\n      }\n    }\n\n    parsePropertyNamePrefixOperator(\n      node: N.ObjectOrClassMember | N.ClassMember,\n    ): void {\n      node.variance = this.flowParseVariance();\n    }\n\n    // parse type parameters for object method shorthand\n    parseObjPropValue<T extends N.ObjectMember>(\n      prop: Undone<T>,\n      startLoc: Position | undefined | null,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isPattern: boolean,\n      isAccessor: boolean,\n      refExpressionErrors?: ExpressionErrors | null,\n    ): T {\n      if ((prop as any).variance) {\n        this.unexpected((prop as any).variance.loc.start);\n      }\n      delete (prop as any).variance;\n\n      let typeParameters;\n\n      // method shorthand\n      if (this.match(tt.lt) && !isAccessor) {\n        typeParameters = this.flowParseTypeParameterDeclaration();\n        if (!this.match(tt.parenL)) this.unexpected();\n      }\n\n      const result = super.parseObjPropValue(\n        prop,\n        startLoc,\n        isGenerator,\n        isAsync,\n        isPattern,\n        isAccessor,\n        refExpressionErrors,\n      );\n\n      // add typeParameters if we found them\n      if (typeParameters) {\n        // @ts-expect-error: refine typings\n        (result.value || result).typeParameters = typeParameters;\n      }\n      return result;\n    }\n\n    parseFunctionParamType(param: N.Pattern): N.Pattern {\n      if (this.eat(tt.question)) {\n        if (param.type !== \"Identifier\") {\n          this.raise(FlowErrors.PatternIsOptional, param);\n        }\n        if (this.isThisParam(param)) {\n          this.raise(FlowErrors.ThisParamMayNotBeOptional, param);\n        }\n\n        (param as any as N.Identifier).optional = true;\n      }\n      if (this.match(tt.colon)) {\n        param.typeAnnotation = this.flowParseTypeAnnotation();\n      } else if (this.isThisParam(param)) {\n        this.raise(FlowErrors.ThisParamAnnotationRequired, param);\n      }\n\n      if (this.match(tt.eq) && this.isThisParam(param)) {\n        this.raise(FlowErrors.ThisParamNoDefault, param);\n      }\n\n      this.resetEndLocation(param);\n      return param;\n    }\n\n    parseMaybeDefault(\n      startLoc?: Position | null,\n      left?: N.Pattern | null,\n    ): N.Pattern {\n      const node = super.parseMaybeDefault(startLoc, left);\n\n      if (\n        node.type === \"AssignmentPattern\" &&\n        node.typeAnnotation &&\n        node.right.start < node.typeAnnotation.start\n      ) {\n        this.raise(FlowErrors.TypeBeforeInitializer, node.typeAnnotation);\n      }\n\n      return node;\n    }\n\n    checkImportReflection(node: Undone<N.ImportDeclaration>) {\n      super.checkImportReflection(node);\n      if (node.module && node.importKind !== \"value\") {\n        this.raise(\n          FlowErrors.ImportReflectionHasImportType,\n          node.specifiers[0].loc.start,\n        );\n      }\n    }\n\n    parseImportSpecifierLocal<\n      T extends\n        | N.ImportSpecifier\n        | N.ImportDefaultSpecifier\n        | N.ImportNamespaceSpecifier,\n    >(node: N.ImportDeclaration, specifier: Undone<T>, type: T[\"type\"]): void {\n      specifier.local = hasTypeImportKind(node)\n        ? this.flowParseRestrictedIdentifier(\n            /* liberal */ true,\n            /* declaration */ true,\n          )\n        : this.parseIdentifier();\n\n      node.specifiers.push(this.finishImportSpecifier(specifier, type));\n    }\n\n    isPotentialImportPhase(isExport: boolean): boolean {\n      if (super.isPotentialImportPhase(isExport)) return true;\n      if (this.isContextual(tt._type)) {\n        if (!isExport) return true;\n        const ch = this.lookaheadCharCode();\n        return ch === charCodes.leftCurlyBrace || ch === charCodes.asterisk;\n      }\n      return !isExport && this.isContextual(tt._typeof);\n    }\n\n    applyImportPhase(\n      node: Undone<N.ImportDeclaration | N.ExportNamedDeclaration>,\n      isExport: boolean,\n      phase: string | null,\n      loc?: Position,\n    ): void {\n      super.applyImportPhase(node, isExport, phase, loc);\n      if (isExport) {\n        if (!phase && this.match(tt._default)) {\n          // TODO: Align with our TS AST and always add .exportKind\n          return;\n        }\n        (node as N.ExportNamedDeclaration).exportKind =\n          phase === \"type\" ? phase : \"value\";\n      } else {\n        if (phase === \"type\" && this.match(tt.star)) this.unexpected();\n        (node as N.ImportDeclaration).importKind =\n          phase === \"type\" || phase === \"typeof\" ? phase : \"value\";\n      }\n    }\n\n    // parse import-type/typeof shorthand\n    parseImportSpecifier(\n      specifier: any,\n      importedIsString: boolean,\n      isInTypeOnlyImport: boolean,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      isMaybeTypeOnly: boolean,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      bindingType: BindingFlag | undefined,\n    ): N.ImportSpecifier {\n      const firstIdent = specifier.imported;\n\n      let specifierTypeKind = null;\n      if (firstIdent.type === \"Identifier\") {\n        if (firstIdent.name === \"type\") {\n          specifierTypeKind = \"type\";\n        } else if (firstIdent.name === \"typeof\") {\n          specifierTypeKind = \"typeof\";\n        }\n      }\n\n      let isBinding = false;\n      if (this.isContextual(tt._as) && !this.isLookaheadContextual(\"as\")) {\n        const as_ident = this.parseIdentifier(true);\n        if (\n          specifierTypeKind !== null &&\n          !tokenIsKeywordOrIdentifier(this.state.type)\n        ) {\n          // `import {type as ,` or `import {type as }`\n          specifier.imported = as_ident;\n          specifier.importKind = specifierTypeKind;\n          specifier.local = cloneIdentifier(as_ident);\n        } else {\n          // `import {type as foo`\n          specifier.imported = firstIdent;\n          specifier.importKind = null;\n          specifier.local = this.parseIdentifier();\n        }\n      } else {\n        if (\n          specifierTypeKind !== null &&\n          tokenIsKeywordOrIdentifier(this.state.type)\n        ) {\n          // `import {type foo`\n          specifier.imported = this.parseIdentifier(true);\n          specifier.importKind = specifierTypeKind;\n        } else {\n          if (importedIsString) {\n            /*:: invariant(firstIdent instanceof N.StringLiteral) */\n            throw this.raise(Errors.ImportBindingIsString, specifier, {\n              importName: firstIdent.value,\n            });\n          }\n          /*:: invariant(firstIdent instanceof N.Node) */\n          specifier.imported = firstIdent;\n          specifier.importKind = null;\n        }\n\n        if (this.eatContextual(tt._as)) {\n          specifier.local = this.parseIdentifier();\n        } else {\n          isBinding = true;\n          specifier.local = cloneIdentifier(specifier.imported);\n        }\n      }\n\n      const specifierIsTypeImport = hasTypeImportKind(specifier);\n\n      if (isInTypeOnlyImport && specifierIsTypeImport) {\n        this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, specifier);\n      }\n\n      if (isInTypeOnlyImport || specifierIsTypeImport) {\n        this.checkReservedType(\n          specifier.local.name,\n          specifier.local.loc.start,\n          /* declaration */ true,\n        );\n      }\n\n      if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {\n        this.checkReservedWord(\n          specifier.local.name,\n          specifier.loc.start,\n          true,\n          true,\n        );\n      }\n\n      return this.finishImportSpecifier(specifier, \"ImportSpecifier\");\n    }\n\n    parseBindingAtom(): N.Pattern {\n      switch (this.state.type) {\n        case tt._this:\n          // \"this\" may be the name of a parameter, so allow it.\n          return this.parseIdentifier(/* liberal */ true);\n        default:\n          return super.parseBindingAtom();\n      }\n    }\n\n    // parse function type parameters - function foo<T>() {}\n    parseFunctionParams(\n      node: Undone<N.Function>,\n      isConstructor: boolean,\n    ): void {\n      // @ts-expect-error kind may not index node\n      const kind = node.kind;\n      if (kind !== \"get\" && kind !== \"set\" && this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n      super.parseFunctionParams(node, isConstructor);\n    }\n\n    // parse flow type annotations on variable declarator heads - let foo: string = bar\n    parseVarId(\n      decl: N.VariableDeclarator,\n      kind: \"var\" | \"let\" | \"const\",\n    ): void {\n      super.parseVarId(decl, kind);\n      if (this.match(tt.colon)) {\n        decl.id.typeAnnotation = this.flowParseTypeAnnotation();\n        this.resetEndLocation(decl.id); // set end position to end of type\n      }\n    }\n\n    // parse the return type of an async arrow function - let foo = (async (): number => {});\n    parseAsyncArrowFromCallExpression(\n      node: N.ArrowFunctionExpression,\n      call: N.CallExpression,\n    ): N.ArrowFunctionExpression {\n      if (this.match(tt.colon)) {\n        const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n        this.state.noAnonFunctionType = true;\n        node.returnType = this.flowParseTypeAnnotation();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n      }\n\n      return super.parseAsyncArrowFromCallExpression(node, call);\n    }\n\n    // todo description\n    shouldParseAsyncArrow(): boolean {\n      return this.match(tt.colon) || super.shouldParseAsyncArrow();\n    }\n\n    // We need to support type parameter declarations for arrow functions. This\n    // is tricky. There are three situations we need to handle\n    //\n    // 1. This is either JSX or an arrow function. We'll try JSX first. If that\n    //    fails, we'll try an arrow function. If that fails, we'll throw the JSX\n    //    error.\n    // 2. This is an arrow function. We'll parse the type parameter declaration,\n    //    parse the rest, make sure the rest is an arrow function, and go from\n    //    there\n    // 3. This is neither. Just call the super method\n    parseMaybeAssign(\n      refExpressionErrors?: ExpressionErrors | null,\n      afterLeftParse?: Function,\n    ): N.Expression {\n      let state = null;\n\n      let jsx;\n\n      if (\n        this.hasPlugin(\"jsx\") &&\n        (this.match(tt.jsxTagStart) || this.match(tt.lt))\n      ) {\n        state = this.state.clone();\n\n        jsx = this.tryParse(\n          () => super.parseMaybeAssign(refExpressionErrors, afterLeftParse),\n          state,\n        );\n\n        /*:: invariant(!jsx.aborted) */\n        /*:: invariant(jsx.node != null) */\n        if (!jsx.error) return jsx.node;\n\n        // Remove `tc.j_expr` and `tc.j_oTag` from context added\n        // by parsing `jsxTagStart` to stop the JSX plugin from\n        // messing with the tokens\n        const { context } = this.state;\n        const currentContext = context[context.length - 1];\n        if (currentContext === tc.j_oTag || currentContext === tc.j_expr) {\n          context.pop();\n        }\n      }\n\n      if (jsx?.error || this.match(tt.lt)) {\n        state = state || this.state.clone();\n\n        let typeParameters: N.TypeParameterDeclaration;\n\n        const arrow = this.tryParse((abort: () => never) => {\n          typeParameters = this.flowParseTypeParameterDeclaration();\n\n          const arrowExpression = this.forwardNoArrowParamsConversionAt(\n            typeParameters,\n            () => {\n              const result = super.parseMaybeAssign(\n                refExpressionErrors,\n                afterLeftParse,\n              );\n\n              this.resetStartLocationFromNode(result, typeParameters);\n\n              return result;\n            },\n          );\n\n          // <T>(() => {});\n          // <T>(() => {}: any);\n          if (arrowExpression.extra?.parenthesized) abort();\n\n          // The above can return a TypeCastExpression when the arrow\n          // expression is not wrapped in parens. See also `this.parseParenItem`.\n          // (<T>() => {}: any);\n          const expr = this.maybeUnwrapTypeCastExpression(arrowExpression);\n\n          if (expr.type !== \"ArrowFunctionExpression\") abort();\n\n          expr.typeParameters = typeParameters;\n          this.resetStartLocationFromNode(expr, typeParameters);\n\n          return arrowExpression;\n        }, state);\n\n        let arrowExpression:\n          | N.ArrowFunctionExpression\n          | N.TypeCastExpression\n          | undefined\n          | null = null;\n\n        if (\n          arrow.node &&\n          this.maybeUnwrapTypeCastExpression(arrow.node).type ===\n            \"ArrowFunctionExpression\"\n        ) {\n          if (!arrow.error && !arrow.aborted) {\n            // <T> async () => {}\n            // @ts-expect-error: refine tryParse typings\n            if (arrow.node.async) {\n              /*:: invariant(typeParameters) */\n              this.raise(\n                FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction,\n                typeParameters,\n              );\n            }\n            return arrow.node;\n          }\n\n          // @ts-expect-error: refine typings\n          arrowExpression = arrow.node;\n        }\n\n        // If we are here, both JSX and Flow parsing attempts failed.\n        // Give the precedence to the JSX error, except if JSX had an\n        // unrecoverable error while Flow didn't.\n        // If the error is recoverable, we can only re-report it if there is\n        // a node we can return.\n\n        if (jsx?.node) {\n          /*:: invariant(jsx.failState) */\n          this.state = jsx.failState;\n          return jsx.node;\n        }\n\n        if (arrowExpression) {\n          /*:: invariant(arrow.failState) */\n          this.state = arrow.failState;\n          return arrowExpression;\n        }\n\n        if (jsx?.thrown) throw jsx.error;\n        if (arrow.thrown) throw arrow.error;\n\n        /*:: invariant(typeParameters) */\n        throw this.raise(\n          FlowErrors.UnexpectedTokenAfterTypeParameter,\n          typeParameters,\n        );\n      }\n\n      return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n    }\n\n    // handle return types for arrow functions\n    parseArrow(\n      node: Undone<N.ArrowFunctionExpression>,\n    ): Undone<N.ArrowFunctionExpression> | undefined | null {\n      if (this.match(tt.colon)) {\n        // @ts-expect-error todo(flow->ts)\n        const result = this.tryParse<N.TypeAnnotation>(() => {\n          const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n          this.state.noAnonFunctionType = true;\n\n          const typeNode = this.startNode<N.TypeAnnotation>();\n\n          [\n            typeNode.typeAnnotation,\n            // @ts-expect-error (destructuring not supported yet)\n            node.predicate,\n          ] = this.flowParseTypeAndPredicateInitialiser();\n\n          this.state.noAnonFunctionType = oldNoAnonFunctionType;\n\n          if (this.canInsertSemicolon()) this.unexpected();\n          if (!this.match(tt.arrow)) this.unexpected();\n\n          return typeNode;\n        });\n\n        if (result.thrown) return null;\n        /*:: invariant(result.node) */\n\n        if (result.error) this.state = result.failState;\n\n        // assign after it is clear it is an arrow\n        // @ts-expect-error todo(flow->ts)\n        node.returnType = result.node.typeAnnotation\n          ? this.finishNode(result.node, \"TypeAnnotation\")\n          : null;\n      }\n\n      return super.parseArrow(node);\n    }\n\n    shouldParseArrow(params: Array<N.Node>): boolean {\n      return this.match(tt.colon) || super.shouldParseArrow(params);\n    }\n\n    setArrowFunctionParameters(\n      node: Undone<N.ArrowFunctionExpression>,\n      params:\n        | Array<N.Expression | N.SpreadElement>\n        | Array<N.Expression | N.RestElement>,\n    ): void {\n      if (\n        this.state.noArrowParamsConversionAt.includes(\n          this.offsetToSourcePos(node.start),\n        )\n      ) {\n        node.params = params as N.ArrowFunctionExpression[\"params\"];\n      } else {\n        super.setArrowFunctionParameters(node, params);\n      }\n    }\n\n    checkParams(\n      node: N.Function,\n      allowDuplicates: boolean,\n      isArrowFunction?: boolean | null,\n      strictModeChanged: boolean = true,\n    ): void {\n      if (\n        isArrowFunction &&\n        this.state.noArrowParamsConversionAt.includes(\n          this.offsetToSourcePos(node.start),\n        )\n      ) {\n        return;\n      }\n\n      // ensure the `this` param is first, if it exists\n      for (let i = 0; i < node.params.length; i++) {\n        if (this.isThisParam(node.params[i]) && i > 0) {\n          this.raise(FlowErrors.ThisParamMustBeFirst, node.params[i]);\n        }\n      }\n\n      super.checkParams(\n        node,\n        allowDuplicates,\n        isArrowFunction,\n        strictModeChanged,\n      );\n    }\n\n    parseParenAndDistinguishExpression(canBeArrow: boolean): N.Expression {\n      return super.parseParenAndDistinguishExpression(\n        canBeArrow &&\n          !this.state.noArrowAt.includes(\n            this.sourceToOffsetPos(this.state.start),\n          ),\n      );\n    }\n\n    parseSubscripts(\n      base: N.Expression,\n      startLoc: Position,\n      noCalls?: boolean | null,\n    ): N.Expression {\n      if (\n        base.type === \"Identifier\" &&\n        base.name === \"async\" &&\n        this.state.noArrowAt.includes(startLoc.index)\n      ) {\n        this.next();\n\n        const node = this.startNodeAt<N.CallExpression>(startLoc);\n        node.callee = base;\n        node.arguments = super.parseCallExpressionArguments(tt.parenR);\n        base = this.finishNode(node, \"CallExpression\");\n      } else if (\n        base.type === \"Identifier\" &&\n        base.name === \"async\" &&\n        this.match(tt.lt)\n      ) {\n        const state = this.state.clone();\n        const arrow = this.tryParse(\n          abort => this.parseAsyncArrowWithTypeParameters(startLoc) || abort(),\n          state,\n        );\n\n        /*:: invariant(arrow.node != null) */\n        // @ts-expect-error: refine tryParse typings\n        if (!arrow.error && !arrow.aborted) return arrow.node;\n\n        const result = this.tryParse(\n          () => super.parseSubscripts(base, startLoc, noCalls),\n          state,\n        );\n\n        if (result.node && !result.error) return result.node;\n\n        if (arrow.node) {\n          this.state = arrow.failState;\n          // @ts-expect-error: refine tryParse typings\n          return arrow.node;\n        }\n\n        if (result.node) {\n          this.state = result.failState;\n          return result.node;\n        }\n\n        throw arrow.error || result.error;\n      }\n\n      return super.parseSubscripts(base, startLoc, noCalls);\n    }\n\n    parseSubscript(\n      base: N.Expression,\n\n      startLoc: Position,\n      noCalls: boolean | undefined | null,\n      subscriptState: N.ParseSubscriptState,\n    ): N.Expression {\n      if (this.match(tt.questionDot) && this.isLookaheadToken_lt()) {\n        subscriptState.optionalChainMember = true;\n        if (noCalls) {\n          subscriptState.stop = true;\n          return base;\n        }\n        this.next();\n        const node = this.startNodeAt<N.OptionalCallExpression>(startLoc);\n        node.callee = base;\n        node.typeArguments =\n          this.flowParseTypeParameterInstantiationInExpression();\n        this.expect(tt.parenL);\n        node.arguments = this.parseCallExpressionArguments(tt.parenR);\n        node.optional = true;\n        return this.finishCallExpression(node, /* optional */ true);\n      } else if (\n        !noCalls &&\n        this.shouldParseTypes() &&\n        (this.match(tt.lt) ||\n          // also handles `new C<<T>`\n          this.match(tt.bitShiftL))\n      ) {\n        const node = this.startNodeAt<\n          N.OptionalCallExpression | N.CallExpression\n        >(startLoc);\n        node.callee = base;\n\n        const result = this.tryParse(() => {\n          node.typeArguments =\n            this.flowParseTypeParameterInstantiationCallOrNew();\n          this.expect(tt.parenL);\n          node.arguments = super.parseCallExpressionArguments(tt.parenR);\n          if (subscriptState.optionalChainMember) {\n            (node as Undone<N.OptionalCallExpression>).optional = false;\n          }\n          return this.finishCallExpression(\n            node,\n            subscriptState.optionalChainMember,\n          );\n        });\n\n        if (result.node) {\n          if (result.error) this.state = result.failState;\n          return result.node;\n        }\n      }\n\n      return super.parseSubscript(\n        base,\n\n        startLoc,\n        noCalls,\n        subscriptState,\n      );\n    }\n\n    parseNewCallee(node: N.NewExpression): void {\n      super.parseNewCallee(node);\n\n      let targs = null;\n      if (this.shouldParseTypes() && this.match(tt.lt)) {\n        targs = this.tryParse(() =>\n          this.flowParseTypeParameterInstantiationCallOrNew(),\n        ).node;\n      }\n      node.typeArguments = targs;\n    }\n\n    parseAsyncArrowWithTypeParameters(\n      startLoc: Position,\n    ): N.ArrowFunctionExpression | undefined | null {\n      const node = this.startNodeAt<N.ArrowFunctionExpression>(startLoc);\n      this.parseFunctionParams(node, false);\n      if (!this.parseArrow(node)) return;\n      return super.parseArrowExpression(\n        node,\n        /* params */ undefined,\n        /* isAsync */ true,\n      );\n    }\n\n    readToken_mult_modulo(code: number): void {\n      const next = this.input.charCodeAt(this.state.pos + 1);\n      if (\n        code === charCodes.asterisk &&\n        next === charCodes.slash &&\n        this.state.hasFlowComment\n      ) {\n        this.state.hasFlowComment = false;\n        this.state.pos += 2;\n        this.nextToken();\n        return;\n      }\n\n      super.readToken_mult_modulo(code);\n    }\n\n    readToken_pipe_amp(code: number): void {\n      const next = this.input.charCodeAt(this.state.pos + 1);\n      if (\n        code === charCodes.verticalBar &&\n        next === charCodes.rightCurlyBrace\n      ) {\n        // '|}'\n        this.finishOp(tt.braceBarR, 2);\n        return;\n      }\n\n      super.readToken_pipe_amp(code);\n    }\n\n    parseTopLevel(file: N.File, program: N.Program): N.File {\n      const fileNode = super.parseTopLevel(file, program);\n      if (this.state.hasFlowComment) {\n        this.raise(\n          FlowErrors.UnterminatedFlowComment,\n          this.state.curPosition(),\n        );\n      }\n      return fileNode;\n    }\n\n    skipBlockComment(): N.CommentBlock | undefined {\n      if (this.hasPlugin(\"flowComments\") && this.skipFlowComment()) {\n        if (this.state.hasFlowComment) {\n          throw this.raise(FlowErrors.NestedFlowComment, this.state.startLoc);\n        }\n        this.hasFlowCommentCompletion();\n        const commentSkip = this.skipFlowComment();\n        if (commentSkip) {\n          this.state.pos += commentSkip;\n          this.state.hasFlowComment = true;\n        }\n        return;\n      }\n\n      return super.skipBlockComment(this.state.hasFlowComment ? \"*-/\" : \"*/\");\n    }\n\n    skipFlowComment(): number | false {\n      const { pos } = this.state;\n      let shiftToFirstNonWhiteSpace = 2;\n      while (\n        [charCodes.space, charCodes.tab].includes(\n          // @ts-expect-error testing whether a number is included\n          this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace),\n        )\n      ) {\n        shiftToFirstNonWhiteSpace++;\n      }\n\n      const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);\n      const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);\n\n      if (ch2 === charCodes.colon && ch3 === charCodes.colon) {\n        return shiftToFirstNonWhiteSpace + 2; // check for /*::\n      }\n      if (\n        this.input.slice(\n          shiftToFirstNonWhiteSpace + pos,\n          shiftToFirstNonWhiteSpace + pos + 12,\n        ) === \"flow-include\"\n      ) {\n        return shiftToFirstNonWhiteSpace + 12; // check for /*flow-include\n      }\n      if (ch2 === charCodes.colon && ch3 !== charCodes.colon) {\n        return shiftToFirstNonWhiteSpace; // check for /*:, advance up to :\n      }\n      return false;\n    }\n\n    hasFlowCommentCompletion(): void {\n      const end = this.input.indexOf(\"*/\", this.state.pos);\n      if (end === -1) {\n        throw this.raise(Errors.UnterminatedComment, this.state.curPosition());\n      }\n    }\n\n    // Flow enum parsing\n\n    flowEnumErrorBooleanMemberNotInitialized(\n      loc: Position,\n      {\n        enumName,\n        memberName,\n      }: {\n        enumName: string;\n        memberName: string;\n      },\n    ): void {\n      this.raise(FlowErrors.EnumBooleanMemberNotInitialized, loc, {\n        memberName,\n        enumName,\n      });\n    }\n\n    flowEnumErrorInvalidMemberInitializer(\n      loc: Position,\n      enumContext: EnumContext,\n    ) {\n      return this.raise(\n        !enumContext.explicitType\n          ? FlowErrors.EnumInvalidMemberInitializerUnknownType\n          : enumContext.explicitType === \"symbol\"\n            ? FlowErrors.EnumInvalidMemberInitializerSymbolType\n            : FlowErrors.EnumInvalidMemberInitializerPrimaryType,\n        loc,\n        enumContext,\n      );\n    }\n\n    flowEnumErrorNumberMemberNotInitialized(\n      loc: Position,\n      details: {\n        enumName: string;\n        memberName: string;\n      },\n    ): void {\n      this.raise(FlowErrors.EnumNumberMemberNotInitialized, loc, details);\n    }\n\n    flowEnumErrorStringMemberInconsistentlyInitialized(\n      node: N.Node,\n      details: {\n        enumName: string;\n      },\n    ): void {\n      this.raise(\n        FlowErrors.EnumStringMemberInconsistentlyInitialized,\n        node,\n        details,\n      );\n    }\n\n    flowEnumMemberInit(): EnumMemberInit {\n      const startLoc = this.state.startLoc;\n      const endOfInit = () => this.match(tt.comma) || this.match(tt.braceR);\n      switch (this.state.type) {\n        case tt.num: {\n          const literal = this.parseNumericLiteral(this.state.value);\n          if (endOfInit()) {\n            return { type: \"number\", loc: literal.loc.start, value: literal };\n          }\n          return { type: \"invalid\", loc: startLoc };\n        }\n        case tt.string: {\n          const literal = this.parseStringLiteral(this.state.value);\n          if (endOfInit()) {\n            return { type: \"string\", loc: literal.loc.start, value: literal };\n          }\n          return { type: \"invalid\", loc: startLoc };\n        }\n        case tt._true:\n        case tt._false: {\n          const literal = this.parseBooleanLiteral(this.match(tt._true));\n          if (endOfInit()) {\n            return {\n              type: \"boolean\",\n              loc: literal.loc.start,\n              value: literal,\n            };\n          }\n          return { type: \"invalid\", loc: startLoc };\n        }\n        default:\n          return { type: \"invalid\", loc: startLoc };\n      }\n    }\n\n    flowEnumMemberRaw(): {\n      id: N.Identifier;\n      init: EnumMemberInit;\n    } {\n      const loc = this.state.startLoc;\n      const id = this.parseIdentifier(true);\n      const init = this.eat(tt.eq)\n        ? this.flowEnumMemberInit()\n        : { type: \"none\" as const, loc };\n      return { id, init };\n    }\n\n    flowEnumCheckExplicitTypeMismatch(\n      loc: Position,\n      context: EnumContext,\n      expectedType: EnumExplicitType,\n    ): void {\n      const { explicitType } = context;\n      if (explicitType === null) {\n        return;\n      }\n      if (explicitType !== expectedType) {\n        this.flowEnumErrorInvalidMemberInitializer(loc, context);\n      }\n    }\n\n    flowEnumMembers({\n      enumName,\n      explicitType,\n    }: {\n      enumName: string;\n      explicitType: EnumExplicitType;\n    }): {\n      members: {\n        booleanMembers: Extract<\n          N.FlowEnumMember,\n          { type: \"EnumBooleanMember\" }\n        >[];\n        numberMembers: Extract<\n          N.FlowEnumMember,\n          { type: \"EnumNumberMember\" }\n        >[];\n        stringMembers: Extract<\n          N.FlowEnumMember,\n          { type: \"EnumStringMember\" }\n        >[];\n        defaultedMembers: Extract<\n          N.FlowEnumMember,\n          { type: \"EnumDefaultedMember\" }\n        >[];\n      };\n      hasUnknownMembers: boolean;\n    } {\n      const seenNames = new Set();\n      const members = {\n        // @ts-expect-error: migrate to Babel types\n        booleanMembers: [],\n        // @ts-expect-error: migrate to Babel types\n        numberMembers: [],\n        // @ts-expect-error: migrate to Babel types\n        stringMembers: [],\n        // @ts-expect-error: migrate to Babel types\n        defaultedMembers: [],\n      };\n      let hasUnknownMembers = false;\n      while (!this.match(tt.braceR)) {\n        if (this.eat(tt.ellipsis)) {\n          hasUnknownMembers = true;\n          break;\n        }\n        const memberNode = this.startNode<N.FlowEnumMember>();\n        const { id, init } = this.flowEnumMemberRaw();\n        const memberName = id.name;\n        if (memberName === \"\") {\n          continue;\n        }\n        if (/^[a-z]/.test(memberName)) {\n          this.raise(FlowErrors.EnumInvalidMemberName, id, {\n            memberName,\n            suggestion: memberName[0].toUpperCase() + memberName.slice(1),\n            enumName,\n          });\n        }\n        if (seenNames.has(memberName)) {\n          this.raise(FlowErrors.EnumDuplicateMemberName, id, {\n            memberName,\n            enumName,\n          });\n        }\n        seenNames.add(memberName);\n        const context = { enumName, explicitType, memberName };\n        memberNode.id = id;\n        switch (init.type) {\n          case \"boolean\": {\n            this.flowEnumCheckExplicitTypeMismatch(\n              init.loc,\n              context,\n              \"boolean\",\n            );\n            memberNode.init = init.value;\n            members.booleanMembers.push(\n              this.finishNode(memberNode, \"EnumBooleanMember\"),\n            );\n            break;\n          }\n          case \"number\": {\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"number\");\n            memberNode.init = init.value;\n            members.numberMembers.push(\n              this.finishNode(memberNode, \"EnumNumberMember\"),\n            );\n            break;\n          }\n          case \"string\": {\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"string\");\n            memberNode.init = init.value;\n            members.stringMembers.push(\n              this.finishNode(memberNode, \"EnumStringMember\"),\n            );\n            break;\n          }\n          case \"invalid\": {\n            throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);\n          }\n          case \"none\": {\n            switch (explicitType) {\n              case \"boolean\":\n                this.flowEnumErrorBooleanMemberNotInitialized(\n                  init.loc,\n                  context,\n                );\n                break;\n              case \"number\":\n                this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);\n                break;\n              default:\n                members.defaultedMembers.push(\n                  this.finishNode(memberNode, \"EnumDefaultedMember\"),\n                );\n            }\n          }\n        }\n\n        if (!this.match(tt.braceR)) {\n          this.expect(tt.comma);\n        }\n      }\n      return { members, hasUnknownMembers };\n    }\n\n    flowEnumStringMembers(\n      initializedMembers: Array<N.Node>,\n      defaultedMembers: Array<N.Node>,\n      {\n        enumName,\n      }: {\n        enumName: string;\n      },\n    ): Array<N.Node> {\n      if (initializedMembers.length === 0) {\n        return defaultedMembers;\n      } else if (defaultedMembers.length === 0) {\n        return initializedMembers;\n      } else if (defaultedMembers.length > initializedMembers.length) {\n        for (const member of initializedMembers) {\n          this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {\n            enumName,\n          });\n        }\n        return defaultedMembers;\n      } else {\n        for (const member of defaultedMembers) {\n          this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {\n            enumName,\n          });\n        }\n        return initializedMembers;\n      }\n    }\n\n    flowEnumParseExplicitType({\n      enumName,\n    }: {\n      enumName: string;\n    }): EnumExplicitType {\n      if (!this.eatContextual(tt._of)) return null;\n\n      if (!tokenIsIdentifier(this.state.type)) {\n        throw this.raise(\n          FlowErrors.EnumInvalidExplicitTypeUnknownSupplied,\n          this.state.startLoc,\n          {\n            enumName,\n          },\n        );\n      }\n\n      const { value } = this.state;\n      this.next();\n\n      if (\n        value !== \"boolean\" &&\n        value !== \"number\" &&\n        value !== \"string\" &&\n        value !== \"symbol\"\n      ) {\n        this.raise(FlowErrors.EnumInvalidExplicitType, this.state.startLoc, {\n          enumName,\n          invalidEnumType: value,\n        });\n      }\n\n      return value;\n    }\n\n    flowEnumBody(node: Undone<N.FlowEnumBody>, id: N.Identifier): N.Node {\n      const enumName = id.name;\n      const nameLoc = id.loc.start;\n      const explicitType = this.flowEnumParseExplicitType({ enumName });\n      this.expect(tt.braceL);\n      const { members, hasUnknownMembers } = this.flowEnumMembers({\n        enumName,\n        explicitType,\n      });\n      node.hasUnknownMembers = hasUnknownMembers;\n\n      switch (explicitType) {\n        case \"boolean\":\n          node.explicitType = true;\n          node.members = members.booleanMembers;\n          this.expect(tt.braceR);\n          return this.finishNode(node, \"EnumBooleanBody\");\n        case \"number\":\n          node.explicitType = true;\n          node.members = members.numberMembers;\n          this.expect(tt.braceR);\n          return this.finishNode(node, \"EnumNumberBody\");\n        case \"string\":\n          node.explicitType = true;\n          node.members = this.flowEnumStringMembers(\n            members.stringMembers,\n            members.defaultedMembers,\n            { enumName },\n          );\n          this.expect(tt.braceR);\n          return this.finishNode(node, \"EnumStringBody\");\n        case \"symbol\":\n          node.members = members.defaultedMembers;\n          this.expect(tt.braceR);\n          return this.finishNode(node, \"EnumSymbolBody\");\n        default: {\n          // `explicitType` is `null`\n          const empty = () => {\n            node.members = [];\n            this.expect(tt.braceR);\n            return this.finishNode(node, \"EnumStringBody\");\n          };\n          node.explicitType = false;\n\n          const boolsLen = members.booleanMembers.length;\n          const numsLen = members.numberMembers.length;\n          const strsLen = members.stringMembers.length;\n          const defaultedLen = members.defaultedMembers.length;\n\n          if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {\n            return empty();\n          } else if (!boolsLen && !numsLen) {\n            node.members = this.flowEnumStringMembers(\n              members.stringMembers,\n              members.defaultedMembers,\n              { enumName },\n            );\n            this.expect(tt.braceR);\n            return this.finishNode(node, \"EnumStringBody\");\n          } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {\n            for (const member of members.defaultedMembers) {\n              this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {\n                enumName,\n                memberName: member.id.name,\n              });\n            }\n            node.members = members.booleanMembers;\n            this.expect(tt.braceR);\n            return this.finishNode(node, \"EnumBooleanBody\");\n          } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {\n            for (const member of members.defaultedMembers) {\n              this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {\n                enumName,\n                memberName: member.id.name,\n              });\n            }\n            node.members = members.numberMembers;\n            this.expect(tt.braceR);\n            return this.finishNode(node, \"EnumNumberBody\");\n          } else {\n            this.raise(FlowErrors.EnumInconsistentMemberValues, nameLoc, {\n              enumName,\n            });\n            return empty();\n          }\n        }\n      }\n    }\n\n    flowParseEnumDeclaration(\n      node: Undone<N.FlowEnumDeclaration>,\n    ): N.FlowEnumDeclaration {\n      const id = this.parseIdentifier();\n      node.id = id;\n      node.body = this.flowEnumBody(this.startNode(), id);\n      return this.finishNode(node, \"EnumDeclaration\");\n    }\n\n    jsxParseOpeningElementAfterName(\n      node: N.JSXOpeningElement,\n    ): N.JSXOpeningElement {\n      if (this.shouldParseTypes()) {\n        if (this.match(tt.lt) || this.match(tt.bitShiftL)) {\n          node.typeArguments =\n            this.flowParseTypeParameterInstantiationInExpression();\n        }\n      }\n\n      return super.jsxParseOpeningElementAfterName(node);\n    }\n\n    // check if the next token is a tt.lt\n    isLookaheadToken_lt(): boolean {\n      const next = this.nextTokenStart();\n      if (this.input.charCodeAt(next) === charCodes.lessThan) {\n        const afterNext = this.input.charCodeAt(next + 1);\n        return (\n          afterNext !== charCodes.lessThan && afterNext !== charCodes.equalsTo\n        );\n      }\n      return false;\n    }\n\n    // used after we have finished parsing types\n    reScan_lt_gt() {\n      const { type } = this.state;\n      if (type === tt.lt) {\n        this.state.pos -= 1;\n        this.readToken_lt();\n      } else if (type === tt.gt) {\n        this.state.pos -= 1;\n        this.readToken_gt();\n      }\n    }\n\n    reScan_lt() {\n      const { type } = this.state;\n      if (type === tt.bitShiftL) {\n        this.state.pos -= 2;\n        this.finishOp(tt.lt, 1);\n        return tt.lt;\n      }\n      return type;\n    }\n\n    maybeUnwrapTypeCastExpression(node: N.Node) {\n      return node.type === \"TypeCastExpression\" ? node.expression : node;\n    }\n  };\n"],"mappings":"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","ignoreList":[]}