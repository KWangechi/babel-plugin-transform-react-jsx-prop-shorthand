{"version":3,"names":["_types","require","_parseError","PlaceholderErrors","ParseErrorEnum","ClassNameIsRequired","UnexpectedSpace","_default","superClass","PlaceholdersParserMixin","parsePlaceholder","expectedNode","match","node","startNode","next","assertNoSpace","name","parseIdentifier","expect","finishPlaceholder","placeholder","type","finishNode","getTokenFromCode","code","input","charCodeAt","state","pos","finishOp","parseExprAtom","refExpressionErrors","liberal","checkReservedWord","word","startLoc","checkKeywords","isBinding","undefined","parseBindingAtom","isValidLVal","isParenthesized","binding","toAssignable","isLHS","chStartsBindingIdentifier","ch","nextToken","lookahead","verifyBreakContinue","isBreak","label","parseExpressionStatement","expr","extra","parenthesized","stmt","body","parseStatementOrSloppyAnnexBFunctionDeclaration","semicolon","stmtPlaceholder","parseBlock","allowDirectives","createNewLexicalScope","afterBlockParse","parseFunctionId","requireId","parseClass","isStatement","optionalId","oldStrict","strict","id","raise","parseClassId","parseClassSuper","parseClassBody","parseExport","decorators","node2","isContextual","specifiers","source","declaration","expectPlugin","specifier","exported","isExportDefaultSpecifier","nextTokenStart","isUnparsedContextual","startsWith","tokenLabelName","nextTokenStartSince","maybeParseExportDefaultSpecifier","maybeDefaultIdentifier","length","checkExport","filter","parseImport","startNodeAtNode","local","push","eat","hasStarImport","maybeParseStarImportSpecifier","parseNamedImportSpecifiers","expectContextual","parseImportSource","start","offsetToSourcePos","lastTokEndLoc","index","exports","default"],"sources":["../../src/plugins/placeholders.ts"],"sourcesContent":["import * as charCodes from \"charcodes\";\n\nimport { tokenLabelName, tt } from \"../tokenizer/types.ts\";\nimport type Parser from \"../parser/index.ts\";\nimport type * as N from \"../types.ts\";\nimport { ParseErrorEnum } from \"../parse-error.ts\";\nimport type { Undone } from \"../parser/node.ts\";\nimport type { ExpressionErrors } from \"../parser/util.ts\";\nimport type { BindingFlag } from \"../util/scopeflags.ts\";\nimport type { Position } from \"../util/location.ts\";\n\ntype PossiblePlaceholders = {\n  Identifier: N.Identifier;\n  StringLiteral: N.StringLiteral;\n  Expression: N.Expression;\n  Statement: N.Statement;\n  Declaration: N.Declaration;\n  BlockStatement: N.BlockStatement;\n  ClassBody: N.ClassBody;\n  Pattern: N.Pattern;\n};\nexport type PlaceholderTypes = keyof PossiblePlaceholders;\n\ntype NodeOf<T extends keyof PossiblePlaceholders> = PossiblePlaceholders[T];\n// todo: when there  is proper union type for Node\n// type NodeOf<T extends PlaceholderTypes> = Extract<N.Node, { type: T }>;\n\n// todo: Placeholder<T> breaks everything, because its type is incompatible with\n// the substituted nodes.\ntype MaybePlaceholder<T extends PlaceholderTypes> = NodeOf<T>; // | Placeholder<T>\n\n/* eslint sort-keys: \"error\" */\nconst PlaceholderErrors = ParseErrorEnum`placeholders`({\n  ClassNameIsRequired: \"A class name is required.\",\n  UnexpectedSpace: \"Unexpected space in placeholder.\",\n});\n\nexport default (superClass: typeof Parser) =>\n  class PlaceholdersParserMixin extends superClass implements Parser {\n    parsePlaceholder<T extends PlaceholderTypes>(\n      expectedNode: T,\n    ): /*?N.Placeholder<T>*/ MaybePlaceholder<T> | undefined {\n      if (this.match(tt.placeholder)) {\n        const node = this.startNode<N.Placeholder<T>>();\n        this.next();\n        this.assertNoSpace();\n\n        // We can't use this.parseIdentifier because\n        // we don't want nested placeholders.\n        node.name = super.parseIdentifier(/* liberal */ true);\n\n        this.assertNoSpace();\n        this.expect(tt.placeholder);\n        return this.finishPlaceholder(node, expectedNode);\n      }\n    }\n\n    finishPlaceholder<T extends PlaceholderTypes>(\n      node: Undone<N.Placeholder> | Undone<NodeOf<PlaceholderTypes>>,\n      expectedNode: T,\n    ): /*N.Placeholder<T>*/ MaybePlaceholder<T> {\n      let placeholder = node as unknown as N.Placeholder<T>;\n\n      if (!placeholder.expectedNode || !placeholder.type) {\n        placeholder = this.finishNode(\n          placeholder,\n          \"Placeholder\",\n        ) as unknown as N.Placeholder<T>;\n      }\n\n      placeholder.expectedNode = expectedNode;\n      return placeholder as unknown as MaybePlaceholder<T>;\n    }\n\n    /* ============================================================ *\n     * tokenizer/index.js                                           *\n     * ============================================================ */\n\n    getTokenFromCode(code: number) {\n      if (\n        code === charCodes.percentSign &&\n        this.input.charCodeAt(this.state.pos + 1) === charCodes.percentSign\n      ) {\n        this.finishOp(tt.placeholder, 2);\n      } else {\n        super.getTokenFromCode(code);\n      }\n    }\n\n    /* ============================================================ *\n     * parser/expression.js                                         *\n     * ============================================================ */\n\n    parseExprAtom(\n      refExpressionErrors?: ExpressionErrors | null,\n    ): MaybePlaceholder<\"Expression\"> {\n      return (\n        this.parsePlaceholder(\"Expression\") ||\n        super.parseExprAtom(refExpressionErrors)\n      );\n    }\n\n    parseIdentifier(liberal?: boolean): MaybePlaceholder<\"Identifier\"> {\n      // NOTE: This function only handles identifiers outside of\n      // expressions and binding patterns, since they are already\n      // handled by the parseExprAtom and parseBindingAtom functions.\n      // This is needed, for example, to parse \"class %%NAME%% {}\".\n      return (\n        this.parsePlaceholder(\"Identifier\") || super.parseIdentifier(liberal)\n      );\n    }\n\n    checkReservedWord(\n      word: string,\n      startLoc: Position,\n      checkKeywords: boolean,\n      isBinding: boolean,\n    ) {\n      // Sometimes we call #checkReservedWord(node.name), expecting\n      // that node is an Identifier. If it is a Placeholder, name\n      // will be undefined.\n      if (word !== undefined) {\n        super.checkReservedWord(word, startLoc, checkKeywords, isBinding);\n      }\n    }\n\n    /* ============================================================ *\n     * parser/lval.js                                               *\n     * ============================================================ */\n\n    parseBindingAtom(): MaybePlaceholder<\"Pattern\"> {\n      return this.parsePlaceholder(\"Pattern\") || super.parseBindingAtom();\n    }\n\n    isValidLVal(type: string, isParenthesized: boolean, binding: BindingFlag) {\n      return (\n        type === \"Placeholder\" ||\n        super.isValidLVal(type, isParenthesized, binding)\n      );\n    }\n\n    toAssignable(node: N.Node, isLHS: boolean): void {\n      if (\n        node &&\n        node.type === \"Placeholder\" &&\n        node.expectedNode === \"Expression\"\n      ) {\n        node.expectedNode = \"Pattern\";\n      } else {\n        super.toAssignable(node, isLHS);\n      }\n    }\n\n    /* ============================================================ *\n     * parser/statement.js                                          *\n     * ============================================================ */\n\n    chStartsBindingIdentifier(ch: number, pos: number): boolean {\n      if (super.chStartsBindingIdentifier(ch, pos)) {\n        return true;\n      }\n\n      // Accept \"let %%\" as the start of \"let %%placeholder%%\", as though the\n      // placeholder were an identifier.\n      const nextToken = this.lookahead();\n      if (nextToken.type === tt.placeholder) {\n        return true;\n      }\n\n      return false;\n    }\n\n    verifyBreakContinue(\n      node: N.BreakStatement | N.ContinueStatement,\n      isBreak: boolean,\n    ) {\n      // @ts-expect-error: node.label could be Placeholder\n      if (node.label && node.label.type === \"Placeholder\") return;\n      super.verifyBreakContinue(node, isBreak);\n    }\n\n    // @ts-expect-error Plugin will override parser interface\n    parseExpressionStatement(\n      node: MaybePlaceholder<\"Statement\">,\n      expr: MaybePlaceholder<\"Expression\">,\n    ): MaybePlaceholder<\"Statement\"> {\n      // @ts-expect-error placeholder typings\n      if (expr.type !== \"Placeholder\" || expr.extra?.parenthesized) {\n        // @ts-expect-error placeholder typings\n        return super.parseExpressionStatement(node, expr);\n      }\n\n      if (this.match(tt.colon)) {\n        // @ts-expect-error placeholder typings\n        const stmt: N.LabeledStatement = node;\n        stmt.label = this.finishPlaceholder(expr, \"Identifier\");\n        this.next();\n        stmt.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration();\n        return this.finishNode(stmt, \"LabeledStatement\");\n      }\n\n      this.semicolon();\n      const stmtPlaceholder = node as unknown as N.Placeholder<\"Statement\">;\n      stmtPlaceholder.name = (expr as N.Placeholder).name;\n      return this.finishPlaceholder(stmtPlaceholder, \"Statement\");\n    }\n\n    parseBlock(\n      allowDirectives?: boolean,\n      createNewLexicalScope?: boolean,\n      afterBlockParse?: (hasStrictModeDirective: boolean) => void,\n    ): MaybePlaceholder<\"BlockStatement\"> {\n      return (\n        this.parsePlaceholder(\"BlockStatement\") ||\n        super.parseBlock(\n          allowDirectives,\n          createNewLexicalScope,\n          afterBlockParse,\n        )\n      );\n    }\n\n    parseFunctionId(\n      requireId?: boolean,\n    ): MaybePlaceholder<\"Identifier\"> | undefined | null {\n      return (\n        this.parsePlaceholder(\"Identifier\") || super.parseFunctionId(requireId)\n      );\n    }\n    // @ts-expect-error Plugin will override parser interface\n    parseClass<T extends N.Class>(\n      node: T,\n      isStatement: /* T === ClassDeclaration */ boolean,\n      optionalId?: boolean,\n    ): T {\n      const type = isStatement ? \"ClassDeclaration\" : \"ClassExpression\";\n\n      this.next();\n      const oldStrict = this.state.strict;\n\n      const placeholder = this.parsePlaceholder(\"Identifier\");\n      if (placeholder) {\n        if (\n          this.match(tt._extends) ||\n          this.match(tt.placeholder) ||\n          this.match(tt.braceL)\n        ) {\n          node.id = placeholder;\n        } else if (optionalId || !isStatement) {\n          node.id = null;\n          node.body = this.finishPlaceholder(placeholder, \"ClassBody\");\n          return this.finishNode(node, type);\n        } else {\n          throw this.raise(\n            PlaceholderErrors.ClassNameIsRequired,\n            this.state.startLoc,\n          );\n        }\n      } else {\n        this.parseClassId(node, isStatement, optionalId);\n      }\n\n      super.parseClassSuper(node);\n      node.body =\n        this.parsePlaceholder(\"ClassBody\") ||\n        super.parseClassBody(!!node.superClass, oldStrict);\n      return this.finishNode(node, type);\n    }\n\n    parseExport(\n      node: Undone<\n        | N.ExportDefaultDeclaration\n        | N.ExportAllDeclaration\n        | N.ExportNamedDeclaration\n      >,\n      decorators: N.Decorator[] | null,\n    ): N.AnyExport {\n      const placeholder = this.parsePlaceholder(\"Identifier\");\n      if (!placeholder) return super.parseExport(node, decorators);\n\n      const node2 = node as Undone<N.ExportNamedDeclaration>;\n\n      if (!this.isContextual(tt._from) && !this.match(tt.comma)) {\n        // export %%DECL%%;\n        node2.specifiers = [];\n        node2.source = null;\n        node2.declaration = this.finishPlaceholder(placeholder, \"Declaration\");\n        return this.finishNode(node2, \"ExportNamedDeclaration\");\n      }\n\n      // export %%NAME%% from \"foo\";\n      this.expectPlugin(\"exportDefaultFrom\");\n      const specifier = this.startNode<N.ExportDefaultSpecifier>();\n      specifier.exported = placeholder;\n      node2.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n\n      return super.parseExport(node2, decorators);\n    }\n\n    isExportDefaultSpecifier(): boolean {\n      if (this.match(tt._default)) {\n        const next = this.nextTokenStart();\n        if (this.isUnparsedContextual(next, \"from\")) {\n          if (\n            this.input.startsWith(\n              tokenLabelName(tt.placeholder),\n              this.nextTokenStartSince(next + 4),\n            )\n          ) {\n            return true;\n          }\n        }\n      }\n      return super.isExportDefaultSpecifier();\n    }\n\n    maybeParseExportDefaultSpecifier(\n      node: Undone<\n        | N.ExportDefaultDeclaration\n        | N.ExportAllDeclaration\n        | N.ExportNamedDeclaration\n      >,\n      maybeDefaultIdentifier: N.Identifier | null,\n    ): node is Undone<N.ExportNamedDeclaration> {\n      if ((node as N.ExportNamedDeclaration).specifiers?.length) {\n        // \"export %%NAME%%\" has already been parsed by #parseExport.\n        return true;\n      }\n      return super.maybeParseExportDefaultSpecifier(\n        node,\n        maybeDefaultIdentifier,\n      );\n    }\n\n    checkExport(node: N.ExportNamedDeclaration): void {\n      const { specifiers } = node;\n      if (specifiers?.length) {\n        node.specifiers = specifiers.filter(\n          // @ts-expect-error placeholder typings\n          node => node.exported.type === \"Placeholder\",\n        );\n      }\n      super.checkExport(node);\n      node.specifiers = specifiers;\n    }\n\n    parseImport(\n      node: Undone<N.ImportDeclaration>,\n    ): N.ImportDeclaration | N.TsImportEqualsDeclaration {\n      const placeholder = this.parsePlaceholder(\"Identifier\");\n      if (!placeholder) return super.parseImport(node);\n\n      node.specifiers = [];\n\n      if (!this.isContextual(tt._from) && !this.match(tt.comma)) {\n        // import %%STRING%%;\n        node.source = this.finishPlaceholder(placeholder, \"StringLiteral\");\n        this.semicolon();\n        return this.finishNode(node, \"ImportDeclaration\");\n      }\n\n      // import %%DEFAULT%% ...\n      const specifier =\n        this.startNodeAtNode<N.ImportDefaultSpecifier>(placeholder);\n      specifier.local = placeholder;\n      node.specifiers.push(\n        this.finishNode(specifier, \"ImportDefaultSpecifier\"),\n      );\n\n      if (this.eat(tt.comma)) {\n        // import %%DEFAULT%%, * as ...\n        const hasStarImport = this.maybeParseStarImportSpecifier(node);\n\n        // import %%DEFAULT%%, { ...\n        if (!hasStarImport) this.parseNamedImportSpecifiers(node);\n      }\n\n      this.expectContextual(tt._from);\n      node.source = this.parseImportSource();\n      this.semicolon();\n      return this.finishNode(node, \"ImportDeclaration\");\n    }\n\n    parseImportSource(): MaybePlaceholder<\"StringLiteral\"> {\n      // import ... from %%STRING%%;\n\n      return (\n        this.parsePlaceholder(\"StringLiteral\") || super.parseImportSource()\n      );\n    }\n\n    // Throws if the current token and the prev one are separated by a space.\n    assertNoSpace(): void {\n      if (\n        this.state.start >\n        this.offsetToSourcePos(this.state.lastTokEndLoc.index)\n      ) {\n        this.raise(PlaceholderErrors.UnexpectedSpace, this.state.lastTokEndLoc);\n      }\n    }\n  };\n"],"mappings":"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","ignoreList":[]}