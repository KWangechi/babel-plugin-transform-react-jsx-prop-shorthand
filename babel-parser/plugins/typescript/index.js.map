{"version":3,"names":["_types","require","_context","_location","_scopeflags","_scope","_productionParameter","_parseError","_node","_lval","_options","nonNull","x","Error","assert","TSErrors","ParseErrorEnum","AbstractMethodHasImplementation","methodName","AbstractPropertyHasInitializer","propertyName","AccessorCannotBeOptional","AccessorCannotDeclareThisParameter","AccessorCannotHaveTypeParameters","ClassMethodHasDeclare","ClassMethodHasReadonly","ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference","ConstructorHasTypeParameters","DeclareAccessor","kind","DeclareClassFieldHasInitializer","DeclareFunctionHasImplementation","DuplicateAccessibilityModifier","modifier","DuplicateModifier","EmptyHeritageClauseType","token","EmptyTypeArguments","EmptyTypeParameters","ExpectedAmbientAfterExportDeclare","ImportAliasHasImportType","ImportReflectionHasImportType","IncompatibleModifiers","modifiers","IndexSignatureHasAbstract","IndexSignatureHasAccessibility","IndexSignatureHasDeclare","IndexSignatureHasOverride","IndexSignatureHasStatic","InitializerNotAllowedInAmbientContext","InvalidHeritageClauseType","InvalidModifierOnTypeMember","InvalidModifierOnTypeParameter","InvalidModifierOnTypeParameterPositions","InvalidModifiersOrder","orderedModifiers","InvalidPropertyAccessAfterInstantiationExpression","InvalidTupleMemberLabel","MissingInterfaceName","NonAbstractClassHasAbstractMethod","NonClassMethodPropertyHasAbstractModifer","OptionalTypeBeforeRequired","OverrideNotInSubClass","PatternIsOptional","PrivateElementHasAbstract","PrivateElementHasAccessibility","ReadonlyForMethodSignature","ReservedArrowTypeParam","ReservedTypeAssertion","SetAccessorCannotHaveOptionalParameter","SetAccessorCannotHaveRestParameter","SetAccessorCannotHaveReturnType","SingleTypeParameterWithoutTrailingComma","typeParameterName","StaticBlockCannotHaveModifier","TupleOptionalAfterType","TypeAnnotationAfterAssign","TypeImportCannotSpecifyDefaultAndNamed","TypeModifierIsUsedInTypeExports","TypeModifierIsUsedInTypeImports","UnexpectedParameterModifier","UnexpectedReadonly","UnexpectedTypeAnnotation","UnexpectedTypeCastInParameter","UnsupportedImportTypeArgument","UnsupportedParameterPropertyKind","UnsupportedSignatureParameterKind","type","keywordTypeFromName","value","undefined","tsIsAccessModifier","tsIsVarianceAnnotations","tsIsEntityName","node","extra","parenthesized","computed","object","expression","tsParseEntityNameFlags","exports","NONE","ALLOW_RESERVED_WORDS","LEADING_THIS_AS_IDENTIFIER","_default","superClass","TypeScriptParserMixin","getScopeHandler","TypeScriptScopeHandler","tsIsIdentifier","tokenIsIdentifier","state","tsTokenCanFollowModifier","match","isLiteralPropertyName","tsNextTokenOnSameLineAndCanFollowModifier","next","hasPrecedingLineBreak","tsNextTokenCanFollowModifier","tsParseModifier","allowedModifiers","stopOnStartOfClassStaticBlock","includes","tsIsStartOfStaticBlocks","tsTryParse","bind","tsParseModifiers","disallowedModifiers","errorTemplate","modified","enforceOrder","loc","before","after","raise","incompatible","mod1","mod2","startLoc","concat","accessibility","Object","hasOwn","tsIsListTerminator","tsParseList","parseElement","result","push","tsParseDelimitedList","refTrailingCommaPos","tsParseDelimitedListWorker","expectSuccess","trailingCommaPos","element","eat","lastTokStartLoc","index","expect","tsParseBracketedList","bracket","skipFirstToken","tsParseImportType","startNode","process","env","BABEL_8_BREAKING","argument","tsParseNonConditionalType","parseExprAtom","tsParseLiteralTypeNode","parseStringLiteral","options","parseMaybeAssignAllowIn","qualifier","tsParseEntityName","typeArguments","tsParseTypeArguments","typeParameters","finishNode","flags","entity","parseIdentifier","startNodeAtNode","left","right","tsParseTypeReference","typeName","tsParseThisTypePredicate","lhs","parameterName","typeAnnotation","tsParseTypeAnnotation","asserts","tsParseThisTypeNode","tsParseTypeQuery","exprName","tsParseInOutModifiers","tsParseConstModifier","tsParseInOutConstModifiers","tsParseTypeParameter","parseModifiers","name","tsParseTypeParameterName","constraint","tsEatThenParseType","default","tsTryParseTypeParameters","tsParseTypeParameters","unexpected","params","length","addExtra","tsFillSignature","returnToken","signature","returnTokenRequired","paramsKey","returnTypeKey","tsParseBindingListForSignature","tsParseTypeOrTypePredicateAnnotation","list","parseBindingList","ParseBindingListFlags","IS_FUNCTION_PARAMS","pattern","tsParseTypeMemberSemicolon","isLineTerminator","tsParseSignatureMember","tsIsUnambiguouslyIndexSignature","tsTryParseIndexSignature","tsLookAhead","id","resetEndLocation","parameters","tsTryParseTypeAnnotation","tsParsePropertyOrMethodSignature","readonly","optional","nodeAny","method","curPosition","Errors","BadGetterArity","isThisParam","BadSetterArity","firstParameter","property","tsParseTypeMember","key","createIdentifier","idx","parsePropertyName","tsParseTypeLiteral","members","tsParseObjectTypeMembers","tsIsStartOfMappedType","isContextual","tsParseMappedType","expectContextual","eatContextual","tsExpectThenParseType","typeParameter","nameType","tsParseType","tsTryParseType","semicolon","tsParseTupleType","elementTypes","tsParseTupleElementType","seenOptionalElement","forEach","elementNode","restStartLoc","rest","labeled","label","isWord","tokenIsKeywordOrIdentifier","chAfterWord","lookaheadCharCode","wordName","typeOrLabel","tsParseNonArrayType","startNodeAt","labeledNode","elementType","optionalTypeNode","restNode","tsParseParenthesizedType","tsParseFunctionOrConstructorType","abstract","tsInAllowConditionalTypesContext","literal","tsParseTemplateLiteralType","curElt","parseTemplateElement","quasis","tail","expressions","substitutions","readTemplateContinuation","types","parseTemplate","parseTemplateSubstitution","inType","tsParseThisTypeOrThisTypePredicate","thisKeyword","nextToken","lookahead","parseMaybeUnary","optionFlags","OptionFlags","CreateParenthesizedExpressions","nodeType","tsParseArrayTypeOrHigher","objectType","indexType","tsParseTypeOperator","operator","tsParseTypeOperatorOrHigher","tsCheckTypeAnnotationForReadOnly","tsParseInferType","tsParseConstraintForInferType","tsInDisallowConditionalTypesContext","inDisallowConditionalTypesContext","isTypeOperator","tokenIsTSTypeOperator","containsEsc","tsParseUnionOrIntersectionType","parseConstituentType","hasLeadingOperator","tsParseIntersectionTypeOrHigher","tsParseUnionTypeOrHigher","tsIsStartOfFunctionType","tsIsUnambiguouslyStartOfFunctionType","tsSkipParameterStart","errors","previousErrorCount","parseObjectLike","ALLOW_EMPTY","tsInType","t","tsParseTypePredicateAsserts","thisTypePredicate","resetStartLocationFromNode","typePredicateVariable","tsParseTypePredicatePrefix","tsTryParseTypeOrTypePredicateAnnotation","InvalidEscapedReservedWord","reservedWord","eatColon","checkType","extendsType","trueType","falseType","isAbstractConstructorSignature","tsParseTypeAssertion","getPluginOption","tsParseHeritageClause","originalStartLoc","delimitedList","parseExprSubscripts","start","tsParseTypeArgumentsInExpression","tsParseInterfaceDeclaration","properties","hasFollowingLineBreak","declare","checkIdentifier","BindingFlag","TYPE_TS_INTERFACE","extends","body","tsParseTypeAliasDeclaration","TYPE_TS_TYPE","tsInTopLevelContext","cb","curContext","tc","brace","oldContext","context","oldInType","oldInDisallowConditionalTypesContext","tsNextThenParseType","tsParseEnumMember","initializer","tsParseEnumDeclaration","const","TYPE_TS_CONST_ENUM","TYPE_TS_ENUM","tsParseEnumBody","tsParseModuleBlock","scope","enter","ScopeFlag","OTHER","parseBlockOrModuleBlockBody","exit","tsParseModuleOrNamespaceDeclaration","nested","TYPE_TS_NAMESPACE","inner","TS_MODULE","prodParam","ParamKind","PARAM","tsParseAmbientExternalModuleDeclaration","global","tsParseImportEqualsDeclaration","maybeDefaultIdentifier","isExport","TYPE_TS_VALUE_IMPORT","moduleReference","tsParseModuleReference","importKind","tsIsExternalModuleReference","tsParseExternalModuleReference","sawUnambiguousESM","f","clone","res","tsTryParseAndCatch","tryParse","abort","aborted","error","failState","tsTryParseDeclare","nany","startType","tsInAmbientContext","parseFunctionStatement","parseClass","isLookaheadContextual","parseVarStatement","tsParseDeclaration","tsTryParseExportDeclaration","tsParseExpressionStatement","expr","decorators","declaration","mod","tsCheckLineTerminator","tsParseAbstractDeclaration","tsTryParseGenericAsyncArrowFunction","oldMaybeInArrowParameters","maybeInArrowParameters","parseFunctionParams","returnType","parseArrowExpression","reScan_lt","reScan_lt_gt","tsIsDeclarationStart","tokenIsTSDeclarationStart","isExportDefaultSpecifier","parseBindingElement","override","IS_CONSTRUCTOR_PARAMS","parseMaybeDefault","parseFunctionParamType","elt","pp","parameter","isSimpleParameter","tsDisallowOptionalPattern","param","isAmbientContext","setArrowFunctionParameters","trailingCommaLoc","parseFunctionBodyAndFinish","isMethod","bodilessType","registerFunctionStatementId","TYPE_TS_AMBIENT","tsCheckForInvalidTypeCasts","items","toReferencedList","exprList","isInParens","parseArrayLike","close","canBePattern","isTuple","refExpressionErrors","elements","parseSubscript","base","noCalls","canStartJSXElement","nonNullExpression","isOptionalCall","stop","optionalChainMember","missingParenErrorLoc","atPossibleAsyncArrow","asyncArrowFn","tokenIsTemplate","parseTaggedTemplateExpression","callee","arguments","parseCallExpressionArguments","finishCallExpression","tokenType","tokenCanStartExpression","parseNewCallee","parseExprOp","leftStartLoc","minPrec","isSatisfies","tokenOperatorPrecedence","UnexpectedKeyword","keyword","checkReservedWord","word","checkKeywords","isBinding","checkImportReflection","module","specifiers","checkDuplicateExports","isPotentialImportPhase","ch","applyImportPhase","phase","exportKind","parseImport","importNode","parseMaybeImportPhase","parseImportSpecifiersAndAfter","parseExport","nodeImportEquals","assign","parseExpression","decl","isAbstractClass","parseExportDefaultExpression","cls","allowMissingInitializer","init","declarations","isValidAmbientConstInitializer","hasPlugin","parseStatementContent","parseAccessModifier","tsHasSomeModifiers","member","some","parseClassMember","classBody","callParseClassMemberWithIsStatic","parseClassStaticBlock","parseClassMemberWithIsStatic","static","isStatic","inAbstractClass","hadSuperClass","parsePostMemberNameModifiers","methodOrProp","parseExpressionStatement","shouldParseExportDeclaration","parseConditional","nextCh","setOptionalParametersError","parseParenItem","newNode","typeCastNode","parseExportDeclaration","isDeclare","isIdentifier","resetStartLocation","parseClassId","isStatement","optionalId","bindingType","TYPE_CLASS","parseClassPropertyAnnotation","definite","parseClassProperty","input","slice","offsetToSourcePos","end","parseClassPrivateProperty","parseClassAccessorProperty","pushClassMethod","isGenerator","isAsync","isConstructor","allowsDirectSuper","pushClassPrivateMethod","declareClassPrivateMethodInScope","parseClassSuper","superTypeArguments","superTypeParameters","implements","parseObjPropValue","prop","isPattern","isAccessor","parseVarId","parseAsyncArrowFromCallExpression","call","parseMaybeAssign","afterLeftParse","jsx","typeCast","currentContext","j_oTag","j_expr","pop","arrow","trailingComma","createPositionWithColumnOffset","reportReservedArrowTypeParam","sawUnary","parseArrow","canInsertSemicolon","thrown","isAssignable","toAssignable","isLHS","toAssignableParenthesizedExpression","expressionScope","recordArrowParameterBindingError","typeCastToParameter","checkToRestConversion","allowPattern","isValidLVal","isUnparenthesizedInAssign","binding","TYPE_NONE","parseBindingAtom","parseMaybeDecoratorArguments","checkCommaAfterRest","isClassMethod","isClassProperty","getTokenFromCode","code","finishOp","pos","readToken_lt","readToken_gt","toAssignableListItem","shouldParseArrow","every","shouldParseAsyncArrow","canHaveLeadingDecorator","jsxParseOpeningElementAfterName","getGetterSetterExpectedParamCount","baseCount","getObjectOrClassMethodParams","firstParam","hasContextParam","parseCatchClauseParam","oldIsAmbientContext","strict","oldStrict","oldInAbstractClass","maybeTakeDecorators","parseMethod","allowDirectSuper","inClassScope","hasEstreePlugin","methodFn","shouldParseAsAmbientContext","parse","getExpression","parseExportSpecifier","isString","isInTypeExport","isMaybeTypeOnly","parseTypeOnlyImportExportSpecifier","parseImportSpecifier","specifier","importedIsString","isInTypeOnlyImport","TYPE_TS_TYPE_IMPORT","isImport","isInTypeOnlyImportExport","leftOfAsKey","rightOfAsKey","leftOfAs","rightOfAs","hasTypeSpecifier","canParseAsKeyword","firstAs","secondAs","parseModuleExportName","kindKey","cloneIdentifier","isPossiblyLiteralEnum","isUncomputedMemberExpressionChain","estree","isNumber","isNegativeNumber"],"sources":["../../../src/plugins/typescript/index.ts"],"sourcesContent":["import type State from \"../../tokenizer/state.ts\";\nimport {\n  tokenIsIdentifier,\n  tokenIsTSDeclarationStart,\n  tokenIsTSTypeOperator,\n  tokenOperatorPrecedence,\n  tokenIsKeywordOrIdentifier,\n  tt,\n  type TokenType,\n  tokenIsTemplate,\n  tokenCanStartExpression,\n} from \"../../tokenizer/types.ts\";\nimport { types as tc } from \"../../tokenizer/context.ts\";\nimport type * as N from \"../../types.ts\";\nimport type { Position } from \"../../util/location.ts\";\nimport { createPositionWithColumnOffset } from \"../../util/location.ts\";\nimport type Parser from \"../../parser/index.ts\";\nimport { ScopeFlag, BindingFlag } from \"../../util/scopeflags.ts\";\nimport TypeScriptScopeHandler from \"./scope.ts\";\nimport * as charCodes from \"charcodes\";\nimport type { ExpressionErrors } from \"../../parser/util.ts\";\nimport type { ParseStatementFlag } from \"../../parser/statement.ts\";\nimport { ParamKind } from \"../../util/production-parameter.ts\";\nimport { Errors, ParseErrorEnum } from \"../../parse-error.ts\";\nimport { cloneIdentifier, type Undone } from \"../../parser/node.ts\";\nimport type { Pattern } from \"../../types.ts\";\nimport type { ClassWithMixin, IJSXParserMixin } from \"../jsx/index.ts\";\nimport { ParseBindingListFlags } from \"../../parser/lval.ts\";\nimport { OptionFlags } from \"../../options.ts\";\n\ntype TsModifier =\n  | \"readonly\"\n  | \"abstract\"\n  | \"declare\"\n  | \"static\"\n  | \"override\"\n  | \"const\"\n  | N.Accessibility\n  | N.VarianceAnnotations;\n\nfunction nonNull<T>(x?: T | null): T {\n  if (x == null) {\n    throw new Error(`Unexpected ${x} value.`);\n  }\n  return x;\n}\n\nfunction assert(x: boolean): void {\n  if (!x) {\n    throw new Error(\"Assert fail\");\n  }\n}\n\ntype ParsingContext =\n  | \"EnumMembers\"\n  | \"HeritageClauseElement\"\n  | \"TupleElementTypes\"\n  | \"TypeMembers\"\n  | \"TypeParametersOrArguments\";\n\ntype ModifierBase = {\n  accessibility?: N.Accessibility;\n} & {\n  [key in TsModifier]?: boolean | undefined | null;\n};\n\n/* eslint sort-keys: \"error\" */\nconst TSErrors = ParseErrorEnum`typescript`({\n  AbstractMethodHasImplementation: ({ methodName }: { methodName: string }) =>\n    `Method '${methodName}' cannot have an implementation because it is marked abstract.`,\n  AbstractPropertyHasInitializer: ({\n    propertyName,\n  }: {\n    propertyName: string;\n  }) =>\n    `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,\n  AccessorCannotBeOptional:\n    \"An 'accessor' property cannot be declared optional.\",\n  AccessorCannotDeclareThisParameter:\n    \"'get' and 'set' accessors cannot declare 'this' parameters.\",\n  AccessorCannotHaveTypeParameters: \"An accessor cannot have type parameters.\",\n  ClassMethodHasDeclare: \"Class methods cannot have the 'declare' modifier.\",\n  ClassMethodHasReadonly: \"Class methods cannot have the 'readonly' modifier.\",\n  ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference:\n    \"A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.\",\n  ConstructorHasTypeParameters:\n    \"Type parameters cannot appear on a constructor declaration.\",\n  DeclareAccessor: ({ kind }: { kind: \"get\" | \"set\" }) =>\n    `'declare' is not allowed in ${kind}ters.`,\n  DeclareClassFieldHasInitializer:\n    \"Initializers are not allowed in ambient contexts.\",\n  DeclareFunctionHasImplementation:\n    \"An implementation cannot be declared in ambient contexts.\",\n  DuplicateAccessibilityModifier:\n    // `Accessibility modifier already seen: ${modifier}` would be more helpful.\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    ({ modifier }: { modifier: N.Accessibility }) =>\n      `Accessibility modifier already seen.`,\n  DuplicateModifier: ({ modifier }: { modifier: TsModifier }) =>\n    `Duplicate modifier: '${modifier}'.`,\n  // `token` matches the terminology used by typescript:\n  // https://github.com/microsoft/TypeScript/blob/main/src/compiler/types.ts#L2915\n  EmptyHeritageClauseType: ({ token }: { token: \"extends\" | \"implements\" }) =>\n    `'${token}' list cannot be empty.`,\n  EmptyTypeArguments: \"Type argument list cannot be empty.\",\n  EmptyTypeParameters: \"Type parameter list cannot be empty.\",\n  ExpectedAmbientAfterExportDeclare:\n    \"'export declare' must be followed by an ambient declaration.\",\n  ImportAliasHasImportType: \"An import alias can not use 'import type'.\",\n  ImportReflectionHasImportType:\n    \"An `import module` declaration can not use `type` modifier\",\n  IncompatibleModifiers: ({\n    modifiers,\n  }: {\n    modifiers: [TsModifier, TsModifier];\n  }) =>\n    `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,\n  IndexSignatureHasAbstract:\n    \"Index signatures cannot have the 'abstract' modifier.\",\n  IndexSignatureHasAccessibility: ({\n    modifier,\n  }: {\n    modifier: N.Accessibility;\n  }) =>\n    `Index signatures cannot have an accessibility modifier ('${modifier}').`,\n  IndexSignatureHasDeclare:\n    \"Index signatures cannot have the 'declare' modifier.\",\n  IndexSignatureHasOverride:\n    \"'override' modifier cannot appear on an index signature.\",\n  IndexSignatureHasStatic:\n    \"Index signatures cannot have the 'static' modifier.\",\n  InitializerNotAllowedInAmbientContext:\n    \"Initializers are not allowed in ambient contexts.\",\n  InvalidHeritageClauseType: ({ token }: { token: \"extends\" | \"implements\" }) =>\n    `'${token}' list can only include identifiers or qualified-names with optional type arguments.`,\n  InvalidModifierOnTypeMember: ({ modifier }: { modifier: TsModifier }) =>\n    `'${modifier}' modifier cannot appear on a type member.`,\n  InvalidModifierOnTypeParameter: ({ modifier }: { modifier: TsModifier }) =>\n    `'${modifier}' modifier cannot appear on a type parameter.`,\n  InvalidModifierOnTypeParameterPositions: ({\n    modifier,\n  }: {\n    modifier: TsModifier;\n  }) =>\n    `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,\n  InvalidModifiersOrder: ({\n    orderedModifiers,\n  }: {\n    orderedModifiers: [TsModifier, TsModifier];\n  }) =>\n    `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,\n  InvalidPropertyAccessAfterInstantiationExpression:\n    \"Invalid property access after an instantiation expression. \" +\n    \"You can either wrap the instantiation expression in parentheses, or delete the type arguments.\",\n  InvalidTupleMemberLabel:\n    \"Tuple members must be labeled with a simple identifier.\",\n  MissingInterfaceName:\n    \"'interface' declarations must be followed by an identifier.\",\n  NonAbstractClassHasAbstractMethod:\n    \"Abstract methods can only appear within an abstract class.\",\n  NonClassMethodPropertyHasAbstractModifer:\n    \"'abstract' modifier can only appear on a class, method, or property declaration.\",\n  OptionalTypeBeforeRequired:\n    \"A required element cannot follow an optional element.\",\n  OverrideNotInSubClass:\n    \"This member cannot have an 'override' modifier because its containing class does not extend another class.\",\n  PatternIsOptional:\n    \"A binding pattern parameter cannot be optional in an implementation signature.\",\n  PrivateElementHasAbstract:\n    \"Private elements cannot have the 'abstract' modifier.\",\n  PrivateElementHasAccessibility: ({\n    modifier,\n  }: {\n    modifier: N.Accessibility;\n  }) =>\n    `Private elements cannot have an accessibility modifier ('${modifier}').`,\n  ReadonlyForMethodSignature:\n    \"'readonly' modifier can only appear on a property declaration or index signature.\",\n  ReservedArrowTypeParam:\n    \"This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.\",\n  ReservedTypeAssertion:\n    \"This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.\",\n  SetAccessorCannotHaveOptionalParameter:\n    \"A 'set' accessor cannot have an optional parameter.\",\n  SetAccessorCannotHaveRestParameter:\n    \"A 'set' accessor cannot have rest parameter.\",\n  SetAccessorCannotHaveReturnType:\n    \"A 'set' accessor cannot have a return type annotation.\",\n  SingleTypeParameterWithoutTrailingComma: ({\n    typeParameterName,\n  }: {\n    typeParameterName: string;\n  }) =>\n    `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,\n  StaticBlockCannotHaveModifier:\n    \"Static class blocks cannot have any modifier.\",\n  TupleOptionalAfterType:\n    \"A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).\",\n  TypeAnnotationAfterAssign:\n    \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.\",\n  TypeImportCannotSpecifyDefaultAndNamed:\n    \"A type-only import can specify a default import or named bindings, but not both.\",\n  TypeModifierIsUsedInTypeExports:\n    \"The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.\",\n  TypeModifierIsUsedInTypeImports:\n    \"The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.\",\n  UnexpectedParameterModifier:\n    \"A parameter property is only allowed in a constructor implementation.\",\n  UnexpectedReadonly:\n    \"'readonly' type modifier is only permitted on array and tuple literal types.\",\n  UnexpectedTypeAnnotation: \"Did not expect a type annotation here.\",\n  UnexpectedTypeCastInParameter: \"Unexpected type cast in parameter position.\",\n  UnsupportedImportTypeArgument:\n    \"Argument in a type import must be a string literal.\",\n  UnsupportedParameterPropertyKind:\n    \"A parameter property may not be declared using a binding pattern.\",\n  UnsupportedSignatureParameterKind: ({ type }: { type: string }) =>\n    `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`,\n});\n\n/* eslint-disable sort-keys */\n\n// Doesn't handle \"void\" or \"null\" because those are keywords, not identifiers.\n// It also doesn't handle \"intrinsic\", since usually it's not a keyword.\nfunction keywordTypeFromName(value: string): N.TsKeywordTypeType | undefined {\n  switch (value) {\n    case \"any\":\n      return \"TSAnyKeyword\";\n    case \"boolean\":\n      return \"TSBooleanKeyword\";\n    case \"bigint\":\n      return \"TSBigIntKeyword\";\n    case \"never\":\n      return \"TSNeverKeyword\";\n    case \"number\":\n      return \"TSNumberKeyword\";\n    case \"object\":\n      return \"TSObjectKeyword\";\n    case \"string\":\n      return \"TSStringKeyword\";\n    case \"symbol\":\n      return \"TSSymbolKeyword\";\n    case \"undefined\":\n      return \"TSUndefinedKeyword\";\n    case \"unknown\":\n      return \"TSUnknownKeyword\";\n    default:\n      return undefined;\n  }\n}\n\nfunction tsIsAccessModifier(modifier: string): modifier is N.Accessibility {\n  return (\n    modifier === \"private\" || modifier === \"public\" || modifier === \"protected\"\n  );\n}\n\nfunction tsIsVarianceAnnotations(\n  modifier: string,\n): modifier is N.VarianceAnnotations {\n  return modifier === \"in\" || modifier === \"out\";\n}\n\nfunction tsIsEntityName(\n  node: N.Expression,\n): node is N.MemberExpression | N.Identifier | N.TsInstantiationExpression {\n  if (node.extra?.parenthesized) {\n    return false;\n  }\n  switch (node.type) {\n    case \"Identifier\":\n      return true;\n    case \"MemberExpression\":\n      return !node.computed && tsIsEntityName(node.object);\n    case \"TSInstantiationExpression\":\n      return tsIsEntityName(node.expression);\n    default:\n      return false;\n  }\n}\n\nexport const enum tsParseEntityNameFlags {\n  NONE = 0b00,\n  ALLOW_RESERVED_WORDS = 0b01,\n  LEADING_THIS_AS_IDENTIFIER = 0b10,\n}\n\nexport default (superClass: ClassWithMixin<typeof Parser, IJSXParserMixin>) =>\n  class TypeScriptParserMixin extends superClass implements Parser {\n    getScopeHandler(): new (...args: any) => TypeScriptScopeHandler {\n      return TypeScriptScopeHandler;\n    }\n\n    tsIsIdentifier(): boolean {\n      // TODO: actually a bit more complex in TypeScript, but shouldn't matter.\n      // See https://github.com/Microsoft/TypeScript/issues/15008\n      return tokenIsIdentifier(this.state.type);\n    }\n\n    tsTokenCanFollowModifier() {\n      return (\n        this.match(tt.bracketL) ||\n        this.match(tt.braceL) ||\n        this.match(tt.star) ||\n        this.match(tt.ellipsis) ||\n        this.match(tt.privateName) ||\n        this.isLiteralPropertyName()\n      );\n    }\n\n    tsNextTokenOnSameLineAndCanFollowModifier() {\n      this.next();\n      if (this.hasPrecedingLineBreak()) {\n        return false;\n      }\n      return this.tsTokenCanFollowModifier();\n    }\n\n    tsNextTokenCanFollowModifier() {\n      // Note: TypeScript's implementation is much more complicated because\n      // more things are considered modifiers there.\n      // This implementation only handles modifiers not handled by @babel/parser itself. And \"static\".\n      if (this.match(tt._static)) {\n        this.next();\n        return this.tsTokenCanFollowModifier();\n      }\n      return this.tsNextTokenOnSameLineAndCanFollowModifier();\n    }\n\n    /** Parses a modifier matching one the given modifier names. */\n    tsParseModifier<T extends TsModifier>(\n      allowedModifiers: T[],\n      stopOnStartOfClassStaticBlock?: boolean,\n    ): T | undefined | null {\n      if (\n        !tokenIsIdentifier(this.state.type) &&\n        this.state.type !== tt._in &&\n        this.state.type !== tt._const\n      ) {\n        return undefined;\n      }\n\n      const modifier = this.state.value;\n      if (allowedModifiers.includes(modifier)) {\n        if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {\n          return undefined;\n        }\n        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {\n          return modifier;\n        }\n      }\n      return undefined;\n    }\n\n    /** Parses a list of modifiers, in any order.\n     *  If you need a specific order, you must call this function multiple times:\n     *    this.tsParseModifiers({ modified: node, allowedModifiers: [\"public\"] });\n     *    this.tsParseModifiers({ modified: node, allowedModifiers: [\"abstract\", \"readonly\"] });\n     */\n    tsParseModifiers<N extends ModifierBase>(\n      {\n        allowedModifiers,\n        disallowedModifiers,\n        stopOnStartOfClassStaticBlock,\n        errorTemplate = TSErrors.InvalidModifierOnTypeMember,\n      }: {\n        allowedModifiers: readonly TsModifier[];\n        disallowedModifiers?: TsModifier[];\n        stopOnStartOfClassStaticBlock?: boolean;\n        errorTemplate?: typeof TSErrors.InvalidModifierOnTypeMember;\n      },\n      modified: N,\n    ): void {\n      const enforceOrder = (\n        loc: Position,\n        modifier: TsModifier,\n        before: TsModifier,\n        after: TsModifier,\n      ) => {\n        if (modifier === before && modified[after]) {\n          this.raise(TSErrors.InvalidModifiersOrder, loc, {\n            orderedModifiers: [before, after],\n          });\n        }\n      };\n      const incompatible = (\n        loc: Position,\n        modifier: TsModifier,\n        mod1: TsModifier,\n        mod2: TsModifier,\n      ) => {\n        if (\n          (modified[mod1] && modifier === mod2) ||\n          (modified[mod2] && modifier === mod1)\n        ) {\n          this.raise(TSErrors.IncompatibleModifiers, loc, {\n            modifiers: [mod1, mod2],\n          });\n        }\n      };\n\n      for (;;) {\n        const { startLoc } = this.state;\n        const modifier: TsModifier | undefined | null = this.tsParseModifier(\n          allowedModifiers.concat(disallowedModifiers ?? []),\n          stopOnStartOfClassStaticBlock,\n        );\n\n        if (!modifier) break;\n\n        if (tsIsAccessModifier(modifier)) {\n          if (modified.accessibility) {\n            this.raise(TSErrors.DuplicateAccessibilityModifier, startLoc, {\n              modifier,\n            });\n          } else {\n            enforceOrder(startLoc, modifier, modifier, \"override\");\n            enforceOrder(startLoc, modifier, modifier, \"static\");\n            enforceOrder(startLoc, modifier, modifier, \"readonly\");\n\n            modified.accessibility = modifier;\n          }\n        } else if (tsIsVarianceAnnotations(modifier)) {\n          if (modified[modifier]) {\n            this.raise(TSErrors.DuplicateModifier, startLoc, { modifier });\n          }\n          modified[modifier] = true;\n\n          enforceOrder(startLoc, modifier, \"in\", \"out\");\n        } else {\n          if (Object.hasOwn(modified, modifier)) {\n            this.raise(TSErrors.DuplicateModifier, startLoc, { modifier });\n          } else {\n            enforceOrder(startLoc, modifier, \"static\", \"readonly\");\n            enforceOrder(startLoc, modifier, \"static\", \"override\");\n            enforceOrder(startLoc, modifier, \"override\", \"readonly\");\n            enforceOrder(startLoc, modifier, \"abstract\", \"override\");\n\n            incompatible(startLoc, modifier, \"declare\", \"override\");\n            incompatible(startLoc, modifier, \"static\", \"abstract\");\n          }\n          modified[modifier] = true;\n        }\n\n        if (disallowedModifiers?.includes(modifier)) {\n          this.raise(errorTemplate, startLoc, {\n            modifier,\n          });\n        }\n      }\n    }\n\n    tsIsListTerminator(kind: ParsingContext): boolean {\n      switch (kind) {\n        case \"EnumMembers\":\n        case \"TypeMembers\":\n          return this.match(tt.braceR);\n        case \"HeritageClauseElement\":\n          return this.match(tt.braceL);\n        case \"TupleElementTypes\":\n          return this.match(tt.bracketR);\n        case \"TypeParametersOrArguments\":\n          return this.match(tt.gt);\n      }\n    }\n\n    tsParseList<T extends N.Node>(\n      kind: ParsingContext,\n      parseElement: () => T,\n    ): T[] {\n      const result: T[] = [];\n      while (!this.tsIsListTerminator(kind)) {\n        // Skipping \"parseListElement\" from the TS source since that's just for error handling.\n        result.push(parseElement());\n      }\n      return result;\n    }\n\n    tsParseDelimitedList<T extends N.Node>(\n      kind: ParsingContext,\n      parseElement: () => T,\n      refTrailingCommaPos?: {\n        value: number;\n      },\n    ): T[] {\n      return nonNull(\n        this.tsParseDelimitedListWorker(\n          kind,\n          parseElement,\n          /* expectSuccess */ true,\n          refTrailingCommaPos,\n        ),\n      );\n    }\n\n    /**\n     * If !expectSuccess, returns undefined instead of failing to parse.\n     * If expectSuccess, parseElement should always return a defined value.\n     */\n    tsParseDelimitedListWorker<T extends N.Node>(\n      kind: ParsingContext,\n      parseElement: () => T | undefined,\n      expectSuccess: boolean,\n      refTrailingCommaPos?: {\n        value: number;\n      },\n    ): T[] | undefined {\n      const result: T[] = [];\n      let trailingCommaPos = -1;\n\n      for (;;) {\n        if (this.tsIsListTerminator(kind)) {\n          break;\n        }\n        trailingCommaPos = -1;\n\n        const element = parseElement();\n        if (element == null) {\n          return undefined;\n        }\n        result.push(element);\n\n        if (this.eat(tt.comma)) {\n          trailingCommaPos = this.state.lastTokStartLoc.index;\n          continue;\n        }\n\n        if (this.tsIsListTerminator(kind)) {\n          break;\n        }\n\n        if (expectSuccess) {\n          // This will fail with an error about a missing comma\n          this.expect(tt.comma);\n        }\n        return undefined;\n      }\n\n      if (refTrailingCommaPos) {\n        refTrailingCommaPos.value = trailingCommaPos;\n      }\n\n      return result;\n    }\n\n    tsParseBracketedList<T extends N.Node>(\n      kind: ParsingContext,\n      parseElement: () => T,\n      bracket: boolean,\n      skipFirstToken: boolean,\n      refTrailingCommaPos?: {\n        value: number;\n      },\n    ): T[] {\n      if (!skipFirstToken) {\n        if (bracket) {\n          this.expect(tt.bracketL);\n        } else {\n          this.expect(tt.lt);\n        }\n      }\n\n      const result = this.tsParseDelimitedList(\n        kind,\n        parseElement,\n        refTrailingCommaPos,\n      );\n\n      if (bracket) {\n        this.expect(tt.bracketR);\n      } else {\n        this.expect(tt.gt);\n      }\n\n      return result;\n    }\n\n    tsParseImportType(): N.TsImportType {\n      const node = this.startNode<N.TsImportType>();\n      this.expect(tt._import);\n      this.expect(tt.parenL);\n      if (!this.match(tt.string)) {\n        this.raise(TSErrors.UnsupportedImportTypeArgument, this.state.startLoc);\n        if (process.env.BABEL_8_BREAKING) {\n          // Consume as an non-conditional type so that we can recover from this error\n          node.argument = this.tsParseNonConditionalType() as any;\n        } else {\n          node.argument = super.parseExprAtom() as any;\n        }\n      } else {\n        if (process.env.BABEL_8_BREAKING) {\n          node.argument = this.tsParseLiteralTypeNode();\n        } else {\n          // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST\n          node.argument = this.parseStringLiteral(this.state.value);\n        }\n      }\n      if (this.eat(tt.comma) && !this.match(tt.parenR)) {\n        node.options = super.parseMaybeAssignAllowIn();\n        this.eat(tt.comma);\n      } else {\n        node.options = null;\n      }\n      this.expect(tt.parenR);\n\n      if (this.eat(tt.dot)) {\n        // In this instance, the entity name will actually itself be a\n        // qualifier, so allow it to be a reserved word as well.\n        node.qualifier = this.tsParseEntityName(\n          tsParseEntityNameFlags.ALLOW_RESERVED_WORDS |\n            tsParseEntityNameFlags.LEADING_THIS_AS_IDENTIFIER,\n        );\n      }\n      if (this.match(tt.lt)) {\n        if (process.env.BABEL_8_BREAKING) {\n          node.typeArguments = this.tsParseTypeArguments();\n        } else {\n          node.typeParameters = this.tsParseTypeArguments();\n        }\n      }\n      return this.finishNode(node, \"TSImportType\");\n    }\n\n    tsParseEntityName(flags: tsParseEntityNameFlags): N.TsEntityName {\n      let entity: N.TsEntityName;\n      if (\n        flags & tsParseEntityNameFlags.ALLOW_RESERVED_WORDS &&\n        this.match(tt._this)\n      ) {\n        if (flags & tsParseEntityNameFlags.LEADING_THIS_AS_IDENTIFIER) {\n          entity = this.parseIdentifier(true);\n        } else {\n          const node = this.startNode<N.ThisExpression>();\n          this.next();\n          entity = this.finishNode(node, \"ThisExpression\");\n        }\n      } else {\n        entity = this.parseIdentifier(\n          !!(flags & tsParseEntityNameFlags.ALLOW_RESERVED_WORDS),\n        );\n      }\n      while (this.eat(tt.dot)) {\n        const node: Undone<N.TsQualifiedName> =\n          this.startNodeAtNode<N.TsQualifiedName>(entity);\n        node.left = entity;\n        node.right = this.parseIdentifier(\n          !!(flags & tsParseEntityNameFlags.ALLOW_RESERVED_WORDS),\n        );\n        entity = this.finishNode(node, \"TSQualifiedName\");\n      }\n      return entity;\n    }\n\n    tsParseTypeReference(): N.TsTypeReference {\n      const node = this.startNode<N.TsTypeReference>();\n      node.typeName = this.tsParseEntityName(\n        tsParseEntityNameFlags.ALLOW_RESERVED_WORDS,\n      );\n      if (!this.hasPrecedingLineBreak() && this.match(tt.lt)) {\n        if (process.env.BABEL_8_BREAKING) {\n          node.typeArguments = this.tsParseTypeArguments();\n        } else {\n          node.typeParameters = this.tsParseTypeArguments();\n        }\n      }\n      return this.finishNode(node, \"TSTypeReference\");\n    }\n\n    tsParseThisTypePredicate(lhs: N.TsThisType): N.TsTypePredicate {\n      this.next();\n      const node = this.startNodeAtNode<N.TsTypePredicate>(lhs);\n      node.parameterName = lhs;\n      node.typeAnnotation = this.tsParseTypeAnnotation(/* eatColon */ false);\n      node.asserts = false;\n      return this.finishNode(node, \"TSTypePredicate\");\n    }\n\n    tsParseThisTypeNode(): N.TsThisType {\n      const node = this.startNode<N.TsThisType>();\n      this.next();\n      return this.finishNode(node, \"TSThisType\");\n    }\n\n    tsParseTypeQuery(): N.TsTypeQuery {\n      const node = this.startNode<N.TsTypeQuery>();\n      this.expect(tt._typeof);\n      if (this.match(tt._import)) {\n        node.exprName = this.tsParseImportType();\n      } else {\n        if (process.env.BABEL_8_BREAKING) {\n          node.exprName = this.tsParseEntityName(\n            tsParseEntityNameFlags.ALLOW_RESERVED_WORDS,\n          );\n        } else {\n          node.exprName = this.tsParseEntityName(\n            tsParseEntityNameFlags.ALLOW_RESERVED_WORDS |\n              tsParseEntityNameFlags.LEADING_THIS_AS_IDENTIFIER,\n          );\n        }\n      }\n      if (!this.hasPrecedingLineBreak() && this.match(tt.lt)) {\n        if (process.env.BABEL_8_BREAKING) {\n          node.typeArguments = this.tsParseTypeArguments();\n        } else {\n          node.typeParameters = this.tsParseTypeArguments();\n        }\n      }\n      return this.finishNode(node, \"TSTypeQuery\");\n    }\n\n    tsParseInOutModifiers = this.tsParseModifiers.bind(this, {\n      allowedModifiers: [\"in\", \"out\"],\n      disallowedModifiers: [\n        \"const\",\n        \"public\",\n        \"private\",\n        \"protected\",\n        \"readonly\",\n        \"declare\",\n        \"abstract\",\n        \"override\",\n      ],\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameter,\n    });\n\n    tsParseConstModifier = this.tsParseModifiers.bind(this, {\n      allowedModifiers: [\"const\"],\n      // for better error recovery\n      disallowedModifiers: [\"in\", \"out\"],\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions,\n    });\n\n    tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {\n      allowedModifiers: [\"in\", \"out\", \"const\"],\n      disallowedModifiers: [\n        \"public\",\n        \"private\",\n        \"protected\",\n        \"readonly\",\n        \"declare\",\n        \"abstract\",\n        \"override\",\n      ],\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameter,\n    });\n\n    tsParseTypeParameter(\n      parseModifiers: (node: Undone<N.TsTypeParameter>) => void,\n    ): N.TsTypeParameter {\n      const node = this.startNode<N.TsTypeParameter>();\n\n      parseModifiers(node);\n\n      node.name = this.tsParseTypeParameterName();\n      node.constraint = this.tsEatThenParseType(tt._extends);\n      node.default = this.tsEatThenParseType(tt.eq);\n      return this.finishNode(node, \"TSTypeParameter\");\n    }\n\n    tsTryParseTypeParameters(\n      parseModifiers: (node: N.TsTypeParameter) => void,\n    ): N.TsTypeParameterDeclaration | undefined | null {\n      if (this.match(tt.lt)) {\n        return this.tsParseTypeParameters(parseModifiers);\n      }\n    }\n\n    tsParseTypeParameters(parseModifiers: (node: N.TsTypeParameter) => void) {\n      const node = this.startNode<N.TsTypeParameterDeclaration>();\n\n      if (this.match(tt.lt) || this.match(tt.jsxTagStart)) {\n        this.next();\n      } else {\n        this.unexpected();\n      }\n\n      const refTrailingCommaPos = { value: -1 };\n\n      node.params = this.tsParseBracketedList(\n        \"TypeParametersOrArguments\",\n        this.tsParseTypeParameter.bind(this, parseModifiers),\n        /* bracket */ false,\n        /* skipFirstToken */ true,\n        refTrailingCommaPos,\n      );\n      if (node.params.length === 0) {\n        this.raise(TSErrors.EmptyTypeParameters, node);\n      }\n      if (refTrailingCommaPos.value !== -1) {\n        this.addExtra(node, \"trailingComma\", refTrailingCommaPos.value);\n      }\n      return this.finishNode(node, \"TSTypeParameterDeclaration\");\n    }\n\n    // Note: In TypeScript implementation we must provide `yieldContext` and `awaitContext`,\n    // but here it's always false, because this is only used for types.\n    tsFillSignature(\n      returnToken: TokenType,\n      signature: Undone<N.TsSignatureDeclaration>,\n    ): void {\n      // Arrow fns *must* have return token (`=>`). Normal functions can omit it.\n      const returnTokenRequired = returnToken === tt.arrow;\n\n      // https://github.com/babel/babel/issues/9231\n      const paramsKey = process.env.BABEL_8_BREAKING ? \"params\" : \"parameters\";\n      const returnTypeKey = process.env.BABEL_8_BREAKING\n        ? \"returnType\"\n        : \"typeAnnotation\";\n\n      signature.typeParameters = this.tsTryParseTypeParameters(\n        this.tsParseConstModifier,\n      );\n      this.expect(tt.parenL);\n      signature[paramsKey] = this.tsParseBindingListForSignature();\n      if (returnTokenRequired) {\n        signature[returnTypeKey] =\n          this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n      } else if (this.match(returnToken)) {\n        signature[returnTypeKey] =\n          this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n      }\n    }\n\n    tsParseBindingListForSignature(): Array<\n      N.Identifier | N.RestElement | N.ObjectPattern | N.ArrayPattern\n    > {\n      const list = super.parseBindingList(\n        tt.parenR,\n        charCodes.rightParenthesis,\n        ParseBindingListFlags.IS_FUNCTION_PARAMS,\n      );\n      for (const pattern of list) {\n        const { type } = pattern;\n        if (type === \"AssignmentPattern\" || type === \"TSParameterProperty\") {\n          this.raise(TSErrors.UnsupportedSignatureParameterKind, pattern, {\n            type,\n          });\n        }\n      }\n      return list as Exclude<\n        (typeof list)[0],\n        N.AssignmentPattern | N.TSParameterProperty\n      >[];\n    }\n\n    tsParseTypeMemberSemicolon(): void {\n      if (!this.eat(tt.comma) && !this.isLineTerminator()) {\n        this.expect(tt.semi);\n      }\n    }\n\n    tsParseSignatureMember(\n      kind: \"TSCallSignatureDeclaration\" | \"TSConstructSignatureDeclaration\",\n      node: Undone<\n        N.TsCallSignatureDeclaration | N.TsConstructSignatureDeclaration\n      >,\n    ): N.TsCallSignatureDeclaration | N.TsConstructSignatureDeclaration {\n      this.tsFillSignature(tt.colon, node);\n      this.tsParseTypeMemberSemicolon();\n      return this.finishNode(node, kind);\n    }\n\n    tsIsUnambiguouslyIndexSignature() {\n      this.next(); // Skip '{'\n      if (tokenIsIdentifier(this.state.type)) {\n        this.next();\n        return this.match(tt.colon);\n      }\n      return false;\n    }\n\n    tsTryParseIndexSignature(\n      node: Undone<N.TsIndexSignature>,\n    ): N.TsIndexSignature | undefined {\n      if (\n        !(\n          this.match(tt.bracketL) &&\n          this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))\n        )\n      ) {\n        return;\n      }\n\n      this.expect(tt.bracketL);\n      const id = this.parseIdentifier();\n      id.typeAnnotation = this.tsParseTypeAnnotation();\n      this.resetEndLocation(id); // set end position to end of type\n\n      this.expect(tt.bracketR);\n      node.parameters = [id];\n\n      const type = this.tsTryParseTypeAnnotation();\n      if (type) node.typeAnnotation = type;\n      this.tsParseTypeMemberSemicolon();\n      return this.finishNode(node, \"TSIndexSignature\");\n    }\n\n    tsParsePropertyOrMethodSignature(\n      node: N.TsPropertySignature | N.TsMethodSignature,\n      readonly: boolean,\n    ): N.TsPropertySignature | N.TsMethodSignature {\n      if (this.eat(tt.question)) node.optional = true;\n      const nodeAny: any = node;\n\n      if (this.match(tt.parenL) || this.match(tt.lt)) {\n        if (readonly) {\n          this.raise(TSErrors.ReadonlyForMethodSignature, node);\n        }\n        const method: N.TsMethodSignature = nodeAny;\n        if (method.kind && this.match(tt.lt)) {\n          this.raise(\n            TSErrors.AccessorCannotHaveTypeParameters,\n            this.state.curPosition(),\n          );\n        }\n        this.tsFillSignature(tt.colon, method);\n        this.tsParseTypeMemberSemicolon();\n        const paramsKey = process.env.BABEL_8_BREAKING\n          ? \"params\"\n          : \"parameters\";\n        const returnTypeKey = process.env.BABEL_8_BREAKING\n          ? \"returnType\"\n          : \"typeAnnotation\";\n        if (method.kind === \"get\") {\n          if (method[paramsKey].length > 0) {\n            this.raise(Errors.BadGetterArity, this.state.curPosition());\n            if (this.isThisParam(method[paramsKey][0])) {\n              this.raise(\n                TSErrors.AccessorCannotDeclareThisParameter,\n                this.state.curPosition(),\n              );\n            }\n          }\n        } else if (method.kind === \"set\") {\n          if (method[paramsKey].length !== 1) {\n            this.raise(Errors.BadSetterArity, this.state.curPosition());\n          } else {\n            const firstParameter = method[paramsKey][0];\n            if (this.isThisParam(firstParameter)) {\n              this.raise(\n                TSErrors.AccessorCannotDeclareThisParameter,\n                this.state.curPosition(),\n              );\n            }\n            if (\n              firstParameter.type === \"Identifier\" &&\n              firstParameter.optional\n            ) {\n              this.raise(\n                TSErrors.SetAccessorCannotHaveOptionalParameter,\n                this.state.curPosition(),\n              );\n            }\n            if (firstParameter.type === \"RestElement\") {\n              this.raise(\n                TSErrors.SetAccessorCannotHaveRestParameter,\n                this.state.curPosition(),\n              );\n            }\n          }\n          if (method[returnTypeKey]) {\n            this.raise(\n              TSErrors.SetAccessorCannotHaveReturnType,\n              method[returnTypeKey],\n            );\n          }\n        } else {\n          method.kind = \"method\";\n        }\n        return this.finishNode(method, \"TSMethodSignature\");\n      } else {\n        const property: N.TsPropertySignature = nodeAny;\n        if (readonly) property.readonly = true;\n        const type = this.tsTryParseTypeAnnotation();\n        if (type) property.typeAnnotation = type;\n        this.tsParseTypeMemberSemicolon();\n        return this.finishNode(property, \"TSPropertySignature\");\n      }\n    }\n\n    tsParseTypeMember(): N.TsTypeElement {\n      const node: any = this.startNode();\n\n      if (this.match(tt.parenL) || this.match(tt.lt)) {\n        return this.tsParseSignatureMember(\"TSCallSignatureDeclaration\", node);\n      }\n\n      if (this.match(tt._new)) {\n        const id = this.startNode<N.Identifier>();\n        this.next();\n        if (this.match(tt.parenL) || this.match(tt.lt)) {\n          return this.tsParseSignatureMember(\n            \"TSConstructSignatureDeclaration\",\n            node,\n          );\n        } else {\n          node.key = this.createIdentifier(id, \"new\");\n          return this.tsParsePropertyOrMethodSignature(node, false);\n        }\n      }\n\n      this.tsParseModifiers(\n        {\n          allowedModifiers: [\"readonly\"],\n          disallowedModifiers: [\n            \"declare\",\n            \"abstract\",\n            \"private\",\n            \"protected\",\n            \"public\",\n            \"static\",\n            \"override\",\n          ],\n        },\n        node,\n      );\n\n      const idx = this.tsTryParseIndexSignature(node);\n      if (idx) {\n        return idx;\n      }\n\n      super.parsePropertyName(node);\n      if (\n        !node.computed &&\n        node.key.type === \"Identifier\" &&\n        (node.key.name === \"get\" || node.key.name === \"set\") &&\n        this.tsTokenCanFollowModifier()\n      ) {\n        node.kind = node.key.name;\n        super.parsePropertyName(node);\n      }\n      return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);\n    }\n\n    tsParseTypeLiteral(): N.TsTypeLiteral {\n      const node = this.startNode<N.TsTypeLiteral>();\n      node.members = this.tsParseObjectTypeMembers();\n      return this.finishNode(node, \"TSTypeLiteral\");\n    }\n\n    tsParseObjectTypeMembers(): Array<N.TsTypeElement> {\n      this.expect(tt.braceL);\n      const members = this.tsParseList(\n        \"TypeMembers\",\n        this.tsParseTypeMember.bind(this),\n      );\n      this.expect(tt.braceR);\n      return members;\n    }\n\n    tsIsStartOfMappedType(): boolean {\n      this.next();\n      if (this.eat(tt.plusMin)) {\n        return this.isContextual(tt._readonly);\n      }\n      if (this.isContextual(tt._readonly)) {\n        this.next();\n      }\n      if (!this.match(tt.bracketL)) {\n        return false;\n      }\n      this.next();\n      if (!this.tsIsIdentifier()) {\n        return false;\n      }\n      this.next();\n      return this.match(tt._in);\n    }\n\n    tsParseMappedType(): N.TsMappedType {\n      const node = this.startNode<N.TsMappedType>();\n\n      this.expect(tt.braceL);\n\n      if (this.match(tt.plusMin)) {\n        node.readonly = this.state.value;\n        this.next();\n        this.expectContextual(tt._readonly);\n      } else if (this.eatContextual(tt._readonly)) {\n        node.readonly = true;\n      }\n\n      this.expect(tt.bracketL);\n      if (process.env.BABEL_8_BREAKING) {\n        node.key = this.tsParseTypeParameterName() as N.Identifier;\n        node.constraint = this.tsExpectThenParseType(tt._in);\n      } else {\n        const typeParameter = this.startNode<N.TsTypeParameter>();\n        typeParameter.name = this.tsParseTypeParameterName();\n        typeParameter.constraint = this.tsExpectThenParseType(tt._in);\n        // @ts-expect-error for Babel 7\n        node.typeParameter = this.finishNode(typeParameter, \"TSTypeParameter\");\n      }\n      node.nameType = this.eatContextual(tt._as) ? this.tsParseType() : null;\n\n      this.expect(tt.bracketR);\n\n      if (this.match(tt.plusMin)) {\n        node.optional = this.state.value;\n        this.next();\n        this.expect(tt.question);\n      } else if (this.eat(tt.question)) {\n        node.optional = true;\n      }\n\n      node.typeAnnotation = this.tsTryParseType();\n      this.semicolon();\n      this.expect(tt.braceR);\n\n      return this.finishNode(node, \"TSMappedType\");\n    }\n\n    tsParseTupleType(): N.TsTupleType {\n      const node = this.startNode<N.TsTupleType>();\n      node.elementTypes = this.tsParseBracketedList(\n        \"TupleElementTypes\",\n        this.tsParseTupleElementType.bind(this),\n        /* bracket */ true,\n        /* skipFirstToken */ false,\n      );\n\n      // Validate the elementTypes to ensure that no mandatory elements\n      // follow optional elements\n      let seenOptionalElement = false;\n      node.elementTypes.forEach(elementNode => {\n        const { type } = elementNode;\n\n        if (\n          seenOptionalElement &&\n          type !== \"TSRestType\" &&\n          type !== \"TSOptionalType\" &&\n          !(type === \"TSNamedTupleMember\" && elementNode.optional)\n        ) {\n          this.raise(TSErrors.OptionalTypeBeforeRequired, elementNode);\n        }\n\n        seenOptionalElement ||=\n          (type === \"TSNamedTupleMember\" && elementNode.optional) ||\n          type === \"TSOptionalType\";\n      });\n\n      return this.finishNode(node, \"TSTupleType\");\n    }\n\n    tsParseTupleElementType(): N.TsNamedTupleMember | N.TsType {\n      // parses `...TsType[]`\n\n      const restStartLoc = this.state.startLoc;\n\n      const rest = this.eat(tt.ellipsis);\n      const { startLoc } = this.state;\n\n      let labeled: boolean;\n      let label: N.Identifier;\n      let optional: boolean;\n      let type: N.TsNamedTupleMember | N.TsType;\n\n      const isWord = tokenIsKeywordOrIdentifier(this.state.type);\n      const chAfterWord = isWord ? this.lookaheadCharCode() : null;\n      if (chAfterWord === charCodes.colon) {\n        labeled = true;\n        optional = false;\n        label = this.parseIdentifier(true);\n        this.expect(tt.colon);\n        type = this.tsParseType();\n      } else if (chAfterWord === charCodes.questionMark) {\n        optional = true;\n        const wordName = this.state.value;\n        const typeOrLabel = this.tsParseNonArrayType();\n\n        if (this.lookaheadCharCode() === charCodes.colon) {\n          labeled = true;\n          label = this.createIdentifier(\n            this.startNodeAt<N.Identifier>(startLoc),\n            wordName,\n          );\n          this.expect(tt.question);\n          this.expect(tt.colon);\n          type = this.tsParseType();\n        } else {\n          labeled = false;\n          type = typeOrLabel;\n          this.expect(tt.question);\n        }\n      } else {\n        type = this.tsParseType();\n        optional = this.eat(tt.question);\n        // In this case (labeled === true) could be only in invalid label.\n        // E.g. [x.y:type]\n        // An error is raised while processing node.\n        labeled = this.eat(tt.colon);\n      }\n\n      if (labeled) {\n        let labeledNode: Undone<N.TsNamedTupleMember>;\n        if (label) {\n          labeledNode = this.startNodeAt<N.TsNamedTupleMember>(startLoc);\n          labeledNode.optional = optional;\n          labeledNode.label = label;\n          labeledNode.elementType = type;\n\n          if (this.eat(tt.question)) {\n            labeledNode.optional = true;\n            this.raise(\n              TSErrors.TupleOptionalAfterType,\n              this.state.lastTokStartLoc,\n            );\n          }\n        } else {\n          labeledNode = this.startNodeAt<N.TsNamedTupleMember>(startLoc);\n          labeledNode.optional = optional;\n          this.raise(TSErrors.InvalidTupleMemberLabel, type);\n          // @ts-expect-error This produces an invalid AST, but at least we don't drop\n          // nodes representing the invalid source.\n          labeledNode.label = type;\n          labeledNode.elementType = this.tsParseType();\n        }\n        type = this.finishNode(labeledNode, \"TSNamedTupleMember\");\n      } else if (optional) {\n        const optionalTypeNode = this.startNodeAt<N.TsOptionalType>(startLoc);\n        optionalTypeNode.typeAnnotation = type;\n        type = this.finishNode(optionalTypeNode, \"TSOptionalType\");\n      }\n\n      if (rest) {\n        const restNode = this.startNodeAt<N.TsRestType>(restStartLoc);\n        restNode.typeAnnotation = type;\n        type = this.finishNode(restNode, \"TSRestType\");\n      }\n\n      return type;\n    }\n\n    tsParseParenthesizedType(): N.TsParenthesizedType {\n      const node = this.startNode<N.TsParenthesizedType>();\n      this.expect(tt.parenL);\n      node.typeAnnotation = this.tsParseType();\n      this.expect(tt.parenR);\n      return this.finishNode(node, \"TSParenthesizedType\");\n    }\n\n    tsParseFunctionOrConstructorType(\n      type: \"TSFunctionType\" | \"TSConstructorType\",\n      abstract?: boolean,\n    ): N.TsFunctionOrConstructorType {\n      const node = this.startNode<\n        N.TsFunctionOrConstructorType | N.TsConstructorType\n      >();\n      if (type === \"TSConstructorType\") {\n        (node as Undone<N.TsConstructorType>).abstract = !!abstract;\n        if (abstract) this.next();\n        this.next(); // eat `new`\n      }\n      this.tsInAllowConditionalTypesContext(() =>\n        this.tsFillSignature(tt.arrow, node),\n      );\n      return this.finishNode(node, type);\n    }\n\n    tsParseLiteralTypeNode(): N.TsLiteralType {\n      const node = this.startNode<N.TsLiteralType>();\n      switch (this.state.type) {\n        case tt.num:\n        case tt.bigint:\n        case tt.string:\n        case tt._true:\n        case tt._false:\n          // For compatibility to estree we cannot call parseLiteral directly here\n          // @ts-expect-error refine typings\n          node.literal = super.parseExprAtom();\n          break;\n        default:\n          this.unexpected();\n      }\n      return this.finishNode(node, \"TSLiteralType\");\n    }\n\n    tsParseTemplateLiteralType(): N.TsTemplateLiteralType | N.TsLiteralType {\n      if (process.env.BABEL_8_BREAKING) {\n        const startLoc = this.state.startLoc;\n        let curElt = this.parseTemplateElement(false);\n        const quasis = [curElt];\n        if (curElt.tail) {\n          const node = this.startNodeAt<N.TsLiteralType>(startLoc);\n          const literal = this.startNodeAt<N.TemplateLiteral>(startLoc);\n          literal.expressions = [];\n          literal.quasis = quasis;\n          node.literal = this.finishNode(literal, \"TemplateLiteral\");\n          return this.finishNode(node, \"TSLiteralType\");\n        } else {\n          const substitutions: N.TsType[] = [];\n          while (!curElt.tail) {\n            substitutions.push(this.tsParseType());\n            this.readTemplateContinuation();\n            quasis.push((curElt = this.parseTemplateElement(false)));\n          }\n          const node = this.startNodeAt<N.TsTemplateLiteralType>(startLoc);\n          node.types = substitutions;\n          node.quasis = quasis;\n          return this.finishNode(node, \"TSTemplateLiteralType\");\n        }\n      } else {\n        const node = this.startNode<N.TsLiteralType>();\n        node.literal = super.parseTemplate(false);\n        return this.finishNode(node, \"TSLiteralType\");\n      }\n    }\n\n    parseTemplateSubstitution(): N.TsType | N.Expression {\n      if (this.state.inType) return this.tsParseType();\n      return super.parseTemplateSubstitution();\n    }\n\n    tsParseThisTypeOrThisTypePredicate(): N.TsThisType | N.TsTypePredicate {\n      const thisKeyword = this.tsParseThisTypeNode();\n      if (this.isContextual(tt._is) && !this.hasPrecedingLineBreak()) {\n        return this.tsParseThisTypePredicate(thisKeyword);\n      } else {\n        return thisKeyword;\n      }\n    }\n\n    tsParseNonArrayType(): N.TsType {\n      switch (this.state.type) {\n        case tt.string:\n        case tt.num:\n        case tt.bigint:\n        case tt._true:\n        case tt._false:\n          return this.tsParseLiteralTypeNode();\n        case tt.plusMin:\n          if (this.state.value === \"-\") {\n            const node = this.startNode<N.TsLiteralType>();\n            const nextToken = this.lookahead();\n            if (nextToken.type !== tt.num && nextToken.type !== tt.bigint) {\n              this.unexpected();\n            }\n            // @ts-expect-error: parseMaybeUnary must returns unary expression\n            node.literal = this.parseMaybeUnary();\n            return this.finishNode(node, \"TSLiteralType\");\n          }\n          break;\n        case tt._this:\n          return this.tsParseThisTypeOrThisTypePredicate();\n        case tt._typeof:\n          return this.tsParseTypeQuery();\n        case tt._import:\n          return this.tsParseImportType();\n        case tt.braceL:\n          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this))\n            ? this.tsParseMappedType()\n            : this.tsParseTypeLiteral();\n        case tt.bracketL:\n          return this.tsParseTupleType();\n        case tt.parenL:\n          if (process.env.BABEL_8_BREAKING) {\n            if (\n              !(this.optionFlags & OptionFlags.CreateParenthesizedExpressions)\n            ) {\n              const startLoc = this.state.startLoc;\n              this.next();\n              const type = this.tsParseType();\n              this.expect(tt.parenR);\n              this.addExtra(type, \"parenthesized\", true);\n              this.addExtra(type, \"parenStart\", startLoc.index);\n              return type;\n            }\n          }\n\n          return this.tsParseParenthesizedType();\n        case tt.templateNonTail:\n        case tt.templateTail:\n          return this.tsParseTemplateLiteralType();\n        default: {\n          const { type } = this.state;\n          if (\n            tokenIsIdentifier(type) ||\n            type === tt._void ||\n            type === tt._null\n          ) {\n            const nodeType =\n              type === tt._void\n                ? \"TSVoidKeyword\"\n                : type === tt._null\n                  ? \"TSNullKeyword\"\n                  : keywordTypeFromName(this.state.value);\n            if (\n              nodeType !== undefined &&\n              this.lookaheadCharCode() !== charCodes.dot\n            ) {\n              const node = this.startNode<N.TsKeywordType>();\n              this.next();\n              return this.finishNode(node, nodeType);\n            }\n            return this.tsParseTypeReference();\n          }\n        }\n      }\n\n      this.unexpected();\n    }\n\n    tsParseArrayTypeOrHigher(): N.TsType {\n      const { startLoc } = this.state;\n      let type = this.tsParseNonArrayType();\n      while (!this.hasPrecedingLineBreak() && this.eat(tt.bracketL)) {\n        if (this.match(tt.bracketR)) {\n          const node = this.startNodeAt<N.TsArrayType>(startLoc);\n          node.elementType = type;\n          this.expect(tt.bracketR);\n          type = this.finishNode(node, \"TSArrayType\");\n        } else {\n          const node = this.startNodeAt<N.TsIndexedAccessType>(startLoc);\n          node.objectType = type;\n          node.indexType = this.tsParseType();\n          this.expect(tt.bracketR);\n          type = this.finishNode(node, \"TSIndexedAccessType\");\n        }\n      }\n      return type;\n    }\n\n    tsParseTypeOperator(): N.TsTypeOperator {\n      const node = this.startNode<N.TsTypeOperator>();\n      const operator = this.state.value;\n      this.next(); // eat operator\n      node.operator = operator;\n      node.typeAnnotation = this.tsParseTypeOperatorOrHigher();\n\n      if (operator === \"readonly\") {\n        this.tsCheckTypeAnnotationForReadOnly(node);\n      }\n\n      return this.finishNode(node, \"TSTypeOperator\");\n    }\n\n    tsCheckTypeAnnotationForReadOnly(node: Undone<N.TsTypeOperator>) {\n      switch (node.typeAnnotation.type) {\n        case \"TSTupleType\":\n        case \"TSArrayType\":\n          return;\n        default:\n          this.raise(TSErrors.UnexpectedReadonly, node);\n      }\n    }\n\n    tsParseInferType(): N.TsInferType {\n      const node = this.startNode<N.TsInferType>();\n      this.expectContextual(tt._infer);\n      const typeParameter = this.startNode<N.TsTypeParameter>();\n      typeParameter.name = this.tsParseTypeParameterName();\n      typeParameter.constraint = this.tsTryParse(() =>\n        this.tsParseConstraintForInferType(),\n      );\n      node.typeParameter = this.finishNode(typeParameter, \"TSTypeParameter\");\n      return this.finishNode(node, \"TSInferType\");\n    }\n\n    tsParseConstraintForInferType() {\n      if (this.eat(tt._extends)) {\n        const constraint = this.tsInDisallowConditionalTypesContext(() =>\n          this.tsParseType(),\n        );\n        if (\n          this.state.inDisallowConditionalTypesContext ||\n          !this.match(tt.question)\n        ) {\n          return constraint;\n        }\n      }\n    }\n\n    tsParseTypeOperatorOrHigher(): N.TsType {\n      const isTypeOperator =\n        tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;\n      return isTypeOperator\n        ? this.tsParseTypeOperator()\n        : this.isContextual(tt._infer)\n          ? this.tsParseInferType()\n          : this.tsInAllowConditionalTypesContext(() =>\n              this.tsParseArrayTypeOrHigher(),\n            );\n    }\n\n    tsParseUnionOrIntersectionType(\n      kind: \"TSUnionType\" | \"TSIntersectionType\",\n      parseConstituentType: () => N.TsType,\n      operator: TokenType,\n    ): N.TsType {\n      const node = this.startNode<N.TsUnionType | N.TsIntersectionType>();\n      const hasLeadingOperator = this.eat(operator);\n      const types = [];\n      do {\n        types.push(parseConstituentType());\n      } while (this.eat(operator));\n      if (types.length === 1 && !hasLeadingOperator) {\n        return types[0];\n      }\n      node.types = types;\n      return this.finishNode(node, kind);\n    }\n\n    tsParseIntersectionTypeOrHigher(): N.TsType {\n      return this.tsParseUnionOrIntersectionType(\n        \"TSIntersectionType\",\n        this.tsParseTypeOperatorOrHigher.bind(this),\n        tt.bitwiseAND,\n      );\n    }\n\n    tsParseUnionTypeOrHigher() {\n      return this.tsParseUnionOrIntersectionType(\n        \"TSUnionType\",\n        this.tsParseIntersectionTypeOrHigher.bind(this),\n        tt.bitwiseOR,\n      );\n    }\n\n    tsIsStartOfFunctionType() {\n      if (this.match(tt.lt)) {\n        return true;\n      }\n      return (\n        this.match(tt.parenL) &&\n        this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this))\n      );\n    }\n\n    tsSkipParameterStart(): boolean {\n      if (tokenIsIdentifier(this.state.type) || this.match(tt._this)) {\n        this.next();\n        return true;\n      }\n\n      if (this.match(tt.braceL)) {\n        // Return true if we can parse an object pattern without errors\n        const { errors } = this.state;\n        const previousErrorCount = errors.length;\n        try {\n          this.parseObjectLike(tt.braceR, true);\n          return errors.length === previousErrorCount;\n        } catch {\n          return false;\n        }\n      }\n\n      if (this.match(tt.bracketL)) {\n        this.next();\n        // Return true if we can parse an array pattern without errors\n        const { errors } = this.state;\n        const previousErrorCount = errors.length;\n        try {\n          super.parseBindingList(\n            tt.bracketR,\n            charCodes.rightSquareBracket,\n            ParseBindingListFlags.ALLOW_EMPTY,\n          );\n          return errors.length === previousErrorCount;\n        } catch {\n          return false;\n        }\n      }\n\n      return false;\n    }\n\n    tsIsUnambiguouslyStartOfFunctionType(): boolean {\n      this.next();\n      if (this.match(tt.parenR) || this.match(tt.ellipsis)) {\n        // ( )\n        // ( ...\n        return true;\n      }\n      if (this.tsSkipParameterStart()) {\n        if (\n          this.match(tt.colon) ||\n          this.match(tt.comma) ||\n          this.match(tt.question) ||\n          this.match(tt.eq)\n        ) {\n          // ( xxx :\n          // ( xxx ,\n          // ( xxx ?\n          // ( xxx =\n          return true;\n        }\n        if (this.match(tt.parenR)) {\n          this.next();\n          if (this.match(tt.arrow)) {\n            // ( xxx ) =>\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n\n    tsParseTypeOrTypePredicateAnnotation(\n      returnToken: TokenType,\n    ): N.TsTypeAnnotation {\n      return this.tsInType(() => {\n        const t = this.startNode<N.TsTypeAnnotation>();\n        this.expect(returnToken);\n\n        const node = this.startNode<N.TsTypePredicate>();\n\n        const asserts = !!this.tsTryParse(\n          this.tsParseTypePredicateAsserts.bind(this),\n        );\n\n        if (asserts && this.match(tt._this)) {\n          // When asserts is false, thisKeyword is handled by tsParseNonArrayType\n          // : asserts this is type\n          let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();\n          // if it turns out to be a `TSThisType`, wrap it with `TSTypePredicate`\n          // : asserts this\n          if (thisTypePredicate.type === \"TSThisType\") {\n            node.parameterName = thisTypePredicate;\n            node.asserts = true;\n            (node as N.TsTypePredicate).typeAnnotation = null;\n            thisTypePredicate = this.finishNode(node, \"TSTypePredicate\");\n          } else {\n            this.resetStartLocationFromNode(thisTypePredicate, node);\n            thisTypePredicate.asserts = true;\n          }\n          t.typeAnnotation = thisTypePredicate;\n          return this.finishNode(t, \"TSTypeAnnotation\");\n        }\n\n        const typePredicateVariable =\n          this.tsIsIdentifier() &&\n          this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));\n\n        if (!typePredicateVariable) {\n          if (!asserts) {\n            // : type\n            return this.tsParseTypeAnnotation(/* eatColon */ false, t);\n          }\n\n          // : asserts foo\n          node.parameterName = this.parseIdentifier();\n          node.asserts = asserts;\n          (node as N.TsTypePredicate).typeAnnotation = null;\n          t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n          return this.finishNode(t, \"TSTypeAnnotation\");\n        }\n\n        // : asserts foo is type\n        const type = this.tsParseTypeAnnotation(/* eatColon */ false);\n        node.parameterName = typePredicateVariable;\n        node.typeAnnotation = type;\n        node.asserts = asserts;\n        t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      });\n    }\n\n    tsTryParseTypeOrTypePredicateAnnotation(): N.TsTypeAnnotation | undefined {\n      if (this.match(tt.colon)) {\n        return this.tsParseTypeOrTypePredicateAnnotation(tt.colon);\n      }\n    }\n\n    tsTryParseTypeAnnotation(): N.TsTypeAnnotation | undefined {\n      if (this.match(tt.colon)) {\n        return this.tsParseTypeAnnotation();\n      }\n    }\n\n    tsTryParseType(): N.TsType | undefined {\n      return this.tsEatThenParseType(tt.colon);\n    }\n\n    tsParseTypePredicatePrefix(): N.Identifier | undefined {\n      const id = this.parseIdentifier();\n      if (this.isContextual(tt._is) && !this.hasPrecedingLineBreak()) {\n        this.next();\n        return id;\n      }\n    }\n\n    tsParseTypePredicateAsserts(): boolean {\n      if (this.state.type !== tt._asserts) {\n        return false;\n      }\n      const containsEsc = this.state.containsEsc;\n      this.next();\n      if (!tokenIsIdentifier(this.state.type) && !this.match(tt._this)) {\n        return false;\n      }\n\n      if (containsEsc) {\n        this.raise(\n          Errors.InvalidEscapedReservedWord,\n          this.state.lastTokStartLoc,\n          {\n            reservedWord: \"asserts\",\n          },\n        );\n      }\n\n      return true;\n    }\n\n    tsParseTypeAnnotation(\n      eatColon = true,\n      t: Undone<N.TsTypeAnnotation> = this.startNode<N.TsTypeAnnotation>(),\n    ): N.TsTypeAnnotation {\n      this.tsInType(() => {\n        if (eatColon) this.expect(tt.colon);\n        t.typeAnnotation = this.tsParseType();\n      });\n      return this.finishNode(t, \"TSTypeAnnotation\");\n    }\n\n    /** Be sure to be in a type context before calling this, using `tsInType`. */\n    tsParseType(): N.TsType {\n      // Need to set `state.inType` so that we don't parse JSX in a type context.\n      assert(this.state.inType);\n      const type = this.tsParseNonConditionalType();\n\n      if (\n        this.state.inDisallowConditionalTypesContext ||\n        this.hasPrecedingLineBreak() ||\n        !this.eat(tt._extends)\n      ) {\n        return type;\n      }\n      const node = this.startNodeAtNode<N.TsConditionalType>(type);\n      node.checkType = type;\n\n      node.extendsType = this.tsInDisallowConditionalTypesContext(() =>\n        this.tsParseNonConditionalType(),\n      );\n\n      this.expect(tt.question);\n      node.trueType = this.tsInAllowConditionalTypesContext(() =>\n        this.tsParseType(),\n      );\n\n      this.expect(tt.colon);\n      node.falseType = this.tsInAllowConditionalTypesContext(() =>\n        this.tsParseType(),\n      );\n\n      return this.finishNode(node, \"TSConditionalType\");\n    }\n\n    isAbstractConstructorSignature(): boolean {\n      return (\n        this.isContextual(tt._abstract) && this.lookahead().type === tt._new\n      );\n    }\n\n    tsParseNonConditionalType(): N.TsType {\n      if (this.tsIsStartOfFunctionType()) {\n        return this.tsParseFunctionOrConstructorType(\"TSFunctionType\");\n      }\n      if (this.match(tt._new)) {\n        // As in `new () => Date`\n        return this.tsParseFunctionOrConstructorType(\"TSConstructorType\");\n      } else if (this.isAbstractConstructorSignature()) {\n        // As in `abstract new () => Date`\n        return this.tsParseFunctionOrConstructorType(\n          \"TSConstructorType\",\n          /* abstract */ true,\n        );\n      }\n      return this.tsParseUnionTypeOrHigher();\n    }\n\n    tsParseTypeAssertion(): N.TsTypeAssertion {\n      if (this.getPluginOption(\"typescript\", \"disallowAmbiguousJSXLike\")) {\n        this.raise(TSErrors.ReservedTypeAssertion, this.state.startLoc);\n      }\n\n      const node = this.startNode<N.TsTypeAssertion>();\n      node.typeAnnotation = this.tsInType(() => {\n        this.next(); // \"<\"\n        return this.match(tt._const)\n          ? this.tsParseTypeReference()\n          : this.tsParseType();\n      });\n      this.expect(tt.gt);\n      node.expression = this.parseMaybeUnary();\n      return this.finishNode(node, \"TSTypeAssertion\");\n    }\n\n    tsParseHeritageClause(token: \"extends\"): Array<N.TSInterfaceHeritage>;\n    tsParseHeritageClause(token: \"implements\"): Array<N.TSClassImplements>;\n    tsParseHeritageClause(\n      token: \"extends\" | \"implements\",\n    ): Array<N.TSClassImplements> | Array<N.TSInterfaceHeritage> {\n      const originalStartLoc = this.state.startLoc;\n\n      const delimitedList = this.tsParseDelimitedList(\n        \"HeritageClauseElement\",\n        () => {\n          if (process.env.BABEL_8_BREAKING) {\n            const expression = super.parseExprSubscripts();\n            if (!tsIsEntityName(expression)) {\n              this.raise(\n                TSErrors.InvalidHeritageClauseType,\n                expression.loc.start,\n                { token },\n              );\n            }\n            const nodeType =\n              token === \"extends\" ? \"TSInterfaceHeritage\" : \"TSClassImplements\";\n            if (expression.type === \"TSInstantiationExpression\") {\n              // @ts-expect-error cast TSInstantiationExpression to TSInterfaceHeritage/TSClassImplements\n              expression.type = nodeType;\n              return expression;\n            }\n            const node = this.startNodeAtNode<\n              N.TSInterfaceHeritage | N.TSClassImplements\n            >(expression);\n            node.expression = expression;\n            // The last element can not form a TSInstantiationExpression because of the bail condition in\n            // `parseSubscript`, in this case we have to parse type arguments again\n            if (this.match(tt.lt) || this.match(tt.bitShiftL)) {\n              node.typeArguments = this.tsParseTypeArgumentsInExpression();\n            }\n            return this.finishNode(node, nodeType);\n          } else {\n            const node = this.startNode<\n              N.TSInterfaceHeritage | N.TSClassImplements\n            >();\n            // @ts-expect-error Babel 7 vs Babel 8\n            node.expression = this.tsParseEntityName(\n              tsParseEntityNameFlags.ALLOW_RESERVED_WORDS |\n                tsParseEntityNameFlags.LEADING_THIS_AS_IDENTIFIER,\n            );\n            if (this.match(tt.lt)) {\n              // @ts-expect-error Babel 7 vs Babel 8\n              node.typeParameters = this.tsParseTypeArguments();\n            }\n\n            return this.finishNode(\n              node,\n              // @ts-expect-error Babel 7 vs Babel 8\n              \"TSExpressionWithTypeArguments\",\n            );\n          }\n        },\n      );\n\n      if (!delimitedList.length) {\n        this.raise(TSErrors.EmptyHeritageClauseType, originalStartLoc, {\n          token,\n        });\n      }\n\n      return delimitedList as\n        | Array<N.TSClassImplements>\n        | Array<N.TSInterfaceHeritage>;\n    }\n\n    tsParseInterfaceDeclaration(\n      node: Undone<N.TsInterfaceDeclaration>,\n      properties: {\n        declare?: true;\n      } = {},\n    ): N.TsInterfaceDeclaration | null {\n      if (this.hasFollowingLineBreak()) return null;\n      this.expectContextual(tt._interface);\n      if (properties.declare) node.declare = true;\n      if (tokenIsIdentifier(this.state.type)) {\n        node.id = this.parseIdentifier();\n        this.checkIdentifier(node.id, BindingFlag.TYPE_TS_INTERFACE);\n      } else {\n        node.id = null;\n        this.raise(TSErrors.MissingInterfaceName, this.state.startLoc);\n      }\n\n      node.typeParameters = this.tsTryParseTypeParameters(\n        this.tsParseInOutConstModifiers,\n      );\n      if (this.eat(tt._extends)) {\n        node.extends = this.tsParseHeritageClause(\"extends\");\n      }\n      const body = this.startNode<N.TSInterfaceBody>();\n      body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));\n      node.body = this.finishNode(body, \"TSInterfaceBody\");\n      return this.finishNode(node, \"TSInterfaceDeclaration\");\n    }\n\n    tsParseTypeAliasDeclaration(\n      node: N.TsTypeAliasDeclaration,\n    ): N.TsTypeAliasDeclaration {\n      node.id = this.parseIdentifier();\n      this.checkIdentifier(node.id, BindingFlag.TYPE_TS_TYPE);\n\n      node.typeAnnotation = this.tsInType(() => {\n        node.typeParameters = this.tsTryParseTypeParameters(\n          this.tsParseInOutModifiers,\n        );\n\n        this.expect(tt.eq);\n\n        if (\n          this.isContextual(tt._intrinsic) &&\n          this.lookahead().type !== tt.dot\n        ) {\n          const node = this.startNode<N.TsKeywordType>();\n          this.next();\n          return this.finishNode(node, \"TSIntrinsicKeyword\");\n        }\n\n        return this.tsParseType();\n      });\n\n      this.semicolon();\n      return this.finishNode(node, \"TSTypeAliasDeclaration\");\n    }\n\n    // Parse in top level normal context if we are in a JSX context\n    tsInTopLevelContext<T>(cb: () => T): T {\n      if (this.curContext() !== tc.brace) {\n        const oldContext = this.state.context;\n        this.state.context = [oldContext[0]];\n        try {\n          return cb();\n        } finally {\n          this.state.context = oldContext;\n        }\n      } else {\n        return cb();\n      }\n    }\n\n    /**\n     * Runs `cb` in a type context.\n     * This should be called one token *before* the first type token,\n     * so that the call to `next()` is run in type context.\n     */\n    tsInType<T>(cb: () => T): T {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n      try {\n        return cb();\n      } finally {\n        this.state.inType = oldInType;\n      }\n    }\n\n    tsInDisallowConditionalTypesContext<T>(cb: () => T): T {\n      const oldInDisallowConditionalTypesContext =\n        this.state.inDisallowConditionalTypesContext;\n      this.state.inDisallowConditionalTypesContext = true;\n      try {\n        return cb();\n      } finally {\n        this.state.inDisallowConditionalTypesContext =\n          oldInDisallowConditionalTypesContext;\n      }\n    }\n\n    tsInAllowConditionalTypesContext<T>(cb: () => T): T {\n      const oldInDisallowConditionalTypesContext =\n        this.state.inDisallowConditionalTypesContext;\n      this.state.inDisallowConditionalTypesContext = false;\n      try {\n        return cb();\n      } finally {\n        this.state.inDisallowConditionalTypesContext =\n          oldInDisallowConditionalTypesContext;\n      }\n    }\n\n    tsEatThenParseType(token: TokenType): N.TsType | undefined {\n      if (this.match(token)) {\n        return this.tsNextThenParseType();\n      }\n    }\n\n    tsExpectThenParseType(token: TokenType): N.TsType {\n      return this.tsInType(() => {\n        this.expect(token);\n        return this.tsParseType();\n      });\n    }\n\n    tsNextThenParseType(): N.TsType {\n      return this.tsInType(() => {\n        this.next();\n        return this.tsParseType();\n      });\n    }\n\n    tsParseEnumMember(): N.TsEnumMember {\n      const node = this.startNode<N.TsEnumMember>();\n      // Computed property names are grammar errors in an enum, so accept just string literal or identifier.\n      node.id = this.match(tt.string)\n        ? super.parseStringLiteral(this.state.value)\n        : this.parseIdentifier(/* liberal */ true);\n      if (this.eat(tt.eq)) {\n        node.initializer = super.parseMaybeAssignAllowIn();\n      }\n      return this.finishNode(node, \"TSEnumMember\");\n    }\n\n    tsParseEnumDeclaration(\n      node: Undone<N.TsEnumDeclaration>,\n      properties: {\n        const?: true;\n        declare?: true;\n      } = {},\n    ): N.TsEnumDeclaration {\n      if (properties.const) node.const = true;\n      if (properties.declare) node.declare = true;\n      this.expectContextual(tt._enum);\n      node.id = this.parseIdentifier();\n      this.checkIdentifier(\n        node.id,\n        node.const ? BindingFlag.TYPE_TS_CONST_ENUM : BindingFlag.TYPE_TS_ENUM,\n      );\n\n      if (process.env.BABEL_8_BREAKING) {\n        node.body = this.tsParseEnumBody();\n      } else {\n        this.expect(tt.braceL);\n        node.members = this.tsParseDelimitedList(\n          \"EnumMembers\",\n          this.tsParseEnumMember.bind(this),\n        );\n        this.expect(tt.braceR);\n      }\n      return this.finishNode(node, \"TSEnumDeclaration\");\n    }\n\n    tsParseEnumBody(): N.TsEnumBody {\n      const node = this.startNode<N.TsEnumBody>();\n      this.expect(tt.braceL);\n      node.members = this.tsParseDelimitedList(\n        \"EnumMembers\",\n        this.tsParseEnumMember.bind(this),\n      );\n      this.expect(tt.braceR);\n      return this.finishNode(node, \"TSEnumBody\");\n    }\n\n    tsParseModuleBlock(): N.TsModuleBlock {\n      const node = this.startNode<N.TsModuleBlock>();\n      this.scope.enter(ScopeFlag.OTHER);\n\n      this.expect(tt.braceL);\n      // Inside of a module block is considered \"top-level\", meaning it can have imports and exports.\n      super.parseBlockOrModuleBlockBody(\n        (node.body = []),\n        /* directives */ undefined,\n        /* topLevel */ true,\n        /* end */ tt.braceR,\n      );\n      this.scope.exit();\n      return this.finishNode(node, \"TSModuleBlock\");\n    }\n\n    tsParseModuleOrNamespaceDeclaration(\n      node: Undone<N.TsModuleDeclaration>,\n      nested: boolean = false,\n    ): N.TsModuleDeclaration {\n      node.id = process.env.BABEL_8_BREAKING\n        ? this.tsParseEntityName(tsParseEntityNameFlags.ALLOW_RESERVED_WORDS)\n        : this.parseIdentifier();\n\n      if (\n        process.env.BABEL_8_BREAKING ? node.id.type === \"Identifier\" : !nested\n      ) {\n        // @ts-expect-error checked above\n        this.checkIdentifier(node.id, BindingFlag.TYPE_TS_NAMESPACE);\n      }\n\n      if (!process.env.BABEL_8_BREAKING && this.eat(tt.dot)) {\n        const inner = this.startNode<N.TsModuleDeclaration>();\n        this.tsParseModuleOrNamespaceDeclaration(inner, true);\n        // @ts-expect-error Fixme: refine typings\n        node.body = inner;\n      } else {\n        this.scope.enter(ScopeFlag.TS_MODULE);\n        this.prodParam.enter(ParamKind.PARAM);\n        node.body = this.tsParseModuleBlock();\n        this.prodParam.exit();\n        this.scope.exit();\n      }\n      return this.finishNode(node, \"TSModuleDeclaration\");\n    }\n\n    tsParseAmbientExternalModuleDeclaration(\n      node: N.TsModuleDeclaration,\n    ): N.TsModuleDeclaration {\n      if (this.isContextual(tt._global)) {\n        node.kind = \"global\";\n        if (!process.env.BABEL_8_BREAKING) {\n          node.global = true;\n        }\n        node.id = this.parseIdentifier();\n      } else if (this.match(tt.string)) {\n        node.kind = \"module\";\n        node.id = super.parseStringLiteral(this.state.value);\n      } else {\n        this.unexpected();\n      }\n      if (this.match(tt.braceL)) {\n        this.scope.enter(ScopeFlag.TS_MODULE);\n        this.prodParam.enter(ParamKind.PARAM);\n        node.body = this.tsParseModuleBlock();\n        this.prodParam.exit();\n        this.scope.exit();\n      } else {\n        this.semicolon();\n      }\n\n      return this.finishNode(node, \"TSModuleDeclaration\");\n    }\n\n    tsParseImportEqualsDeclaration(\n      node: Undone<N.TsImportEqualsDeclaration>,\n      maybeDefaultIdentifier?: N.Identifier | null,\n      isExport?: boolean,\n    ): N.TsImportEqualsDeclaration {\n      if (!process.env.BABEL_8_BREAKING) {\n        node.isExport = isExport || false;\n      }\n      node.id = maybeDefaultIdentifier || this.parseIdentifier();\n      this.checkIdentifier(node.id, BindingFlag.TYPE_TS_VALUE_IMPORT);\n      this.expect(tt.eq);\n      const moduleReference = this.tsParseModuleReference();\n      if (\n        node.importKind === \"type\" &&\n        moduleReference.type !== \"TSExternalModuleReference\"\n      ) {\n        this.raise(TSErrors.ImportAliasHasImportType, moduleReference);\n      }\n      node.moduleReference = moduleReference;\n      this.semicolon();\n      return this.finishNode(node, \"TSImportEqualsDeclaration\");\n    }\n\n    tsIsExternalModuleReference(): boolean {\n      return (\n        this.isContextual(tt._require) &&\n        this.lookaheadCharCode() === charCodes.leftParenthesis\n      );\n    }\n\n    tsParseModuleReference(): N.TsModuleReference {\n      return this.tsIsExternalModuleReference()\n        ? this.tsParseExternalModuleReference()\n        : this.tsParseEntityName(tsParseEntityNameFlags.NONE);\n    }\n\n    tsParseExternalModuleReference(): N.TsExternalModuleReference {\n      const node = this.startNode<N.TsExternalModuleReference>();\n      this.expectContextual(tt._require);\n      this.expect(tt.parenL);\n      if (!this.match(tt.string)) {\n        this.unexpected();\n      }\n      // For compatibility to estree we cannot call parseLiteral directly here\n      node.expression = super.parseExprAtom() as N.StringLiteral;\n      this.expect(tt.parenR);\n      this.sawUnambiguousESM = true;\n      return this.finishNode(node, \"TSExternalModuleReference\");\n    }\n\n    // Utilities\n\n    tsLookAhead<T>(f: () => T): T {\n      const state = this.state.clone();\n      const res = f();\n      this.state = state;\n      return res;\n    }\n\n    tsTryParseAndCatch<T extends N.NodeBase | undefined | null>(\n      f: () => T,\n    ): T | undefined | null {\n      const result = this.tryParse(\n        abort =>\n          // @ts-expect-error todo(flow->ts)\n          f() || abort(),\n      );\n\n      if (result.aborted || !result.node) return;\n      if (result.error) this.state = result.failState;\n      // @ts-expect-error refine typings\n      return result.node;\n    }\n\n    tsTryParse<T>(f: () => T | undefined | false): T | undefined {\n      const state = this.state.clone();\n      const result = f();\n      if (result !== undefined && result !== false) {\n        return result;\n      }\n      this.state = state;\n    }\n\n    tsTryParseDeclare(nany: any) {\n      if (this.isLineTerminator()) {\n        return;\n      }\n      let startType = this.state.type;\n      let kind: \"let\" | null;\n\n      if (this.isContextual(tt._let)) {\n        startType = tt._var;\n        kind = \"let\";\n      }\n\n      return this.tsInAmbientContext(() => {\n        switch (startType) {\n          case tt._function:\n            nany.declare = true;\n            return super.parseFunctionStatement(\n              nany,\n              /* async */ false,\n              /* isHangingDeclaration */ false,\n            );\n          case tt._class:\n            // While this is also set by tsParseExpressionStatement, we need to set it\n            // before parsing the class declaration to know how to register it in the scope.\n            nany.declare = true;\n            return this.parseClass(\n              nany as Undone<N.ClassDeclaration>,\n              /* isStatement */ true,\n              /* optionalId */ false,\n            );\n          case tt._enum:\n            return this.tsParseEnumDeclaration(nany, { declare: true });\n          case tt._global:\n            return this.tsParseAmbientExternalModuleDeclaration(nany);\n          case tt._const:\n          case tt._var:\n            if (!this.match(tt._const) || !this.isLookaheadContextual(\"enum\")) {\n              nany.declare = true;\n              return this.parseVarStatement(\n                nany,\n                kind || this.state.value,\n                true,\n              );\n            }\n\n            // `const enum = 0;` not allowed because \"enum\" is a strict mode reserved word.\n            this.expect(tt._const);\n            return this.tsParseEnumDeclaration(nany, {\n              const: true,\n              declare: true,\n            });\n          case tt._interface: {\n            const result = this.tsParseInterfaceDeclaration(nany, {\n              declare: true,\n            });\n            if (result) return result;\n          }\n          // fallthrough\n          default:\n            if (tokenIsIdentifier(startType)) {\n              return this.tsParseDeclaration(\n                nany,\n                this.state.value,\n                /* next */ true,\n                /* decorators */ null,\n              );\n            }\n        }\n      });\n    }\n\n    // Note: this won't be called unless the keyword is allowed in `shouldParseExportDeclaration`.\n    tsTryParseExportDeclaration(): N.Declaration | undefined {\n      return this.tsParseDeclaration(\n        this.startNode(),\n        this.state.value,\n        /* next */ true,\n        /* decorators */ null,\n      );\n    }\n\n    tsParseExpressionStatement(\n      node: Undone<N.TsModuleDeclaration>,\n      expr: N.Identifier,\n      decorators: N.Decorator[] | null,\n    ): N.Declaration | undefined {\n      switch (expr.name) {\n        case \"declare\": {\n          const declaration = this.tsTryParseDeclare(node);\n          if (declaration) {\n            declaration.declare = true;\n          }\n          return declaration;\n        }\n        case \"global\":\n          // `global { }` (with no `declare`) may appear inside an ambient module declaration.\n          // Would like to use tsParseAmbientExternalModuleDeclaration here, but already ran past \"global\".\n          if (this.match(tt.braceL)) {\n            this.scope.enter(ScopeFlag.TS_MODULE);\n            this.prodParam.enter(ParamKind.PARAM);\n            const mod = node;\n            mod.kind = \"global\";\n            if (!process.env.BABEL_8_BREAKING) {\n              node.global = true;\n            }\n            mod.id = expr;\n            mod.body = this.tsParseModuleBlock();\n            this.scope.exit();\n            this.prodParam.exit();\n            return this.finishNode(mod, \"TSModuleDeclaration\");\n          }\n          break;\n\n        default:\n          return this.tsParseDeclaration(\n            node,\n            expr.name,\n            /* next */ false,\n            decorators,\n          );\n      }\n    }\n\n    // Common to tsTryParseDeclare, tsTryParseExportDeclaration, and tsParseExpressionStatement.\n    tsParseDeclaration(\n      node: any,\n      value: string,\n      next: boolean,\n      decorators: N.Decorator[] | null,\n    ) {\n      // no declaration apart from enum can be followed by a line break.\n      switch (value) {\n        case \"abstract\":\n          if (\n            this.tsCheckLineTerminator(next) &&\n            (this.match(tt._class) || tokenIsIdentifier(this.state.type))\n          ) {\n            return this.tsParseAbstractDeclaration(node, decorators);\n          }\n          break;\n\n        case \"module\":\n          if (this.tsCheckLineTerminator(next)) {\n            if (this.match(tt.string)) {\n              return this.tsParseAmbientExternalModuleDeclaration(node);\n            } else if (tokenIsIdentifier(this.state.type)) {\n              node.kind = \"module\";\n              return this.tsParseModuleOrNamespaceDeclaration(node);\n            }\n          }\n          break;\n\n        case \"namespace\":\n          if (\n            this.tsCheckLineTerminator(next) &&\n            tokenIsIdentifier(this.state.type)\n          ) {\n            node.kind = \"namespace\";\n            return this.tsParseModuleOrNamespaceDeclaration(node);\n          }\n          break;\n\n        case \"type\":\n          if (\n            this.tsCheckLineTerminator(next) &&\n            tokenIsIdentifier(this.state.type)\n          ) {\n            return this.tsParseTypeAliasDeclaration(node);\n          }\n          break;\n      }\n    }\n\n    tsCheckLineTerminator(next: boolean) {\n      if (next) {\n        if (this.hasFollowingLineBreak()) return false;\n        this.next();\n        return true;\n      }\n      return !this.isLineTerminator();\n    }\n\n    tsTryParseGenericAsyncArrowFunction(\n      startLoc: Position,\n    ): N.ArrowFunctionExpression | undefined {\n      if (!this.match(tt.lt)) return;\n\n      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n      this.state.maybeInArrowParameters = true;\n\n      const res: Undone<N.ArrowFunctionExpression> | undefined =\n        this.tsTryParseAndCatch(() => {\n          const node = this.startNodeAt<N.ArrowFunctionExpression>(startLoc);\n          node.typeParameters = this.tsParseTypeParameters(\n            this.tsParseConstModifier,\n          );\n          // Don't use overloaded parseFunctionParams which would look for \"<\" again.\n          super.parseFunctionParams(node);\n          node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();\n          this.expect(tt.arrow);\n          return node;\n        });\n\n      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n\n      if (!res) return;\n\n      return super.parseArrowExpression(\n        res,\n        /* params are already set */ null,\n        /* async */ true,\n      );\n    }\n\n    // Used when parsing type arguments from ES or JSX productions, where the first token\n    // has been created without state.inType. Thus we need to re-scan the lt token.\n    tsParseTypeArgumentsInExpression():\n      | N.TsTypeParameterInstantiation\n      | undefined {\n      if (this.reScan_lt() !== tt.lt) return;\n      return this.tsParseTypeArguments();\n    }\n\n    tsParseTypeArguments(): N.TsTypeParameterInstantiation {\n      const node = this.startNode<N.TsTypeParameterInstantiation>();\n      node.params = this.tsInType(() =>\n        this.tsInTopLevelContext(() => {\n          this.expect(tt.lt);\n          return this.tsParseDelimitedList(\n            \"TypeParametersOrArguments\",\n            this.tsParseType.bind(this),\n          );\n        }),\n      );\n      if (node.params.length === 0) {\n        this.raise(TSErrors.EmptyTypeArguments, node);\n      } else if (!this.state.inType && this.curContext() === tc.brace) {\n        // rescan `>` when we are no longer in type context and JSX parsing context\n        // since it was tokenized when `inType` is `true`.\n        this.reScan_lt_gt();\n      }\n      this.expect(tt.gt);\n      return this.finishNode(node, \"TSTypeParameterInstantiation\");\n    }\n\n    tsIsDeclarationStart(): boolean {\n      return tokenIsTSDeclarationStart(this.state.type);\n    }\n\n    // ======================================================\n    // OVERRIDES\n    // ======================================================\n\n    isExportDefaultSpecifier(): boolean {\n      if (this.tsIsDeclarationStart()) return false;\n      return super.isExportDefaultSpecifier();\n    }\n\n    parseBindingElement(\n      flags: ParseBindingListFlags,\n      decorators: N.Decorator[],\n    ): N.Pattern | N.TSParameterProperty {\n      // Store original location to include modifiers in range\n      const startLoc = this.state.startLoc;\n\n      const modified: ModifierBase = {};\n      this.tsParseModifiers(\n        {\n          allowedModifiers: [\n            \"public\",\n            \"private\",\n            \"protected\",\n            \"override\",\n            \"readonly\",\n          ],\n        },\n        modified,\n      );\n      const accessibility = modified.accessibility;\n      const override = modified.override;\n      const readonly = modified.readonly;\n      if (\n        !(flags & ParseBindingListFlags.IS_CONSTRUCTOR_PARAMS) &&\n        (accessibility || readonly || override)\n      ) {\n        this.raise(TSErrors.UnexpectedParameterModifier, startLoc);\n      }\n\n      const left = this.parseMaybeDefault();\n      if (flags & ParseBindingListFlags.IS_FUNCTION_PARAMS) {\n        this.parseFunctionParamType(left);\n      }\n      const elt = this.parseMaybeDefault(left.loc.start, left);\n      if (accessibility || readonly || override) {\n        const pp = this.startNodeAt<N.TSParameterProperty>(startLoc);\n        if (decorators.length) {\n          pp.decorators = decorators;\n        }\n        if (accessibility) pp.accessibility = accessibility;\n        if (readonly) pp.readonly = readonly;\n        if (override) pp.override = override;\n        if (elt.type !== \"Identifier\" && elt.type !== \"AssignmentPattern\") {\n          this.raise(TSErrors.UnsupportedParameterPropertyKind, pp);\n        }\n        pp.parameter = elt as any as N.Identifier | N.AssignmentPattern;\n        return this.finishNode(pp, \"TSParameterProperty\");\n      }\n\n      if (decorators.length) {\n        left.decorators = decorators;\n      }\n\n      return elt;\n    }\n\n    isSimpleParameter(node: N.Pattern | N.TSParameterProperty): boolean {\n      return (\n        (node.type === \"TSParameterProperty\" &&\n          super.isSimpleParameter(node.parameter)) ||\n        super.isSimpleParameter(node)\n      );\n    }\n\n    tsDisallowOptionalPattern(node: Undone<N.Function>) {\n      for (const param of node.params) {\n        if (\n          param.type !== \"Identifier\" &&\n          (param as any).optional &&\n          !this.state.isAmbientContext\n        ) {\n          this.raise(TSErrors.PatternIsOptional, param);\n        }\n      }\n    }\n\n    setArrowFunctionParameters(\n      node: Undone<N.ArrowFunctionExpression>,\n      params: N.Expression[],\n      trailingCommaLoc?: Position | null,\n    ): void {\n      super.setArrowFunctionParameters(node, params, trailingCommaLoc);\n      this.tsDisallowOptionalPattern(node);\n    }\n\n    parseFunctionBodyAndFinish<\n      T extends\n        | N.Function\n        | N.TSDeclareMethod\n        | N.TSDeclareFunction\n        | N.ClassPrivateMethod,\n    >(node: Undone<T>, type: T[\"type\"], isMethod: boolean = false): T {\n      if (this.match(tt.colon)) {\n        node.returnType = this.tsParseTypeOrTypePredicateAnnotation(tt.colon);\n      }\n\n      const bodilessType =\n        type === \"FunctionDeclaration\"\n          ? \"TSDeclareFunction\"\n          : type === \"ClassMethod\" || type === \"ClassPrivateMethod\"\n            ? \"TSDeclareMethod\"\n            : undefined;\n      if (bodilessType && !this.match(tt.braceL) && this.isLineTerminator()) {\n        return this.finishNode(node, bodilessType);\n      }\n      if (bodilessType === \"TSDeclareFunction\" && this.state.isAmbientContext) {\n        this.raise(TSErrors.DeclareFunctionHasImplementation, node);\n        if ((node as Undone<N.FunctionDeclaration>).declare) {\n          return super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);\n        }\n      }\n      this.tsDisallowOptionalPattern(node);\n\n      return super.parseFunctionBodyAndFinish(node, type, isMethod);\n    }\n\n    registerFunctionStatementId(node: N.Function): void {\n      if (!node.body && node.id) {\n        // Function ids are validated after parsing their body.\n        // For bodiless function, we need to do it here.\n        this.checkIdentifier(node.id, BindingFlag.TYPE_TS_AMBIENT);\n      } else {\n        super.registerFunctionStatementId(node);\n      }\n    }\n\n    tsCheckForInvalidTypeCasts(items: Array<N.Expression | N.SpreadElement>) {\n      items.forEach(node => {\n        if (node?.type === \"TSTypeCastExpression\") {\n          this.raise(TSErrors.UnexpectedTypeAnnotation, node.typeAnnotation);\n        }\n      });\n    }\n\n    toReferencedList(\n      exprList: Array<N.Expression | undefined | null>,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      isInParens?: boolean,\n    ): Array<N.Expression | undefined | null> {\n      // Handles invalid scenarios like: `f(a:b)`, `(a:b);`, and `(a:b,c:d)`.\n      //\n      // Note that `f<T>(a:b)` goes through a different path and is handled\n      // in `parseSubscript` directly.\n      this.tsCheckForInvalidTypeCasts(exprList);\n      return exprList;\n    }\n\n    parseArrayLike(\n      close: TokenType,\n      canBePattern: boolean,\n      isTuple: boolean,\n      refExpressionErrors?: ExpressionErrors | null,\n    ): N.ArrayExpression | N.TupleExpression {\n      const node = super.parseArrayLike(\n        close,\n        canBePattern,\n        isTuple,\n        refExpressionErrors,\n      );\n\n      if (node.type === \"ArrayExpression\") {\n        this.tsCheckForInvalidTypeCasts(node.elements);\n      }\n\n      return node;\n    }\n\n    parseSubscript(\n      base: N.Expression,\n\n      startLoc: Position,\n      noCalls: boolean | undefined | null,\n      state: N.ParseSubscriptState,\n    ): N.Expression {\n      if (!this.hasPrecedingLineBreak() && this.match(tt.bang)) {\n        // When ! is consumed as a postfix operator (non-null assertion),\n        // disallow JSX tag forming after. e.g. When parsing `p! < n.p!`\n        // `<n.p` can not be a start of JSX tag\n        this.state.canStartJSXElement = false;\n        this.next();\n\n        const nonNullExpression =\n          this.startNodeAt<N.TsNonNullExpression>(startLoc);\n        nonNullExpression.expression = base;\n        return this.finishNode(nonNullExpression, \"TSNonNullExpression\");\n      }\n\n      let isOptionalCall = false;\n      if (\n        this.match(tt.questionDot) &&\n        this.lookaheadCharCode() === charCodes.lessThan\n      ) {\n        if (noCalls) {\n          state.stop = true;\n          return base;\n        }\n        state.optionalChainMember = isOptionalCall = true;\n        this.next();\n      }\n\n      // handles 'f<<T>'\n      if (this.match(tt.lt) || this.match(tt.bitShiftL)) {\n        let missingParenErrorLoc;\n        // tsTryParseAndCatch is expensive, so avoid if not necessary.\n        // There are number of things we are going to \"maybe\" parse, like type arguments on\n        // tagged template expressions. If any of them fail, walk it back and continue.\n        const result = this.tsTryParseAndCatch(() => {\n          if (!noCalls && this.atPossibleAsyncArrow(base)) {\n            // Almost certainly this is a generic async function `async <T>() => ...\n            // But it might be a call with a type argument `async<T>();`\n            const asyncArrowFn =\n              this.tsTryParseGenericAsyncArrowFunction(startLoc);\n            if (asyncArrowFn) {\n              return asyncArrowFn;\n            }\n          }\n\n          const typeArguments = this.tsParseTypeArgumentsInExpression();\n          if (!typeArguments) return;\n\n          if (isOptionalCall && !this.match(tt.parenL)) {\n            missingParenErrorLoc = this.state.curPosition();\n            return;\n          }\n\n          if (tokenIsTemplate(this.state.type)) {\n            const result = super.parseTaggedTemplateExpression(\n              base,\n              startLoc,\n              state,\n            );\n            if (process.env.BABEL_8_BREAKING) {\n              result.typeArguments = typeArguments;\n            } else {\n              result.typeParameters = typeArguments;\n            }\n            return result;\n          }\n\n          if (!noCalls && this.eat(tt.parenL)) {\n            const node = this.startNodeAt<\n              N.CallExpression | N.OptionalCallExpression\n            >(startLoc);\n            node.callee = base;\n            // @ts-expect-error (won't be any undefined arguments)\n            node.arguments = this.parseCallExpressionArguments(tt.parenR);\n\n            // Handles invalid case: `f<T>(a:b)`\n            this.tsCheckForInvalidTypeCasts(node.arguments);\n\n            if (process.env.BABEL_8_BREAKING) {\n              node.typeArguments = typeArguments;\n            } else {\n              node.typeParameters = typeArguments;\n            }\n\n            if (state.optionalChainMember) {\n              (node as Undone<N.OptionalCallExpression>).optional =\n                isOptionalCall;\n            }\n\n            return this.finishCallExpression(node, state.optionalChainMember);\n          }\n\n          const tokenType = this.state.type;\n          if (\n            // a<b>>c is not (a<b>)>c, but a<(b>>c)\n            tokenType === tt.gt ||\n            // a<b>>>c is not (a<b>)>>c, but a<(b>>>c)\n            tokenType === tt.bitShiftR ||\n            // a<b>c is (a<b)>c\n            (tokenType !== tt.parenL &&\n              tokenCanStartExpression(tokenType) &&\n              !this.hasPrecedingLineBreak())\n          ) {\n            // Bail out.\n            return;\n          }\n\n          const node = this.startNodeAt<N.TsInstantiationExpression>(startLoc);\n          node.expression = base;\n          if (process.env.BABEL_8_BREAKING) {\n            node.typeArguments = typeArguments;\n          } else {\n            node.typeParameters = typeArguments;\n          }\n          return this.finishNode(node, \"TSInstantiationExpression\");\n        });\n\n        if (missingParenErrorLoc) {\n          this.unexpected(missingParenErrorLoc, tt.parenL);\n        }\n\n        if (result) {\n          if (\n            result.type === \"TSInstantiationExpression\" &&\n            (this.match(tt.dot) ||\n              (this.match(tt.questionDot) &&\n                this.lookaheadCharCode() !== charCodes.leftParenthesis))\n          ) {\n            this.raise(\n              TSErrors.InvalidPropertyAccessAfterInstantiationExpression,\n              this.state.startLoc,\n            );\n          }\n          return result;\n        }\n      }\n\n      return super.parseSubscript(base, startLoc, noCalls, state);\n    }\n\n    parseNewCallee(node: N.NewExpression): void {\n      super.parseNewCallee(node);\n\n      const { callee } = node;\n      if (\n        callee.type === \"TSInstantiationExpression\" &&\n        !callee.extra?.parenthesized\n      ) {\n        if (process.env.BABEL_8_BREAKING) {\n          node.typeArguments = callee.typeArguments;\n        } else {\n          node.typeParameters = callee.typeParameters;\n        }\n        node.callee = callee.expression;\n      }\n    }\n\n    parseExprOp(\n      left: N.Expression,\n      leftStartLoc: Position,\n      minPrec: number,\n    ): N.Expression {\n      let isSatisfies: boolean;\n      if (\n        tokenOperatorPrecedence(tt._in) > minPrec &&\n        !this.hasPrecedingLineBreak() &&\n        (this.isContextual(tt._as) ||\n          (isSatisfies = this.isContextual(tt._satisfies)))\n      ) {\n        const node = this.startNodeAt<\n          N.TsAsExpression | N.TsSatisfiesExpression\n        >(leftStartLoc);\n        node.expression = left;\n        node.typeAnnotation = this.tsInType(() => {\n          this.next(); // \"as\" or \"satisfies\"\n          if (this.match(tt._const)) {\n            if (isSatisfies) {\n              this.raise(Errors.UnexpectedKeyword, this.state.startLoc, {\n                keyword: \"const\",\n              });\n            }\n            return this.tsParseTypeReference();\n          }\n\n          return this.tsParseType();\n        });\n        this.finishNode(\n          node,\n          isSatisfies ? \"TSSatisfiesExpression\" : \"TSAsExpression\",\n        );\n        // rescan `<`, `>` because they were scanned when this.state.inType was true\n        this.reScan_lt_gt();\n        return this.parseExprOp(\n          // @ts-expect-error todo(flow->ts)\n          node,\n          leftStartLoc,\n          minPrec,\n        );\n      }\n\n      return super.parseExprOp(left, leftStartLoc, minPrec);\n    }\n\n    checkReservedWord(\n      word: string,\n      startLoc: Position,\n      checkKeywords: boolean,\n      isBinding: boolean,\n    ): void {\n      // Strict mode words may be allowed as in `declare namespace N { const static: number; }`.\n      // And we have a type checker anyway, so don't bother having the parser do it.\n      if (!this.state.isAmbientContext) {\n        super.checkReservedWord(word, startLoc, checkKeywords, isBinding);\n      }\n    }\n\n    checkImportReflection(node: Undone<N.ImportDeclaration>) {\n      super.checkImportReflection(node);\n      if (node.module && node.importKind !== \"value\") {\n        this.raise(\n          TSErrors.ImportReflectionHasImportType,\n          node.specifiers[0].loc.start,\n        );\n      }\n    }\n\n    /*\n    Don't bother doing this check in TypeScript code because:\n    1. We may have a nested export statement with the same name:\n      export const x = 0;\n      export namespace N {\n        export const x = 1;\n      }\n    2. We have a type checker to warn us about this sort of thing.\n    */\n    checkDuplicateExports() {}\n\n    isPotentialImportPhase(isExport: boolean): boolean {\n      if (super.isPotentialImportPhase(isExport)) return true;\n      if (this.isContextual(tt._type)) {\n        const ch = this.lookaheadCharCode();\n        return isExport\n          ? ch === charCodes.leftCurlyBrace || ch === charCodes.asterisk\n          : ch !== charCodes.equalsTo;\n      }\n      return !isExport && this.isContextual(tt._typeof);\n    }\n\n    applyImportPhase(\n      node: Undone<N.ImportDeclaration | N.ExportNamedDeclaration>,\n      isExport: boolean,\n      phase: string | null,\n      loc?: Position,\n    ): void {\n      super.applyImportPhase(node, isExport, phase, loc);\n      if (isExport) {\n        (node as N.ExportNamedDeclaration).exportKind =\n          phase === \"type\" ? \"type\" : \"value\";\n      } else {\n        (node as N.ImportDeclaration).importKind =\n          phase === \"type\" || phase === \"typeof\" ? phase : \"value\";\n      }\n    }\n\n    parseImport(\n      node: Undone<N.ImportDeclaration | N.TsImportEqualsDeclaration>,\n    ): N.AnyImport {\n      if (this.match(tt.string)) {\n        node.importKind = \"value\";\n        return super.parseImport(node as Undone<N.ImportDeclaration>);\n      }\n\n      let importNode;\n      if (\n        tokenIsIdentifier(this.state.type) &&\n        this.lookaheadCharCode() === charCodes.equalsTo\n      ) {\n        node.importKind = \"value\";\n        return this.tsParseImportEqualsDeclaration(\n          node as Undone<N.TsImportEqualsDeclaration>,\n        );\n      } else if (this.isContextual(tt._type)) {\n        const maybeDefaultIdentifier = this.parseMaybeImportPhase(\n          node as Undone<N.ImportDeclaration>,\n          /* isExport */ false,\n        );\n        if (this.lookaheadCharCode() === charCodes.equalsTo) {\n          return this.tsParseImportEqualsDeclaration(\n            node as Undone<N.TsImportEqualsDeclaration>,\n            maybeDefaultIdentifier,\n          );\n        } else {\n          importNode = super.parseImportSpecifiersAndAfter(\n            node as Undone<N.ImportDeclaration>,\n            maybeDefaultIdentifier,\n          );\n        }\n      } else {\n        importNode = super.parseImport(node as Undone<N.ImportDeclaration>);\n      }\n\n      // `import type` can only be used on imports with named imports or with a\n      // default import - but not both\n      if (\n        importNode.importKind === \"type\" &&\n        // @ts-expect-error refine typings\n        importNode.specifiers.length > 1 &&\n        // @ts-expect-error refine typings\n        importNode.specifiers[0].type === \"ImportDefaultSpecifier\"\n      ) {\n        this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, importNode);\n      }\n\n      return importNode;\n    }\n\n    parseExport(\n      node: Undone<\n        | N.ExportDefaultDeclaration\n        | N.ExportAllDeclaration\n        | N.ExportNamedDeclaration\n      >,\n      decorators: N.Decorator[] | null,\n    ): N.AnyExport {\n      if (this.match(tt._import)) {\n        // `export import A = B;`\n        const nodeImportEquals = process.env.BABEL_8_BREAKING\n          ? this.startNode<N.TsImportEqualsDeclaration>()\n          : (node as Undone<N.TsImportEqualsDeclaration>);\n        this.next(); // eat `tt._import`\n        let maybeDefaultIdentifier: N.Identifier | null = null;\n        if (\n          this.isContextual(tt._type) &&\n          // We pass false here, because we are parsing an `import ... =`\n          this.isPotentialImportPhase(/* isExport */ false)\n        ) {\n          maybeDefaultIdentifier = this.parseMaybeImportPhase(\n            nodeImportEquals,\n            /* isExport */ false,\n          );\n        } else {\n          nodeImportEquals.importKind = \"value\";\n        }\n        const declaration = this.tsParseImportEqualsDeclaration(\n          nodeImportEquals,\n          maybeDefaultIdentifier,\n          /* isExport */ true,\n        );\n        if (process.env.BABEL_8_BREAKING) {\n          (node as Undone<N.ExportNamedDeclaration>).declaration = declaration;\n          (node as Undone<N.ExportNamedDeclaration>).specifiers = [];\n          return this.finishNode(node, \"ExportNamedDeclaration\");\n        } else {\n          return declaration;\n        }\n      } else if (this.eat(tt.eq)) {\n        // `export = x;`\n        const assign = node as Undone<N.TsExportAssignment>;\n        assign.expression = super.parseExpression();\n        this.semicolon();\n        this.sawUnambiguousESM = true;\n        return this.finishNode(assign, \"TSExportAssignment\");\n      } else if (this.eatContextual(tt._as)) {\n        // `export as namespace A;`\n        const decl = node as Undone<N.TsNamespaceExportDeclaration>;\n        // See `parseNamespaceExportDeclaration` in TypeScript's own parser\n        this.expectContextual(tt._namespace);\n        decl.id = this.parseIdentifier();\n        this.semicolon();\n        return this.finishNode(decl, \"TSNamespaceExportDeclaration\");\n      } else {\n        return super.parseExport(\n          node as Undone<N.ExportAllDeclaration | N.ExportDefaultDeclaration>,\n          decorators,\n        );\n      }\n    }\n\n    isAbstractClass(): boolean {\n      return (\n        this.isContextual(tt._abstract) && this.lookahead().type === tt._class\n      );\n    }\n\n    parseExportDefaultExpression(): N.ExportDefaultDeclaration[\"declaration\"] {\n      if (this.isAbstractClass()) {\n        const cls = this.startNode<N.Class>();\n        this.next(); // Skip \"abstract\"\n        cls.abstract = true;\n        return this.parseClass(cls, true, true);\n      }\n\n      // export default interface allowed in:\n      // https://github.com/Microsoft/TypeScript/pull/16040\n      if (this.match(tt._interface)) {\n        const result = this.tsParseInterfaceDeclaration(\n          this.startNode<N.TsInterfaceDeclaration>(),\n        );\n        if (result) return result;\n      }\n\n      return super.parseExportDefaultExpression();\n    }\n\n    parseVarStatement(\n      node: N.VariableDeclaration,\n      kind: \"var\" | \"let\" | \"const\" | \"using\",\n      allowMissingInitializer: boolean = false,\n    ) {\n      const { isAmbientContext } = this.state;\n      const declaration = super.parseVarStatement(\n        node,\n        kind,\n        allowMissingInitializer || isAmbientContext,\n      );\n\n      if (!isAmbientContext) return declaration;\n\n      for (const { id, init } of declaration.declarations) {\n        // Empty initializer is the easy case that we want.\n        if (!init) continue;\n\n        // var and let aren't ever allowed initializers.\n        if (kind !== \"const\" || !!id.typeAnnotation) {\n          this.raise(TSErrors.InitializerNotAllowedInAmbientContext, init);\n        } else if (\n          !isValidAmbientConstInitializer(init, this.hasPlugin(\"estree\"))\n        ) {\n          this.raise(\n            TSErrors.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference,\n            init,\n          );\n        }\n      }\n\n      return declaration;\n    }\n\n    parseStatementContent(\n      flags: ParseStatementFlag,\n      decorators?: N.Decorator[] | null,\n    ): N.Statement {\n      if (this.match(tt._const) && this.isLookaheadContextual(\"enum\")) {\n        const node = this.startNode<N.TsEnumDeclaration>();\n        this.expect(tt._const); // eat 'const'\n        return this.tsParseEnumDeclaration(node, { const: true });\n      }\n\n      if (this.isContextual(tt._enum)) {\n        return this.tsParseEnumDeclaration(\n          this.startNode<N.TsEnumDeclaration>(),\n        );\n      }\n\n      if (this.isContextual(tt._interface)) {\n        const result = this.tsParseInterfaceDeclaration(this.startNode());\n        if (result) return result;\n      }\n\n      return super.parseStatementContent(flags, decorators);\n    }\n\n    parseAccessModifier(): N.Accessibility | undefined | null {\n      return this.tsParseModifier([\"public\", \"protected\", \"private\"]);\n    }\n\n    tsHasSomeModifiers(member: any, modifiers: readonly TsModifier[]): boolean {\n      return modifiers.some(modifier => {\n        if (tsIsAccessModifier(modifier)) {\n          return member.accessibility === modifier;\n        }\n        return !!member[modifier];\n      });\n    }\n\n    tsIsStartOfStaticBlocks() {\n      return (\n        this.isContextual(tt._static) &&\n        this.lookaheadCharCode() === charCodes.leftCurlyBrace\n      );\n    }\n\n    parseClassMember(\n      classBody: N.ClassBody,\n      member: any,\n      state: N.ParseClassMemberState,\n    ): void {\n      const modifiers = [\n        \"declare\",\n        \"private\",\n        \"public\",\n        \"protected\",\n        \"override\",\n        \"abstract\",\n        \"readonly\",\n        \"static\",\n      ] as const;\n      this.tsParseModifiers(\n        {\n          allowedModifiers: modifiers,\n          disallowedModifiers: [\"in\", \"out\"],\n          stopOnStartOfClassStaticBlock: true,\n          errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions,\n        },\n        member,\n      );\n\n      const callParseClassMemberWithIsStatic = () => {\n        if (this.tsIsStartOfStaticBlocks()) {\n          this.next(); // eat \"static\"\n          this.next(); // eat \"{\"\n          if (this.tsHasSomeModifiers(member, modifiers)) {\n            this.raise(\n              TSErrors.StaticBlockCannotHaveModifier,\n              this.state.curPosition(),\n            );\n          }\n          super.parseClassStaticBlock(classBody, member as N.StaticBlock);\n        } else {\n          this.parseClassMemberWithIsStatic(\n            classBody,\n            member,\n            state,\n            !!member.static,\n          );\n        }\n      };\n      if (member.declare) {\n        this.tsInAmbientContext(callParseClassMemberWithIsStatic);\n      } else {\n        callParseClassMemberWithIsStatic();\n      }\n    }\n\n    parseClassMemberWithIsStatic(\n      classBody: N.ClassBody,\n      member: Undone<N.ClassMember | N.TsIndexSignature>,\n      state: N.ParseClassMemberState,\n      isStatic: boolean,\n    ): void {\n      const idx = this.tsTryParseIndexSignature(\n        member as Undone<N.TsIndexSignature>,\n      );\n      if (idx) {\n        classBody.body.push(idx);\n\n        if ((member as any).abstract) {\n          this.raise(TSErrors.IndexSignatureHasAbstract, member);\n        }\n        if ((member as any).accessibility) {\n          this.raise(TSErrors.IndexSignatureHasAccessibility, member, {\n            modifier: (member as any).accessibility,\n          });\n        }\n        if ((member as any).declare) {\n          this.raise(TSErrors.IndexSignatureHasDeclare, member);\n        }\n        if ((member as any).override) {\n          this.raise(TSErrors.IndexSignatureHasOverride, member);\n        }\n\n        return;\n      }\n\n      if (!this.state.inAbstractClass && (member as any).abstract) {\n        this.raise(TSErrors.NonAbstractClassHasAbstractMethod, member);\n      }\n\n      if ((member as any).override) {\n        if (!state.hadSuperClass) {\n          this.raise(TSErrors.OverrideNotInSubClass, member);\n        }\n      }\n\n      /*:: invariant(member.type !== \"TSIndexSignature\") */\n\n      super.parseClassMemberWithIsStatic(\n        classBody,\n        member as Undone<N.ClassMember>,\n        state,\n        isStatic,\n      );\n    }\n\n    parsePostMemberNameModifiers(\n      methodOrProp: N.ClassMethod | N.ClassProperty | N.ClassPrivateProperty,\n    ): void {\n      const optional = this.eat(tt.question);\n      if (optional) methodOrProp.optional = true;\n\n      if ((methodOrProp as any).readonly && this.match(tt.parenL)) {\n        this.raise(TSErrors.ClassMethodHasReadonly, methodOrProp);\n      }\n\n      if ((methodOrProp as any).declare && this.match(tt.parenL)) {\n        this.raise(TSErrors.ClassMethodHasDeclare, methodOrProp);\n      }\n    }\n\n    // Note: The reason we do this in `parseExpressionStatement` and not `parseStatement`\n    // is that e.g. `type()` is valid JS, so we must try parsing that first.\n    // If it's really a type, we will parse `type` as the statement, and can correct it here\n    // by parsing the rest.\n    // @ts-expect-error plugin overrides interfaces\n    parseExpressionStatement(\n      node: Undone<N.ExpressionStatement>,\n      expr: N.Expression,\n      decorators: N.Decorator[] | null,\n    ): N.Statement {\n      const decl =\n        expr.type === \"Identifier\"\n          ? // @ts-expect-error refine typings\n            this.tsParseExpressionStatement(node, expr, decorators)\n          : undefined;\n      return decl || super.parseExpressionStatement(node, expr, decorators);\n    }\n\n    // export type\n    // Should be true for anything parsed by `tsTryParseExportDeclaration`.\n    shouldParseExportDeclaration(): boolean {\n      if (this.tsIsDeclarationStart()) return true;\n      return super.shouldParseExportDeclaration();\n    }\n\n    // An apparent conditional expression could actually be an optional parameter in an arrow function.\n    parseConditional(\n      expr: N.Expression,\n\n      startLoc: Position,\n      refExpressionErrors?: ExpressionErrors | null,\n    ): N.Expression {\n      if (!this.match(tt.question)) return expr;\n\n      if (this.state.maybeInArrowParameters) {\n        const nextCh = this.lookaheadCharCode();\n        // These tokens cannot start an expression, so if one of them follows\n        // ? then we are probably in an arrow function parameters list and we\n        // don't parse the conditional expression.\n        if (\n          nextCh === charCodes.comma || // (a?, b) => c\n          nextCh === charCodes.equalsTo || // (a? = b) => c\n          nextCh === charCodes.colon || // (a?: b) => c\n          nextCh === charCodes.rightParenthesis // (a?) => c\n        ) {\n          /*:: invariant(refExpressionErrors != null) */\n          this.setOptionalParametersError(refExpressionErrors);\n          return expr;\n        }\n      }\n\n      return super.parseConditional(expr, startLoc, refExpressionErrors);\n    }\n\n    // Note: These \"type casts\" are *not* valid TS expressions.\n    // But we parse them here and change them when completing the arrow function.\n    parseParenItem<T extends N.Expression | N.RestElement | N.SpreadElement>(\n      node: T,\n      startLoc: Position,\n    ): T | N.TsTypeCastExpression {\n      const newNode = super.parseParenItem(node, startLoc);\n      if (this.eat(tt.question)) {\n        (newNode as N.Identifier).optional = true;\n        // Include questionmark in location of node\n        // Don't use this.finishNode() as otherwise we might process comments twice and\n        // include already consumed parens\n        this.resetEndLocation(node);\n      }\n\n      if (this.match(tt.colon)) {\n        const typeCastNode = this.startNodeAt<N.TsTypeCastExpression>(startLoc);\n        typeCastNode.expression = node as N.Expression;\n        typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();\n\n        return this.finishNode(typeCastNode, \"TSTypeCastExpression\");\n      }\n\n      return node;\n    }\n\n    parseExportDeclaration(\n      node: N.ExportNamedDeclaration,\n    ): N.Declaration | undefined | null {\n      if (!this.state.isAmbientContext && this.isContextual(tt._declare)) {\n        return this.tsInAmbientContext(() => this.parseExportDeclaration(node));\n      }\n\n      // Store original location\n      const startLoc = this.state.startLoc;\n\n      const isDeclare = this.eatContextual(tt._declare);\n\n      if (\n        isDeclare &&\n        (this.isContextual(tt._declare) || !this.shouldParseExportDeclaration())\n      ) {\n        throw this.raise(\n          TSErrors.ExpectedAmbientAfterExportDeclare,\n          this.state.startLoc,\n        );\n      }\n\n      const isIdentifier = tokenIsIdentifier(this.state.type);\n      const declaration: N.Declaration | undefined | null =\n        (isIdentifier && this.tsTryParseExportDeclaration()) ||\n        super.parseExportDeclaration(node);\n\n      if (!declaration) return null;\n\n      if (\n        declaration.type === \"TSInterfaceDeclaration\" ||\n        declaration.type === \"TSTypeAliasDeclaration\" ||\n        isDeclare\n      ) {\n        node.exportKind = \"type\";\n      }\n\n      if (isDeclare && declaration.type !== \"TSImportEqualsDeclaration\") {\n        // Reset location to include `declare` in range\n        this.resetStartLocation(declaration, startLoc);\n\n        declaration.declare = true;\n      }\n\n      return declaration;\n    }\n\n    parseClassId(\n      node: N.Class,\n      isStatement: boolean,\n      optionalId?: boolean | null,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      bindingType?: BindingFlag,\n    ): void {\n      if ((!isStatement || optionalId) && this.isContextual(tt._implements)) {\n        return;\n      }\n\n      super.parseClassId(\n        node,\n        isStatement,\n        optionalId,\n        (node as any).declare\n          ? BindingFlag.TYPE_TS_AMBIENT\n          : BindingFlag.TYPE_CLASS,\n      );\n      const typeParameters = this.tsTryParseTypeParameters(\n        this.tsParseInOutConstModifiers,\n      );\n      if (typeParameters) node.typeParameters = typeParameters;\n    }\n\n    parseClassPropertyAnnotation(\n      node: N.ClassProperty | N.ClassPrivateProperty | N.ClassAccessorProperty,\n    ): void {\n      if (!node.optional) {\n        if (this.eat(tt.bang)) {\n          node.definite = true;\n        } else if (this.eat(tt.question)) {\n          node.optional = true;\n        }\n      }\n\n      const type = this.tsTryParseTypeAnnotation();\n      if (type) node.typeAnnotation = type;\n    }\n\n    parseClassProperty(node: N.ClassProperty): N.ClassProperty {\n      this.parseClassPropertyAnnotation(node);\n\n      if (\n        this.state.isAmbientContext &&\n        !(node.readonly && !node.typeAnnotation) &&\n        this.match(tt.eq)\n      ) {\n        this.raise(\n          TSErrors.DeclareClassFieldHasInitializer,\n          this.state.startLoc,\n        );\n      }\n      if (node.abstract && this.match(tt.eq)) {\n        const { key } = node;\n        this.raise(\n          TSErrors.AbstractPropertyHasInitializer,\n          this.state.startLoc,\n          {\n            propertyName:\n              key.type === \"Identifier\" && !node.computed\n                ? key.name\n                : `[${this.input.slice(this.offsetToSourcePos(key.start), this.offsetToSourcePos(key.end))}]`,\n          },\n        );\n      }\n\n      return super.parseClassProperty(node);\n    }\n\n    parseClassPrivateProperty(\n      node: N.ClassPrivateProperty,\n    ): N.ClassPrivateProperty {\n      if (node.abstract) {\n        this.raise(TSErrors.PrivateElementHasAbstract, node);\n      }\n\n      if (node.accessibility) {\n        this.raise(TSErrors.PrivateElementHasAccessibility, node, {\n          modifier: node.accessibility,\n        });\n      }\n\n      this.parseClassPropertyAnnotation(node);\n      return super.parseClassPrivateProperty(node);\n    }\n\n    parseClassAccessorProperty(\n      node: N.ClassAccessorProperty,\n    ): N.ClassAccessorProperty {\n      this.parseClassPropertyAnnotation(node);\n      if (node.optional) {\n        this.raise(TSErrors.AccessorCannotBeOptional, node);\n      }\n      return super.parseClassAccessorProperty(node);\n    }\n\n    pushClassMethod(\n      classBody: N.ClassBody,\n      method: N.ClassMethod,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isConstructor: boolean,\n      allowsDirectSuper: boolean,\n    ): void {\n      const typeParameters = this.tsTryParseTypeParameters(\n        this.tsParseConstModifier,\n      );\n      if (typeParameters && isConstructor) {\n        this.raise(TSErrors.ConstructorHasTypeParameters, typeParameters);\n      }\n\n      // @ts-expect-error declare does not exist in ClassMethod\n      const { declare = false, kind } = method;\n\n      if (declare && (kind === \"get\" || kind === \"set\")) {\n        this.raise(TSErrors.DeclareAccessor, method, { kind });\n      }\n      if (typeParameters) method.typeParameters = typeParameters;\n      super.pushClassMethod(\n        classBody,\n        method,\n        isGenerator,\n        isAsync,\n        isConstructor,\n        allowsDirectSuper,\n      );\n    }\n\n    pushClassPrivateMethod(\n      classBody: N.ClassBody,\n      method: N.ClassPrivateMethod,\n      isGenerator: boolean,\n      isAsync: boolean,\n    ): void {\n      const typeParameters = this.tsTryParseTypeParameters(\n        this.tsParseConstModifier,\n      );\n      if (typeParameters) method.typeParameters = typeParameters;\n      super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n    }\n\n    declareClassPrivateMethodInScope(\n      node: N.ClassPrivateMethod | N.TSDeclareMethod,\n      kind: number,\n    ) {\n      if (node.type === \"TSDeclareMethod\") return;\n      // This happens when using the \"estree\" plugin.\n      if (\n        (node as N.Node).type === \"MethodDefinition\" &&\n        !Object.hasOwn(\n          (node as unknown as N.EstreeMethodDefinition).value,\n          \"body\",\n        )\n      ) {\n        return;\n      }\n\n      super.declareClassPrivateMethodInScope(node, kind);\n    }\n\n    parseClassSuper(node: N.Class): void {\n      super.parseClassSuper(node);\n      // handle `extends f<<T>\n      if (node.superClass && (this.match(tt.lt) || this.match(tt.bitShiftL))) {\n        if (process.env.BABEL_8_BREAKING) {\n          node.superTypeArguments = this.tsParseTypeArgumentsInExpression();\n        } else {\n          node.superTypeParameters = this.tsParseTypeArgumentsInExpression();\n        }\n      }\n      if (this.eatContextual(tt._implements)) {\n        node.implements = this.tsParseHeritageClause(\"implements\");\n      }\n    }\n\n    parseObjPropValue<T extends N.ObjectMember>(\n      prop: Undone<T>,\n      startLoc: Position | undefined | null,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isPattern: boolean,\n      isAccessor: boolean,\n      refExpressionErrors?: ExpressionErrors | null,\n    ): T {\n      const typeParameters = this.tsTryParseTypeParameters(\n        this.tsParseConstModifier,\n      );\n      if (typeParameters) prop.typeParameters = typeParameters;\n\n      return super.parseObjPropValue(\n        prop,\n\n        startLoc,\n        isGenerator,\n        isAsync,\n        isPattern,\n        isAccessor,\n        refExpressionErrors,\n      );\n    }\n\n    parseFunctionParams(node: N.Function, isConstructor: boolean): void {\n      const typeParameters = this.tsTryParseTypeParameters(\n        this.tsParseConstModifier,\n      );\n      if (typeParameters) node.typeParameters = typeParameters;\n      super.parseFunctionParams(node, isConstructor);\n    }\n\n    // `let x: number;`\n    parseVarId(\n      decl: N.VariableDeclarator,\n      kind: \"var\" | \"let\" | \"const\" | \"using\",\n    ): void {\n      super.parseVarId(decl, kind);\n      if (\n        decl.id.type === \"Identifier\" &&\n        !this.hasPrecedingLineBreak() &&\n        this.eat(tt.bang)\n      ) {\n        decl.definite = true;\n      }\n\n      const type = this.tsTryParseTypeAnnotation();\n      if (type) {\n        decl.id.typeAnnotation = type;\n        this.resetEndLocation(decl.id); // set end position to end of type\n      }\n    }\n\n    // parse the return type of an async arrow function - let foo = (async (): number => {});\n    parseAsyncArrowFromCallExpression(\n      node: N.ArrowFunctionExpression,\n      call: N.CallExpression,\n    ): N.ArrowFunctionExpression {\n      if (this.match(tt.colon)) {\n        node.returnType = this.tsParseTypeAnnotation();\n      }\n      return super.parseAsyncArrowFromCallExpression(node, call);\n    }\n\n    parseMaybeAssign(\n      refExpressionErrors?: ExpressionErrors | null,\n      afterLeftParse?: Function,\n    ): N.Expression {\n      // Note: When the JSX plugin is on, type assertions (`<T> x`) aren't valid syntax.\n\n      let state: State | undefined | null;\n      let jsx;\n      let typeCast;\n\n      if (\n        this.hasPlugin(\"jsx\") &&\n        (this.match(tt.jsxTagStart) || this.match(tt.lt))\n      ) {\n        // Prefer to parse JSX if possible. But may be an arrow fn.\n        state = this.state.clone();\n\n        jsx = this.tryParse(\n          () => super.parseMaybeAssign(refExpressionErrors, afterLeftParse),\n          state,\n        );\n\n        /*:: invariant(!jsx.aborted) */\n        /*:: invariant(jsx.node != null) */\n        if (!jsx.error) return jsx.node;\n\n        // Remove `tc.j_expr` or `tc.j_oTag` from context added\n        // by parsing `jsxTagStart` to stop the JSX plugin from\n        // messing with the tokens\n        const { context } = this.state;\n        const currentContext = context[context.length - 1];\n        if (currentContext === tc.j_oTag || currentContext === tc.j_expr) {\n          context.pop();\n        }\n      }\n\n      if (!jsx?.error && !this.match(tt.lt)) {\n        return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n      }\n\n      // Either way, we're looking at a '<': tt.jsxTagStart or relational.\n\n      // If the state was cloned in the JSX parsing branch above but there\n      // have been any error in the tryParse call, this.state is set to state\n      // so we still need to clone it.\n      if (!state || state === this.state) state = this.state.clone();\n\n      let typeParameters: N.TsTypeParameterDeclaration | undefined | null;\n      // We need to explicitly annotate 'abort' for microsoft/TypeScript#58170\n      const arrow = this.tryParse((abort: () => never) => {\n        // This is similar to TypeScript's `tryParseParenthesizedArrowFunctionExpression`.\n        typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);\n        const expr = super.parseMaybeAssign(\n          refExpressionErrors,\n          afterLeftParse,\n        );\n\n        if (\n          expr.type !== \"ArrowFunctionExpression\" ||\n          expr.extra?.parenthesized\n        ) {\n          abort();\n        }\n\n        // Correct TypeScript code should have at least 1 type parameter, but don't crash on bad code.\n        if (typeParameters?.params.length !== 0) {\n          this.resetStartLocationFromNode(expr, typeParameters);\n        }\n        expr.typeParameters = typeParameters;\n\n        if (process.env.BABEL_8_BREAKING) {\n          if (\n            this.hasPlugin(\"jsx\") &&\n            expr.typeParameters.params.length === 1 &&\n            !expr.typeParameters.extra?.trailingComma\n          ) {\n            // report error if single type parameter used without trailing comma.\n            const parameter = expr.typeParameters\n              .params[0] as N.TsTypeParameter;\n            if (!parameter.constraint) {\n              // A single type parameter must either have constraints\n              // or a trailing comma, otherwise it's ambiguous with JSX.\n              this.raise(\n                TSErrors.SingleTypeParameterWithoutTrailingComma,\n                createPositionWithColumnOffset(parameter.loc.end, 1),\n                {\n                  typeParameterName: process.env.BABEL_8_BREAKING\n                    ? (parameter.name as N.Identifier).name\n                    : (parameter.name as string),\n                },\n              );\n            }\n          }\n        }\n\n        return expr;\n      }, state);\n\n      /*:: invariant(arrow.node != null) */\n      if (!arrow.error && !arrow.aborted) {\n        // This error is reported outside of the this.tryParse call so that\n        // in case of <T>(x) => 2, we don't consider <T>(x) as a type assertion\n        // because of this error.\n        if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);\n        return arrow.node;\n      }\n\n      if (!jsx) {\n        // Try parsing a type cast instead of an arrow function.\n        // This will never happen outside of JSX.\n        // (Because in JSX the '<' should be a jsxTagStart and not a relational.\n        assert(!this.hasPlugin(\"jsx\"));\n\n        // This will start with a type assertion (via parseMaybeUnary).\n        // But don't directly call `this.tsParseTypeAssertion` because we want to handle any binary after it.\n        typeCast = this.tryParse(\n          () => super.parseMaybeAssign(refExpressionErrors, afterLeftParse),\n          state,\n        );\n        /*:: invariant(!typeCast.aborted) */\n        /*:: invariant(typeCast.node != null) */\n        if (!typeCast.error) return typeCast.node;\n      }\n\n      if (jsx?.node) {\n        /*:: invariant(jsx.failState) */\n        this.state = jsx.failState;\n        return jsx.node;\n      }\n\n      if (arrow.node) {\n        /*:: invariant(arrow.failState) */\n        this.state = arrow.failState;\n        if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);\n        return arrow.node;\n      }\n\n      if (typeCast?.node) {\n        /*:: invariant(typeCast.failState) */\n        this.state = typeCast.failState;\n        return typeCast.node;\n      }\n\n      throw jsx?.error || arrow.error || typeCast?.error;\n    }\n\n    reportReservedArrowTypeParam(node: any) {\n      if (\n        node.params.length === 1 &&\n        !node.params[0].constraint &&\n        !node.extra?.trailingComma &&\n        this.getPluginOption(\"typescript\", \"disallowAmbiguousJSXLike\")\n      ) {\n        this.raise(TSErrors.ReservedArrowTypeParam, node);\n      }\n    }\n\n    // Handle type assertions\n    parseMaybeUnary(\n      refExpressionErrors?: ExpressionErrors | null,\n      sawUnary?: boolean,\n    ): N.Expression {\n      if (!this.hasPlugin(\"jsx\") && this.match(tt.lt)) {\n        return this.tsParseTypeAssertion();\n      }\n      return super.parseMaybeUnary(refExpressionErrors, sawUnary);\n    }\n\n    parseArrow(\n      node: Undone<N.ArrowFunctionExpression>,\n    ): Undone<N.ArrowFunctionExpression> | undefined | null {\n      if (this.match(tt.colon)) {\n        // This is different from how the TS parser does it.\n        // TS uses lookahead. The Babel Parser parses it as a parenthesized expression and converts.\n\n        const result = this.tryParse(abort => {\n          const returnType = this.tsParseTypeOrTypePredicateAnnotation(\n            tt.colon,\n          );\n          if (this.canInsertSemicolon() || !this.match(tt.arrow)) abort();\n          return returnType;\n        });\n\n        if (result.aborted) return;\n\n        if (!result.thrown) {\n          if (result.error) this.state = result.failState;\n          // @ts-expect-error refine typings\n          node.returnType = result.node;\n        }\n      }\n\n      return super.parseArrow(node);\n    }\n\n    // Allow type annotations inside of a parameter list.\n    parseFunctionParamType(param: N.Pattern) {\n      if (this.eat(tt.question)) {\n        (param as any as N.Identifier).optional = true;\n      }\n      const type = this.tsTryParseTypeAnnotation();\n      if (type) param.typeAnnotation = type;\n      this.resetEndLocation(param);\n\n      return param;\n    }\n\n    isAssignable(node: N.Node, isBinding?: boolean): boolean {\n      switch (node.type) {\n        case \"TSTypeCastExpression\":\n          return this.isAssignable(node.expression, isBinding);\n        case \"TSParameterProperty\":\n          return true;\n        default:\n          return super.isAssignable(node, isBinding);\n      }\n    }\n\n    toAssignable(node: N.Node, isLHS: boolean = false): void {\n      switch (node.type) {\n        case \"ParenthesizedExpression\":\n          this.toAssignableParenthesizedExpression(node, isLHS);\n          break;\n        case \"TSAsExpression\":\n        case \"TSSatisfiesExpression\":\n        case \"TSNonNullExpression\":\n        case \"TSTypeAssertion\":\n          if (isLHS) {\n            this.expressionScope.recordArrowParameterBindingError(\n              TSErrors.UnexpectedTypeCastInParameter,\n              node,\n            );\n          } else {\n            this.raise(TSErrors.UnexpectedTypeCastInParameter, node);\n          }\n          this.toAssignable(node.expression, isLHS);\n          break;\n        case \"AssignmentExpression\":\n          if (!isLHS && node.left.type === \"TSTypeCastExpression\") {\n            node.left = this.typeCastToParameter(node.left) as N.Assignable;\n          }\n        /* fall through */\n        default:\n          super.toAssignable(node, isLHS);\n      }\n    }\n\n    toAssignableParenthesizedExpression(\n      node: N.ParenthesizedExpression,\n      isLHS: boolean,\n    ): void {\n      switch (node.expression.type) {\n        case \"TSAsExpression\":\n        case \"TSSatisfiesExpression\":\n        case \"TSNonNullExpression\":\n        case \"TSTypeAssertion\":\n        case \"ParenthesizedExpression\":\n          this.toAssignable(node.expression, isLHS);\n          break;\n        default:\n          super.toAssignable(node, isLHS);\n      }\n    }\n\n    checkToRestConversion(node: N.Node, allowPattern: boolean): void {\n      switch (node.type) {\n        case \"TSAsExpression\":\n        case \"TSSatisfiesExpression\":\n        case \"TSTypeAssertion\":\n        case \"TSNonNullExpression\":\n          this.checkToRestConversion(node.expression, false);\n          break;\n        default:\n          super.checkToRestConversion(node, allowPattern);\n      }\n    }\n\n    isValidLVal(\n      type:\n        | \"TSTypeCastExpression\"\n        | \"TSParameterProperty\"\n        | \"TSNonNullExpression\"\n        | \"TSInstantiationExpression\"\n        | \"TSAsExpression\"\n        | \"TSSatisfiesExpression\"\n        | \"TSTypeAssertion\",\n      isUnparenthesizedInAssign: boolean,\n      binding: BindingFlag,\n    ) {\n      switch (type) {\n        // Allow \"typecasts\" to appear on the left of assignment expressions,\n        // because it may be in an arrow function.\n        // e.g. `const f = (foo: number = 0) => foo;`\n        case \"TSTypeCastExpression\":\n          return true;\n        case \"TSParameterProperty\":\n          return \"parameter\";\n        case \"TSNonNullExpression\":\n          return \"expression\";\n        case \"TSAsExpression\":\n        case \"TSSatisfiesExpression\":\n        case \"TSTypeAssertion\":\n          return (\n            (binding !== BindingFlag.TYPE_NONE || !isUnparenthesizedInAssign) &&\n            ([\"expression\", true] as [string, boolean])\n          );\n        default:\n          return super.isValidLVal(type, isUnparenthesizedInAssign, binding);\n      }\n    }\n\n    parseBindingAtom(): N.Pattern {\n      if (this.state.type === tt._this) {\n        return this.parseIdentifier(/* liberal */ true);\n      }\n      return super.parseBindingAtom();\n    }\n\n    parseMaybeDecoratorArguments(\n      expr: N.Expression,\n      startLoc: Position,\n    ): N.Expression {\n      // handles `@f<<T>`\n      if (this.match(tt.lt) || this.match(tt.bitShiftL)) {\n        const typeArguments = this.tsParseTypeArgumentsInExpression();\n\n        if (this.match(tt.parenL)) {\n          const call = super.parseMaybeDecoratorArguments(\n            expr,\n            startLoc,\n          ) as N.CallExpression;\n          if (process.env.BABEL_8_BREAKING) {\n            call.typeArguments = typeArguments;\n          } else {\n            call.typeParameters = typeArguments;\n          }\n\n          return call;\n        }\n\n        this.unexpected(null, tt.parenL);\n      }\n\n      return super.parseMaybeDecoratorArguments(expr, startLoc);\n    }\n\n    checkCommaAfterRest(\n      close: (typeof charCodes)[keyof typeof charCodes],\n    ): boolean {\n      if (\n        this.state.isAmbientContext &&\n        this.match(tt.comma) &&\n        this.lookaheadCharCode() === close\n      ) {\n        this.next();\n        return false;\n      }\n      return super.checkCommaAfterRest(close);\n    }\n\n    // === === === === === === === === === === === === === === === ===\n    // Note: All below methods are duplicates of something in flow.js.\n    // Not sure what the best way to combine these is.\n    // === === === === === === === === === === === === === === === ===\n\n    isClassMethod(): boolean {\n      return this.match(tt.lt) || super.isClassMethod();\n    }\n\n    isClassProperty(): boolean {\n      return (\n        this.match(tt.bang) || this.match(tt.colon) || super.isClassProperty()\n      );\n    }\n\n    parseMaybeDefault(\n      startLoc?: Position | null,\n      left?: Pattern | null,\n    ): N.Pattern {\n      const node = super.parseMaybeDefault(startLoc, left);\n\n      if (\n        node.type === \"AssignmentPattern\" &&\n        node.typeAnnotation &&\n        node.right.start < node.typeAnnotation.start\n      ) {\n        this.raise(TSErrors.TypeAnnotationAfterAssign, node.typeAnnotation);\n      }\n\n      return node;\n    }\n\n    // ensure that inside types, we bypass the jsx parser plugin\n    getTokenFromCode(code: number): void {\n      if (this.state.inType) {\n        if (code === charCodes.greaterThan) {\n          this.finishOp(tt.gt, 1);\n          return;\n        }\n        if (code === charCodes.lessThan) {\n          this.finishOp(tt.lt, 1);\n          return;\n        }\n      }\n      super.getTokenFromCode(code);\n    }\n\n    // used after we have finished parsing types\n    reScan_lt_gt() {\n      const { type } = this.state;\n      if (type === tt.lt) {\n        this.state.pos -= 1;\n        this.readToken_lt();\n      } else if (type === tt.gt) {\n        this.state.pos -= 1;\n        this.readToken_gt();\n      }\n    }\n\n    reScan_lt() {\n      const { type } = this.state;\n      if (type === tt.bitShiftL) {\n        this.state.pos -= 2;\n        this.finishOp(tt.lt, 1);\n        return tt.lt;\n      }\n      return type;\n    }\n\n    toAssignableListItem(\n      exprList: (N.Expression | N.SpreadElement | N.RestElement)[],\n      index: number,\n      isLHS: boolean,\n    ): void {\n      const node = exprList[index];\n      if (node.type === \"TSTypeCastExpression\") {\n        exprList[index] = this.typeCastToParameter(node);\n      }\n      super.toAssignableListItem(exprList, index, isLHS);\n    }\n\n    typeCastToParameter(node: N.TsTypeCastExpression): N.Expression {\n      (node.expression as N.Identifier).typeAnnotation = node.typeAnnotation;\n\n      this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);\n\n      return node.expression;\n    }\n\n    shouldParseArrow(params: Array<N.Node>) {\n      if (this.match(tt.colon)) {\n        return params.every(expr => this.isAssignable(expr, true));\n      }\n      return super.shouldParseArrow(params);\n    }\n\n    shouldParseAsyncArrow(): boolean {\n      return this.match(tt.colon) || super.shouldParseAsyncArrow();\n    }\n\n    canHaveLeadingDecorator() {\n      // Avoid unnecessary lookahead in checking for abstract class unless needed!\n      return super.canHaveLeadingDecorator() || this.isAbstractClass();\n    }\n\n    jsxParseOpeningElementAfterName(\n      node: N.JSXOpeningElement,\n    ): N.JSXOpeningElement {\n      // handles `<Component<<T>`\n      if (this.match(tt.lt) || this.match(tt.bitShiftL)) {\n        const typeArguments = this.tsTryParseAndCatch(() =>\n          this.tsParseTypeArgumentsInExpression(),\n        );\n        if (typeArguments) {\n          if (process.env.BABEL_8_BREAKING) {\n            node.typeArguments = typeArguments;\n          } else {\n            node.typeParameters = typeArguments;\n          }\n        }\n      }\n      return super.jsxParseOpeningElementAfterName(node);\n    }\n\n    getGetterSetterExpectedParamCount(\n      method: N.ObjectMethod | N.ClassMethod,\n    ): number {\n      const baseCount = super.getGetterSetterExpectedParamCount(method);\n      const params = this.getObjectOrClassMethodParams(method);\n      const firstParam = params[0];\n      const hasContextParam = firstParam && this.isThisParam(firstParam);\n\n      return hasContextParam ? baseCount + 1 : baseCount;\n    }\n\n    parseCatchClauseParam(): N.Pattern {\n      const param = super.parseCatchClauseParam();\n      const type = this.tsTryParseTypeAnnotation();\n\n      if (type) {\n        param.typeAnnotation = type;\n        this.resetEndLocation(param);\n      }\n\n      return param;\n    }\n\n    tsInAmbientContext<T>(cb: () => T): T {\n      const { isAmbientContext: oldIsAmbientContext, strict: oldStrict } =\n        this.state;\n      this.state.isAmbientContext = true;\n      this.state.strict = false;\n      try {\n        return cb();\n      } finally {\n        this.state.isAmbientContext = oldIsAmbientContext;\n        this.state.strict = oldStrict;\n      }\n    }\n\n    parseClass<T extends N.Class>(\n      node: Undone<T>,\n      isStatement: boolean,\n      optionalId?: boolean,\n    ): T {\n      const oldInAbstractClass = this.state.inAbstractClass;\n      this.state.inAbstractClass = !!(node as any).abstract;\n      try {\n        return super.parseClass(node, isStatement, optionalId);\n      } finally {\n        this.state.inAbstractClass = oldInAbstractClass;\n      }\n    }\n\n    tsParseAbstractDeclaration(\n      node: any,\n      decorators: N.Decorator[] | null,\n    ): N.ClassDeclaration | N.TsInterfaceDeclaration | undefined | null {\n      if (this.match(tt._class)) {\n        node.abstract = true;\n        return this.maybeTakeDecorators(\n          decorators,\n          this.parseClass<N.ClassDeclaration>(\n            node as N.ClassDeclaration,\n            /* isStatement */ true,\n            /* optionalId */ false,\n          ),\n        );\n      } else if (this.isContextual(tt._interface)) {\n        // for invalid abstract interface\n\n        // To avoid\n        //   abstract interface\n        //   Foo {}\n        if (!this.hasFollowingLineBreak()) {\n          node.abstract = true;\n          this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, node);\n          return this.tsParseInterfaceDeclaration(\n            node as N.TsInterfaceDeclaration,\n          );\n        }\n      } else {\n        this.unexpected(null, tt._class);\n      }\n    }\n\n    parseMethod<\n      T extends N.ObjectMethod | N.ClassMethod | N.ClassPrivateMethod,\n    >(\n      node: Undone<T>,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isConstructor: boolean,\n      allowDirectSuper: boolean,\n      type: T[\"type\"],\n      inClassScope?: boolean,\n    ) {\n      const method = super.parseMethod<T>(\n        node,\n        isGenerator,\n        isAsync,\n        isConstructor,\n        allowDirectSuper,\n        type,\n        inClassScope,\n      );\n      // @ts-expect-error todo(flow->ts) property not defined for all types in union\n      if (method.abstract) {\n        const hasEstreePlugin = this.hasPlugin(\"estree\");\n        const methodFn = hasEstreePlugin\n          ? // @ts-expect-error estree typings\n            method.value\n          : method;\n        if (methodFn.body) {\n          const { key } = method;\n          this.raise(TSErrors.AbstractMethodHasImplementation, method, {\n            methodName:\n              key.type === \"Identifier\" && !method.computed\n                ? key.name\n                : `[${this.input.slice(this.offsetToSourcePos(key.start), this.offsetToSourcePos(key.end))}]`,\n          });\n        }\n      }\n      return method;\n    }\n\n    tsParseTypeParameterName(): N.Identifier | string {\n      const typeName: N.Identifier = this.parseIdentifier();\n      return process.env.BABEL_8_BREAKING ? typeName : typeName.name;\n    }\n\n    shouldParseAsAmbientContext(): boolean {\n      return !!this.getPluginOption(\"typescript\", \"dts\");\n    }\n\n    parse() {\n      if (this.shouldParseAsAmbientContext()) {\n        this.state.isAmbientContext = true;\n      }\n      return super.parse();\n    }\n\n    getExpression() {\n      if (this.shouldParseAsAmbientContext()) {\n        this.state.isAmbientContext = true;\n      }\n      return super.getExpression();\n    }\n\n    parseExportSpecifier(\n      node: Undone<N.ExportSpecifier>,\n      isString: boolean,\n      isInTypeExport: boolean,\n      isMaybeTypeOnly: boolean,\n    ) {\n      if (!isString && isMaybeTypeOnly) {\n        this.parseTypeOnlyImportExportSpecifier(\n          node,\n          /* isImport */ false,\n          isInTypeExport,\n        );\n        return this.finishNode<N.ExportSpecifier>(node, \"ExportSpecifier\");\n      }\n      node.exportKind = \"value\";\n      return super.parseExportSpecifier(\n        node,\n        isString,\n        isInTypeExport,\n        isMaybeTypeOnly,\n      );\n    }\n\n    parseImportSpecifier(\n      specifier: Undone<N.ImportSpecifier>,\n      importedIsString: boolean,\n      isInTypeOnlyImport: boolean,\n      isMaybeTypeOnly: boolean,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      bindingType: BindingFlag | undefined,\n    ): N.ImportSpecifier {\n      if (!importedIsString && isMaybeTypeOnly) {\n        this.parseTypeOnlyImportExportSpecifier(\n          specifier,\n          /* isImport */ true,\n          isInTypeOnlyImport,\n        );\n        return this.finishNode<N.ImportSpecifier>(specifier, \"ImportSpecifier\");\n      }\n      specifier.importKind = \"value\";\n      return super.parseImportSpecifier(\n        specifier,\n        importedIsString,\n        isInTypeOnlyImport,\n        isMaybeTypeOnly,\n        isInTypeOnlyImport\n          ? BindingFlag.TYPE_TS_TYPE_IMPORT\n          : BindingFlag.TYPE_TS_VALUE_IMPORT,\n      );\n    }\n\n    parseTypeOnlyImportExportSpecifier(\n      node: any,\n      isImport: boolean,\n      isInTypeOnlyImportExport: boolean,\n    ): void {\n      const leftOfAsKey = isImport ? \"imported\" : \"local\";\n      const rightOfAsKey = isImport ? \"local\" : \"exported\";\n\n      let leftOfAs = node[leftOfAsKey];\n      let rightOfAs;\n\n      let hasTypeSpecifier = false;\n      let canParseAsKeyword = true;\n\n      const loc = leftOfAs.loc.start;\n\n      // https://github.com/microsoft/TypeScript/blob/fc4f9d83d5939047aa6bb2a43965c6e9bbfbc35b/src/compiler/parser.ts#L7411-L7456\n      // import { type } from \"mod\";          - hasTypeSpecifier: false, leftOfAs: type\n      // import { type as } from \"mod\";       - hasTypeSpecifier: true,  leftOfAs: as\n      // import { type as as } from \"mod\";    - hasTypeSpecifier: false, leftOfAs: type, rightOfAs: as\n      // import { type as as as } from \"mod\"; - hasTypeSpecifier: true,  leftOfAs: as,   rightOfAs: as\n      if (this.isContextual(tt._as)) {\n        // { type as ...? }\n        const firstAs = this.parseIdentifier();\n        if (this.isContextual(tt._as)) {\n          // { type as as ...? }\n          const secondAs = this.parseIdentifier();\n          if (tokenIsKeywordOrIdentifier(this.state.type)) {\n            // { type as as something }\n            hasTypeSpecifier = true;\n            leftOfAs = firstAs;\n            rightOfAs = isImport\n              ? this.parseIdentifier()\n              : this.parseModuleExportName();\n            canParseAsKeyword = false;\n          } else {\n            // { type as as }\n            rightOfAs = secondAs;\n            canParseAsKeyword = false;\n          }\n        } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n          // { type as something }\n          canParseAsKeyword = false;\n          rightOfAs = isImport\n            ? this.parseIdentifier()\n            : this.parseModuleExportName();\n        } else {\n          // { type as }\n          hasTypeSpecifier = true;\n          leftOfAs = firstAs;\n        }\n      } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n        // { type something ...? }\n        hasTypeSpecifier = true;\n        if (isImport) {\n          leftOfAs = this.parseIdentifier(true);\n          if (!this.isContextual(tt._as)) {\n            this.checkReservedWord(\n              leftOfAs.name,\n              leftOfAs.loc.start,\n              true,\n              true,\n            );\n          }\n        } else {\n          leftOfAs = this.parseModuleExportName();\n        }\n      }\n      if (hasTypeSpecifier && isInTypeOnlyImportExport) {\n        this.raise(\n          isImport\n            ? TSErrors.TypeModifierIsUsedInTypeImports\n            : TSErrors.TypeModifierIsUsedInTypeExports,\n          loc,\n        );\n      }\n\n      node[leftOfAsKey] = leftOfAs;\n      node[rightOfAsKey] = rightOfAs;\n\n      const kindKey = isImport ? \"importKind\" : \"exportKind\";\n      node[kindKey] = hasTypeSpecifier ? \"type\" : \"value\";\n\n      if (canParseAsKeyword && this.eatContextual(tt._as)) {\n        node[rightOfAsKey] = isImport\n          ? this.parseIdentifier()\n          : this.parseModuleExportName();\n      }\n      if (!node[rightOfAsKey]) {\n        node[rightOfAsKey] = cloneIdentifier(node[leftOfAsKey]);\n      }\n      if (isImport) {\n        this.checkIdentifier(\n          node[rightOfAsKey],\n          hasTypeSpecifier\n            ? BindingFlag.TYPE_TS_TYPE_IMPORT\n            : BindingFlag.TYPE_TS_VALUE_IMPORT,\n        );\n      }\n    }\n  };\n\nfunction isPossiblyLiteralEnum(expression: N.Expression): boolean {\n  if (expression.type !== \"MemberExpression\") return false;\n\n  const { computed, property } = expression;\n\n  if (\n    computed &&\n    property.type !== \"StringLiteral\" &&\n    (property.type !== \"TemplateLiteral\" || property.expressions.length > 0)\n  ) {\n    return false;\n  }\n\n  return isUncomputedMemberExpressionChain(expression.object);\n}\n\n// If a const declaration has no type annotation and is initialized to\n// a string literal, numeric literal, or enum reference, then it is\n// allowed. In an ideal world, we'd check whether init was *actually* an\n// enum reference, but we allow anything that \"could be\" a literal enum\n// in `isPossiblyLiteralEnum` since we don't have all the information\n// that the typescript compiler has.\nfunction isValidAmbientConstInitializer(\n  expression: N.Expression,\n  estree: boolean,\n): boolean {\n  const { type } = expression;\n  if (expression.extra?.parenthesized) {\n    return false;\n  }\n  if (estree) {\n    if (type === \"Literal\") {\n      const { value } = expression;\n      if (typeof value === \"string\" || typeof value === \"boolean\") {\n        return true;\n      }\n    }\n  } else {\n    if (type === \"StringLiteral\" || type === \"BooleanLiteral\") {\n      return true;\n    }\n  }\n  if (isNumber(expression, estree) || isNegativeNumber(expression, estree)) {\n    return true;\n  }\n  if (type === \"TemplateLiteral\" && expression.expressions.length === 0) {\n    return true;\n  }\n  if (isPossiblyLiteralEnum(expression)) {\n    return true;\n  }\n  return false;\n}\n\nfunction isNumber(expression: N.Expression, estree: boolean): boolean {\n  if (estree) {\n    return (\n      expression.type === \"Literal\" &&\n      (typeof expression.value === \"number\" || \"bigint\" in expression)\n    );\n  }\n  return (\n    expression.type === \"NumericLiteral\" || expression.type === \"BigIntLiteral\"\n  );\n}\n\nfunction isNegativeNumber(expression: N.Expression, estree: boolean): boolean {\n  if (expression.type === \"UnaryExpression\") {\n    const { operator, argument } = expression;\n    if (operator === \"-\" && isNumber(argument, estree)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction isUncomputedMemberExpressionChain(expression: N.Expression): boolean {\n  if (expression.type === \"Identifier\") return true;\n  if (expression.type !== \"MemberExpression\" || expression.computed) {\n    return false;\n  }\n\n  return isUncomputedMemberExpressionChain(expression.object);\n}\n"],"mappings":"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","ignoreList":[]}