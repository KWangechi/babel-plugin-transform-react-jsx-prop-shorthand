{"version":3,"names":["_parseError","require","_options","defineProperty","Object","toUnenumerable","object","key","enumerable","value","toESTreeLocation","node","loc","start","end","_default","superClass","ESTreeParserMixin","parse","file","optionFlags","OptionFlags","Tokens","tokens","map","parseRegExpLiteral","pattern","flags","regex","RegExp","_","estreeParseLiteral","parseBigIntLiteral","bigInt","BigInt","bigint","String","parseDecimalLiteral","decimal","parseLiteral","parseStringLiteral","parseNumericLiteral","parseNullLiteral","parseBooleanLiteral","directiveToStmt","directive","expression","type","raw","extra","expressionValue","stmt","rawValue","initFunction","isAsync","checkDeclaration","isObjectProperty","getObjectOrClassMethodParams","method","params","isValidDirective","parenthesized","parseBlockBody","allowDirectives","topLevel","afterBlockParse","directiveStatements","directives","d","body","concat","parsePrivateName","process","env","BABEL_8_BREAKING","getPluginOption","convertPrivateNameToPrivateIdentifier","name","getPrivateNameSV","id","isPrivateName","parseFunctionBody","allowExpression","isMethod","parseMethod","isGenerator","isConstructor","allowDirectSuper","inClassScope","funcNode","startNode","kind","typeParameters","resetStartLocationFromNode","computed","hasPlugin","abstract","finishNode","nameIsConstructor","parseClassProperty","args","propertyNode","parseClassPrivateProperty","parseObjectMethod","prop","isPattern","isAccessor","shorthand","parseObjectProperty","startLoc","refExpressionErrors","isValidLVal","isUnparenthesizedInAssign","binding","isAssignable","isBinding","toAssignable","isLHS","classScope","usePrivateName","toAssignableObjectExpressionProp","isLast","raise","Errors","PatternHasAccessor","PatternHasMethod","finishCallExpression","unfinished","optional","callee","source","arguments","options","attributes","toReferencedArguments","parseExport","decorators","exportStartLoc","state","lastTokStartLoc","exported","specifiers","length","declaration","resetStartLocation","parseSubscript","base","noCalls","optionalChainMember","substring","stop","chain","startNodeAtNode","isOptionalMemberExpression","hasPropertyAsPrivateName","isObjectMethod","finishNodeAt","endLoc","resetEndLocation","lastTokEndLoc","exports","default"],"sources":["../../src/plugins/estree.ts"],"sourcesContent":["import type { TokenType } from \"../tokenizer/types.ts\";\nimport type Parser from \"../parser/index.ts\";\nimport type { ExpressionErrors } from \"../parser/util.ts\";\nimport type * as N from \"../types.ts\";\nimport type { Node as NodeType, NodeBase, File } from \"../types.ts\";\nimport type { Position } from \"../util/location.ts\";\nimport { Errors } from \"../parse-error.ts\";\nimport type { Undone } from \"../parser/node.ts\";\nimport type { BindingFlag } from \"../util/scopeflags.ts\";\nimport { OptionFlags } from \"../options.ts\";\n\nconst { defineProperty } = Object;\nconst toUnenumerable = (object: any, key: string) => {\n  if (object) {\n    defineProperty(object, key, { enumerable: false, value: object[key] });\n  }\n};\n\nfunction toESTreeLocation(node: any) {\n  toUnenumerable(node.loc.start, \"index\");\n  toUnenumerable(node.loc.end, \"index\");\n\n  return node;\n}\n\nexport default (superClass: typeof Parser) =>\n  class ESTreeParserMixin extends superClass implements Parser {\n    parse(): File {\n      const file = toESTreeLocation(super.parse());\n\n      if (this.optionFlags & OptionFlags.Tokens) {\n        file.tokens = file.tokens.map(toESTreeLocation);\n      }\n\n      return file;\n    }\n\n    // @ts-expect-error ESTree plugin changes node types\n    parseRegExpLiteral({ pattern, flags }): N.EstreeRegExpLiteral {\n      let regex: RegExp | null = null;\n      try {\n        regex = new RegExp(pattern, flags);\n      } catch (_) {\n        // In environments that don't support these flags value will\n        // be null as the regex can't be represented natively.\n      }\n      const node = this.estreeParseLiteral<N.EstreeRegExpLiteral>(regex);\n      node.regex = { pattern, flags };\n\n      return node;\n    }\n\n    // @ts-expect-error ESTree plugin changes node types\n    parseBigIntLiteral(value: any): N.Node {\n      // https://github.com/estree/estree/blob/master/es2020.md#bigintliteral\n      let bigInt: bigint | null;\n      try {\n        bigInt = BigInt(value);\n      } catch {\n        bigInt = null;\n      }\n      const node = this.estreeParseLiteral<N.EstreeBigIntLiteral>(bigInt);\n      node.bigint = String(node.value || value);\n\n      return node;\n    }\n\n    // @ts-expect-error ESTree plugin changes node types\n    parseDecimalLiteral(value: any): N.Node {\n      // https://github.com/estree/estree/blob/master/experimental/decimal.md\n      // todo: use BigDecimal when node supports it.\n      const decimal: null = null;\n      const node = this.estreeParseLiteral(decimal);\n      node.decimal = String(node.value || value);\n\n      return node;\n    }\n\n    estreeParseLiteral<T extends N.EstreeLiteral>(value: any) {\n      // @ts-expect-error ESTree plugin changes node types\n      return this.parseLiteral<T>(value, \"Literal\");\n    }\n\n    // @ts-expect-error ESTree plugin changes node types\n    parseStringLiteral(value: any): N.Node {\n      return this.estreeParseLiteral(value);\n    }\n\n    parseNumericLiteral(value: any): any {\n      return this.estreeParseLiteral(value);\n    }\n\n    // @ts-expect-error ESTree plugin changes node types\n    parseNullLiteral(): N.Node {\n      return this.estreeParseLiteral(null);\n    }\n\n    parseBooleanLiteral(value: boolean): N.BooleanLiteral {\n      // @ts-expect-error ESTree plugin changes node types\n      return this.estreeParseLiteral(value);\n    }\n\n    // Cast a Directive to an ExpressionStatement. Mutates the input Directive.\n    directiveToStmt(directive: N.Directive): N.ExpressionStatement {\n      const expression = directive.value as any as N.EstreeLiteral;\n      delete directive.value;\n\n      expression.type = \"Literal\";\n      // @ts-expect-error N.EstreeLiteral.raw is not defined.\n      expression.raw = expression.extra.raw;\n      expression.value = expression.extra.expressionValue;\n\n      const stmt = directive as any as N.ExpressionStatement;\n      stmt.type = \"ExpressionStatement\";\n      stmt.expression = expression;\n      // @ts-expect-error N.ExpressionStatement.directive is not defined\n      stmt.directive = expression.extra.rawValue;\n\n      delete expression.extra;\n\n      return stmt;\n    }\n\n    // ==================================\n    // Overrides\n    // ==================================\n\n    initFunction(node: N.BodilessFunctionOrMethodBase, isAsync: boolean): void {\n      super.initFunction(node, isAsync);\n      node.expression = false;\n    }\n\n    checkDeclaration(node: N.Pattern | N.ObjectProperty): void {\n      if (node != null && this.isObjectProperty(node)) {\n        // @ts-expect-error plugin typings\n        this.checkDeclaration((node as unknown as N.EstreeProperty).value);\n      } else {\n        super.checkDeclaration(node);\n      }\n    }\n\n    getObjectOrClassMethodParams(method: N.ObjectMethod | N.ClassMethod) {\n      return (method as unknown as N.EstreeMethodDefinition).value.params;\n    }\n\n    isValidDirective(stmt: N.Statement): boolean {\n      return (\n        stmt.type === \"ExpressionStatement\" &&\n        stmt.expression.type === \"Literal\" &&\n        typeof stmt.expression.value === \"string\" &&\n        !stmt.expression.extra?.parenthesized\n      );\n    }\n\n    parseBlockBody(\n      node: N.BlockStatementLike,\n      allowDirectives: boolean | undefined | null,\n      topLevel: boolean,\n      end: TokenType,\n      afterBlockParse?: (hasStrictModeDirective: boolean) => void,\n    ): void {\n      super.parseBlockBody(\n        node,\n        allowDirectives,\n        topLevel,\n        end,\n        afterBlockParse,\n      );\n\n      const directiveStatements = node.directives.map(d =>\n        this.directiveToStmt(d),\n      );\n      // @ts-expect-error estree plugin typings\n      node.body = directiveStatements.concat(node.body);\n      delete node.directives;\n    }\n\n    parsePrivateName(): any {\n      const node = super.parsePrivateName();\n      if (!process.env.BABEL_8_BREAKING) {\n        if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n          return node;\n        }\n      }\n      return this.convertPrivateNameToPrivateIdentifier(node);\n    }\n\n    convertPrivateNameToPrivateIdentifier(\n      node: N.PrivateName,\n    ): N.EstreePrivateIdentifier {\n      const name = super.getPrivateNameSV(node);\n      node = node as any;\n      delete node.id;\n      // @ts-expect-error mutate AST types\n      node.name = name;\n      // @ts-expect-error mutate AST types\n      node.type = \"PrivateIdentifier\";\n      return node as unknown as N.EstreePrivateIdentifier;\n    }\n\n    // @ts-expect-error ESTree plugin changes node types\n    isPrivateName(node: N.Node): node is N.EstreePrivateIdentifier {\n      if (!process.env.BABEL_8_BREAKING) {\n        if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n          return super.isPrivateName(node);\n        }\n      }\n      return node.type === \"PrivateIdentifier\";\n    }\n\n    // @ts-expect-error ESTree plugin changes node types\n    getPrivateNameSV(node: N.EstreePrivateIdentifier): string {\n      if (!process.env.BABEL_8_BREAKING) {\n        if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n          return super.getPrivateNameSV(node as unknown as N.PrivateName);\n        }\n      }\n      return node.name;\n    }\n\n    // @ts-expect-error plugin may override interfaces\n    parseLiteral<T extends N.Literal>(value: any, type: T[\"type\"]): T {\n      const node = super.parseLiteral<T>(value, type);\n      // @ts-expect-error mutating AST types\n      node.raw = node.extra.raw;\n      delete node.extra;\n\n      return node;\n    }\n\n    parseFunctionBody(\n      node: N.Function,\n      allowExpression?: boolean | null,\n      isMethod: boolean = false,\n    ): void {\n      super.parseFunctionBody(node, allowExpression, isMethod);\n      node.expression = node.body.type !== \"BlockStatement\";\n    }\n\n    // @ts-expect-error plugin may override interfaces\n    parseMethod<\n      T extends N.ClassPrivateMethod | N.ObjectMethod | N.ClassMethod,\n    >(\n      node: Undone<T>,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isConstructor: boolean,\n      allowDirectSuper: boolean,\n      type: T[\"type\"],\n      inClassScope: boolean = false,\n    ): N.EstreeMethodDefinition | N.EstreeTSAbstractMethodDefinition {\n      let funcNode = this.startNode<N.MethodLike>();\n      funcNode.kind = node.kind; // provide kind, so super method correctly sets state\n      funcNode = super.parseMethod(\n        // @ts-expect-error todo(flow->ts)\n        funcNode,\n        isGenerator,\n        isAsync,\n        isConstructor,\n        allowDirectSuper,\n        type,\n        inClassScope,\n      );\n      // @ts-expect-error mutate AST types\n      funcNode.type = \"FunctionExpression\";\n      delete funcNode.kind;\n      // @ts-expect-error mutate AST types\n      node.value = funcNode;\n      const { typeParameters } = node;\n      if (typeParameters) {\n        delete node.typeParameters;\n        funcNode.typeParameters = typeParameters;\n        this.resetStartLocationFromNode(funcNode, typeParameters);\n      }\n      if (type === \"ClassPrivateMethod\") {\n        node.computed = false;\n      }\n      if (process.env.BABEL_8_BREAKING && this.hasPlugin(\"typescript\")) {\n        if (!funcNode.body) {\n          (funcNode as unknown as N.EstreeTSEmptyBodyFunctionExpression).type =\n            \"TSEmptyBodyFunctionExpression\";\n        }\n        // @ts-expect-error todo(flow->ts) property not defined for all types in union\n        if (node.abstract) {\n          return this.finishNode(\n            // @ts-expect-error cast methods to estree types\n            node as Undone<N.EstreeTSAbstractMethodDefinition>,\n            \"TSAbstractMethodDefinition\",\n          );\n        }\n      }\n      return this.finishNode(\n        // @ts-expect-error cast methods to estree types\n        node as Undone<N.EstreeMethodDefinition>,\n        \"MethodDefinition\",\n      );\n    }\n\n    nameIsConstructor(key: N.Expression | N.PrivateName): boolean {\n      if (key.type === \"Literal\") return key.value === \"constructor\";\n      return super.nameIsConstructor(key);\n    }\n\n    parseClassProperty(...args: [N.ClassProperty]): any {\n      const propertyNode = super.parseClassProperty(...args);\n      if (!process.env.BABEL_8_BREAKING) {\n        if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n          return propertyNode as unknown as N.EstreePropertyDefinition;\n        }\n      }\n      if (\n        process.env.BABEL_8_BREAKING &&\n        propertyNode.abstract &&\n        this.hasPlugin(\"typescript\")\n      ) {\n        (propertyNode as unknown as N.EstreeTSAbstractPropertyDefinition).type =\n          \"TSAbstractPropertyDefinition\";\n      } else {\n        (propertyNode as unknown as N.EstreePropertyDefinition).type =\n          \"PropertyDefinition\";\n      }\n      return propertyNode;\n    }\n\n    parseClassPrivateProperty(...args: [N.ClassPrivateProperty]): any {\n      const propertyNode = super.parseClassPrivateProperty(...args);\n      if (!process.env.BABEL_8_BREAKING) {\n        if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n          return propertyNode as unknown as N.EstreePropertyDefinition;\n        }\n      }\n      if (\n        process.env.BABEL_8_BREAKING &&\n        propertyNode.abstract &&\n        this.hasPlugin(\"typescript\")\n      ) {\n        (propertyNode as unknown as N.EstreeTSAbstractPropertyDefinition).type =\n          \"TSAbstractPropertyDefinition\";\n      } else {\n        (propertyNode as unknown as N.EstreePropertyDefinition).type =\n          \"PropertyDefinition\";\n      }\n      propertyNode.computed = false;\n      return propertyNode;\n    }\n\n    parseObjectMethod(\n      prop: N.ObjectMethod,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isPattern: boolean,\n      isAccessor: boolean,\n    ): N.ObjectMethod | undefined | null {\n      const node: N.EstreeProperty = super.parseObjectMethod(\n        prop,\n        isGenerator,\n        isAsync,\n        isPattern,\n        isAccessor,\n      ) as any;\n\n      if (node) {\n        node.type = \"Property\";\n        if ((node as any as N.ClassMethod).kind === \"method\") {\n          node.kind = \"init\";\n        }\n        node.shorthand = false;\n      }\n\n      return node as any;\n    }\n\n    parseObjectProperty(\n      prop: N.ObjectProperty,\n      startLoc: Position | undefined | null,\n      isPattern: boolean,\n      refExpressionErrors?: ExpressionErrors | null,\n    ): N.ObjectProperty | undefined | null {\n      const node: N.EstreeProperty = super.parseObjectProperty(\n        prop,\n        startLoc,\n        isPattern,\n        refExpressionErrors,\n      ) as any;\n\n      if (node) {\n        node.kind = \"init\";\n        node.type = \"Property\";\n      }\n\n      return node as any;\n    }\n\n    isValidLVal(\n      type: string,\n      isUnparenthesizedInAssign: boolean,\n      binding: BindingFlag,\n    ) {\n      return type === \"Property\"\n        ? \"value\"\n        : super.isValidLVal(type, isUnparenthesizedInAssign, binding);\n    }\n\n    isAssignable(node: N.Node, isBinding?: boolean): boolean {\n      if (node != null && this.isObjectProperty(node)) {\n        return this.isAssignable(node.value, isBinding);\n      }\n      return super.isAssignable(node, isBinding);\n    }\n\n    toAssignable(node: N.Node, isLHS: boolean = false): void {\n      if (node != null && this.isObjectProperty(node)) {\n        const { key, value } = node;\n        if (this.isPrivateName(key)) {\n          this.classScope.usePrivateName(\n            this.getPrivateNameSV(key),\n            key.loc.start,\n          );\n        }\n        this.toAssignable(value, isLHS);\n      } else {\n        super.toAssignable(node, isLHS);\n      }\n    }\n\n    toAssignableObjectExpressionProp(\n      prop: N.Node,\n      isLast: boolean,\n      isLHS: boolean,\n    ) {\n      if (\n        prop.type === \"Property\" &&\n        (prop.kind === \"get\" || prop.kind === \"set\")\n      ) {\n        this.raise(Errors.PatternHasAccessor, prop.key);\n      } else if (prop.type === \"Property\" && prop.method) {\n        this.raise(Errors.PatternHasMethod, prop.key);\n      } else {\n        super.toAssignableObjectExpressionProp(prop, isLast, isLHS);\n      }\n    }\n\n    finishCallExpression<T extends N.CallExpression | N.OptionalCallExpression>(\n      unfinished: Undone<T>,\n      optional: boolean,\n    ): T {\n      const node = super.finishCallExpression(unfinished, optional);\n\n      if (node.callee.type === \"Import\") {\n        (node as N.Node as N.EstreeImportExpression).type = \"ImportExpression\";\n        (node as N.Node as N.EstreeImportExpression).source = node\n          .arguments[0] as N.Expression;\n        (node as N.Node as N.EstreeImportExpression).options =\n          (node.arguments[1] as N.Expression) ?? null;\n        // compatibility with previous ESTree AST\n        // TODO(Babel 8): Remove this\n        (node as N.Node as N.EstreeImportExpression).attributes =\n          (node.arguments[1] as N.Expression) ?? null;\n        // arguments isn't optional in the type definition\n        delete node.arguments;\n        // callee isn't optional in the type definition\n        delete node.callee;\n      }\n\n      return node;\n    }\n\n    toReferencedArguments(\n      node:\n        | N.CallExpression\n        | N.OptionalCallExpression\n        | N.EstreeImportExpression,\n      /* isParenthesizedExpr?: boolean, */\n    ) {\n      // ImportExpressions do not have an arguments array.\n      if (node.type === \"ImportExpression\") {\n        return;\n      }\n\n      super.toReferencedArguments(node);\n    }\n\n    parseExport(\n      unfinished: Undone<N.AnyExport>,\n      decorators: N.Decorator[] | null,\n    ) {\n      const exportStartLoc = this.state.lastTokStartLoc;\n      const node = super.parseExport(unfinished, decorators);\n\n      switch (node.type) {\n        case \"ExportAllDeclaration\":\n          // @ts-expect-error mutating AST types\n          node.exported = null;\n          break;\n\n        case \"ExportNamedDeclaration\":\n          if (\n            node.specifiers.length === 1 &&\n            node.specifiers[0].type === \"ExportNamespaceSpecifier\"\n          ) {\n            // @ts-expect-error mutating AST types\n            node.type = \"ExportAllDeclaration\";\n            // @ts-expect-error mutating AST types\n            node.exported = node.specifiers[0].exported;\n            delete node.specifiers;\n          }\n\n        // fallthrough\n        case \"ExportDefaultDeclaration\":\n          {\n            const { declaration } = node;\n            if (\n              declaration?.type === \"ClassDeclaration\" &&\n              declaration.decorators?.length > 0 &&\n              // decorator comes before export\n              declaration.start === node.start\n            ) {\n              this.resetStartLocation(\n                node,\n                // For compatibility with ESLint's keyword-spacing rule, which assumes that an\n                // export declaration must start with export.\n                // https://github.com/babel/babel/issues/15085\n                // Here we reset export declaration's start to be the start of the export token\n                exportStartLoc,\n              );\n            }\n          }\n\n          break;\n      }\n\n      return node;\n    }\n\n    parseSubscript(\n      base: N.Expression,\n      startLoc: Position,\n      noCalls: boolean | undefined | null,\n      state: N.ParseSubscriptState,\n    ): N.Expression {\n      const node = super.parseSubscript(base, startLoc, noCalls, state);\n\n      if (state.optionalChainMember) {\n        // https://github.com/estree/estree/blob/master/es2020.md#chainexpression\n        if (\n          node.type === \"OptionalMemberExpression\" ||\n          node.type === \"OptionalCallExpression\"\n        ) {\n          // strip Optional prefix\n          (node as unknown as N.CallExpression | N.MemberExpression).type =\n            node.type.substring(8) as \"CallExpression\" | \"MemberExpression\";\n        }\n        if (state.stop) {\n          const chain = this.startNodeAtNode<N.EstreeChainExpression>(node);\n          chain.expression = node;\n          return this.finishNode(chain, \"ChainExpression\");\n        }\n      } else if (\n        node.type === \"MemberExpression\" ||\n        node.type === \"CallExpression\"\n      ) {\n        // @ts-expect-error not in the type definitions\n        node.optional = false;\n      }\n\n      return node;\n    }\n\n    isOptionalMemberExpression(node: N.Node) {\n      if (node.type === \"ChainExpression\") {\n        return node.expression.type === \"MemberExpression\";\n      }\n      return super.isOptionalMemberExpression(node);\n    }\n\n    hasPropertyAsPrivateName(node: N.Node): boolean {\n      if (node.type === \"ChainExpression\") {\n        node = node.expression;\n      }\n      return super.hasPropertyAsPrivateName(node);\n    }\n\n    // @ts-expect-error ESTree plugin changes node types\n    isObjectProperty(node: N.Node): node is N.EstreeProperty {\n      return node.type === \"Property\" && node.kind === \"init\" && !node.method;\n    }\n\n    // @ts-expect-error ESTree plugin changes node types\n    isObjectMethod(node: N.Node): node is N.EstreeProperty {\n      return (\n        node.type === \"Property\" &&\n        (node.method || node.kind === \"get\" || node.kind === \"set\")\n      );\n    }\n\n    finishNodeAt<T extends NodeType>(\n      node: Undone<T>,\n      type: T[\"type\"],\n      endLoc: Position,\n    ): T {\n      return toESTreeLocation(super.finishNodeAt(node, type, endLoc));\n    }\n\n    resetStartLocation(node: N.Node, startLoc: Position) {\n      super.resetStartLocation(node, startLoc);\n      toESTreeLocation(node);\n    }\n\n    resetEndLocation(\n      node: NodeBase,\n      endLoc: Position = this.state.lastTokEndLoc,\n    ): void {\n      super.resetEndLocation(node, endLoc);\n      toESTreeLocation(node);\n    }\n  };\n"],"mappings":"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","ignoreList":[]}