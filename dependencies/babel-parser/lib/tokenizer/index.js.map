{"version":3,"names":["_options","require","_location","_comments","_identifier","_types","_parseError","_whitespace","_state","_helperStringParser","buildPosition","pos","lineStart","curLine","Position","VALID_REGEX_FLAGS","Set","Token","constructor","state","startIndex","type","value","start","end","loc","SourceLocation","startLoc","endLoc","exports","Tokenizer","CommentsParser","isLookahead","tokens","options","input","State","init","length","comments","pushToken","token","tokensLength","push","next","checkKeywordEscapes","optionFlags","OptionFlags","Tokens","lastTokEndLoc","lastTokStartLoc","nextToken","eat","match","createLookaheadState","context","curContext","inType","curPosition","lookahead","old","curr","nextTokenStart","nextTokenStartSince","skipWhiteSpace","lastIndex","test","lookaheadCharCode","charCodeAt","nextTokenInLineStart","nextTokenInLineStartSince","skipWhiteSpaceInLine","lookaheadInLineCharCode","codePointAtPos","cp","trail","setStrict","strict","strictErrors","forEach","toParseError","at","raise","clear","skipSpace","finishToken","getTokenFromCode","skipBlockComment","commentEnd","indexOf","Errors","UnterminatedComment","lineBreakG","comment","slice","sourceToOffsetPos","skipLineComment","startSkip","ch","isNewLine","spaceStart","AttachComment","loop","undefined","addComment","isWhitespace","inModule","AnnexB","commentWhitespace","leadingNode","trailingNode","containingNode","commentStack","val","prevType","updateContext","replaceToken","readToken_numberSign","readToken_interpreter","nextPos","UnexpectedDigitAfterHash","hasPlugin","expectPlugin","process","env","BABEL_8_BREAKING","getPluginOption","RecordExpressionHashIncorrectStartSyntaxType","TupleExpressionHashIncorrectStartSyntaxType","isIdentifierStart","readWord1","finishOp","readToken_dot","readNumber","readToken_slash","readToken_mult_modulo","code","width","readToken_pipe_amp","RecordExpressionBarIncorrectEndSyntaxType","TupleExpressionBarIncorrectEndSyntaxType","readToken_caret","proposal","topicToken","lookaheadCh","codePointAt","unexpected","readToken_atSign","readToken_plus_min","readToken_lt","readToken_gt","size","readToken_eq_excl","readToken_question","next2","TupleExpressionBarIncorrectStartSyntaxType","RecordExpressionBarIncorrectStartSyntaxType","readTemplateToken","readRadixNumber","readString","readWord","InvalidOrUnexpectedToken","String","fromCodePoint","str","readRegexp","escaped","inClass","UnterminatedRegExp","createPositionWithColumnOffset","content","mods","char","fromCharCode","has","includes","IncompatibleRegExpUVFlags","DuplicateRegExpFlags","isIdentifierChar","MalformedRegExpFlags","pattern","flags","readInt","radix","len","forceLen","allowNumSeparator","n","errorHandlers_readInt","isBigInt","InvalidDigit","InvalidDecimal","NumberIdentifier","replace","startsWithDot","isFloat","hasExponent","isOctal","InvalidNumber","hasLeadingZero","integer","recordStrictModeErrors","StrictOctalLiteral","underscorePos","ZeroDigitNumericSeparator","InvalidOrMissingExponent","InvalidBigIntLiteral","isDecimal","parseInt","parseFloat","readCodePoint","throwOnInvalid","errorHandlers_readCodePoint","quote","readStringContents","errorHandlers_readStringContents_string","readTemplateContinuation","opening","firstInvalidLoc","errorHandlers_readStringContents_template","firstInvalidTemplateEscapePos","index","set","firstCode","containsEsc","word","chunkStart","escStart","identifierCheck","MissingUnicodeEscape","esc","EscapedCharNotAnIdentifier","keywordTypes","get","tokenLabelName","tokenIsKeyword","InvalidEscapedReservedWord","reservedWord","details","error","ErrorRecovery","errors","raiseOverwrite","i","UnexpectedToken","expected","pluginName","MissingPlugin","missingPlugin","expectOnePlugin","pluginNames","some","name","MissingOneOfPlugins","errorBuilder","invalidDigit","numericSeparatorInEscapeSequence","NumericSeparatorInEscapeSequence","unexpectedNumericSeparator","UnexpectedNumericSeparator","Object","assign","invalidEscapeSequence","InvalidEscapeSequence","invalidCodePoint","InvalidCodePoint","strictNumericEscape","StrictNumericEscape","unterminated","UnterminatedString","UnterminatedTemplate","default"],"sources":["../../src/tokenizer/index.ts"],"sourcesContent":["/*:: declare var invariant; */\n\nimport { OptionFlags, type Options } from \"../options.ts\";\nimport {\n  Position,\n  SourceLocation,\n  createPositionWithColumnOffset,\n} from \"../util/location.ts\";\nimport CommentsParser, { type CommentWhitespace } from \"../parser/comments.ts\";\nimport type * as N from \"../types.ts\";\nimport * as charCodes from \"charcodes\";\nimport { isIdentifierStart, isIdentifierChar } from \"../util/identifier.ts\";\nimport {\n  tokenIsKeyword,\n  tokenLabelName,\n  tt,\n  keywords as keywordTypes,\n  type TokenType,\n} from \"./types.ts\";\nimport type { TokContext } from \"./context.ts\";\nimport {\n  Errors,\n  type ParseError,\n  type ParseErrorConstructor,\n} from \"../parse-error.ts\";\nimport {\n  lineBreakG,\n  isNewLine,\n  isWhitespace,\n  skipWhiteSpace,\n  skipWhiteSpaceInLine,\n} from \"../util/whitespace.ts\";\nimport State from \"./state.ts\";\nimport type { LookaheadState, DeferredStrictError } from \"./state.ts\";\nimport type { Undone } from \"../parser/node.ts\";\nimport type { Node } from \"../types.ts\";\n\nimport {\n  readInt,\n  readCodePoint,\n  readStringContents,\n  type IntErrorHandlers,\n  type CodePointErrorHandlers,\n  type StringContentsErrorHandlers,\n} from \"@babel/helper-string-parser\";\n\nimport type { Plugin } from \"../typings.ts\";\n\nfunction buildPosition(pos: number, lineStart: number, curLine: number) {\n  return new Position(curLine, pos - lineStart, pos);\n}\n\nconst VALID_REGEX_FLAGS = new Set([\n  charCodes.lowercaseG,\n  charCodes.lowercaseM,\n  charCodes.lowercaseS,\n  charCodes.lowercaseI,\n  charCodes.lowercaseY,\n  charCodes.lowercaseU,\n  charCodes.lowercaseD,\n  charCodes.lowercaseV,\n]);\n\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\n\nexport class Token {\n  constructor(state: State) {\n    const startIndex = state.startIndex || 0;\n    this.type = state.type;\n    this.value = state.value;\n    this.start = startIndex + state.start;\n    this.end = startIndex + state.end;\n    this.loc = new SourceLocation(state.startLoc, state.endLoc);\n  }\n\n  declare type: TokenType;\n  declare value: any;\n  declare start: number;\n  declare end: number;\n  declare loc: SourceLocation;\n}\n\n// ## Tokenizer\n\nexport default abstract class Tokenizer extends CommentsParser {\n  isLookahead: boolean;\n\n  // Token store.\n  tokens: Array<Token | N.Comment> = [];\n\n  constructor(options: Options, input: string) {\n    super();\n    this.state = new State();\n    this.state.init(options);\n    this.input = input;\n    this.length = input.length;\n    this.comments = [];\n    this.isLookahead = false;\n  }\n\n  pushToken(token: Token | N.Comment) {\n    // Pop out invalid tokens trapped by try-catch parsing.\n    // Those parsing branches are mainly created by typescript and flow plugins.\n    this.tokens.length = this.state.tokensLength;\n    this.tokens.push(token);\n    ++this.state.tokensLength;\n  }\n\n  // Move to the next token\n\n  next(): void {\n    this.checkKeywordEscapes();\n    if (this.optionFlags & OptionFlags.Tokens) {\n      this.pushToken(new Token(this.state));\n    }\n\n    this.state.lastTokEndLoc = this.state.endLoc;\n    this.state.lastTokStartLoc = this.state.startLoc;\n    this.nextToken();\n  }\n\n  eat(type: TokenType): boolean {\n    if (this.match(type)) {\n      this.next();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Whether current token matches given type\n   */\n  match(type: TokenType): boolean {\n    return this.state.type === type;\n  }\n\n  /**\n   * Create a LookaheadState from current parser state\n   */\n  createLookaheadState(state: State): LookaheadState {\n    return {\n      pos: state.pos,\n      value: null,\n      type: state.type,\n      start: state.start,\n      end: state.end,\n      context: [this.curContext()],\n      inType: state.inType,\n      startLoc: state.startLoc,\n      lastTokEndLoc: state.lastTokEndLoc,\n      curLine: state.curLine,\n      lineStart: state.lineStart,\n      curPosition: state.curPosition,\n    };\n  }\n\n  /**\n   * lookahead peeks the next token, skipping changes to token context and\n   * comment stack. For performance it returns a limited LookaheadState\n   * instead of full parser state.\n   *\n   * The { column, line } Loc info is not included in lookahead since such usage\n   * is rare. Although it may return other location properties e.g. `curLine` and\n   * `lineStart`, these properties are not listed in the LookaheadState interface\n   * and thus the returned value is _NOT_ reliable.\n   *\n   * The tokenizer should make best efforts to avoid using any parser state\n   * other than those defined in LookaheadState\n   */\n  lookahead(): LookaheadState {\n    const old = this.state;\n    // @ts-expect-error For performance we use a simplified tokenizer state structure\n    this.state = this.createLookaheadState(old);\n\n    this.isLookahead = true;\n    this.nextToken();\n    this.isLookahead = false;\n\n    const curr = this.state;\n    this.state = old;\n    return curr;\n  }\n\n  nextTokenStart(): number {\n    return this.nextTokenStartSince(this.state.pos);\n  }\n\n  nextTokenStartSince(pos: number): number {\n    skipWhiteSpace.lastIndex = pos;\n    return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;\n  }\n\n  lookaheadCharCode(): number {\n    return this.input.charCodeAt(this.nextTokenStart());\n  }\n\n  /**\n   * Similar to nextToken, but it will stop at line break when it is seen before the next token\n   *\n   * @returns {number} position of the next token start or line break, whichever is seen first.\n   * @memberof Tokenizer\n   */\n  nextTokenInLineStart(): number {\n    return this.nextTokenInLineStartSince(this.state.pos);\n  }\n\n  nextTokenInLineStartSince(pos: number): number {\n    skipWhiteSpaceInLine.lastIndex = pos;\n    return skipWhiteSpaceInLine.test(this.input)\n      ? skipWhiteSpaceInLine.lastIndex\n      : pos;\n  }\n\n  /**\n   * Similar to lookaheadCharCode, but it will return the char code of line break if it is\n   * seen before the next token\n   *\n   * @returns {number} char code of the next token start or line break, whichever is seen first.\n   * @memberof Tokenizer\n   */\n  lookaheadInLineCharCode(): number {\n    return this.input.charCodeAt(this.nextTokenInLineStart());\n  }\n\n  codePointAtPos(pos: number): number {\n    // The implementation is based on\n    // https://source.chromium.org/chromium/chromium/src/+/master:v8/src/builtins/builtins-string-gen.cc;l=1455;drc=221e331b49dfefadbc6fa40b0c68e6f97606d0b3;bpv=0;bpt=1\n    // We reimplement `codePointAt` because `codePointAt` is a V8 builtin which is not inlined by TurboFan (as of M91)\n    // since `input` is mostly ASCII, an inlined `charCodeAt` wins here\n    let cp = this.input.charCodeAt(pos);\n    if ((cp & 0xfc00) === 0xd800 && ++pos < this.input.length) {\n      const trail = this.input.charCodeAt(pos);\n      if ((trail & 0xfc00) === 0xdc00) {\n        cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);\n      }\n    }\n    return cp;\n  }\n\n  // Toggle strict mode. Re-reads the next number or string to please\n  // pedantic tests (`\"use strict\"; 010;` should fail).\n\n  setStrict(strict: boolean): void {\n    this.state.strict = strict;\n    if (strict) {\n      // Throw an error for any string decimal escape found before/immediately\n      // after a \"use strict\" directive. Strict mode will be set at parse\n      // time for any literals that occur after the next node of the strict\n      // directive.\n      this.state.strictErrors.forEach(([toParseError, at]) =>\n        this.raise(toParseError, at),\n      );\n      this.state.strictErrors.clear();\n    }\n  }\n\n  curContext(): TokContext {\n    return this.state.context[this.state.context.length - 1];\n  }\n\n  // Read a single token, updating the parser object's token-related properties.\n  nextToken(): void {\n    this.skipSpace();\n    this.state.start = this.state.pos;\n    if (!this.isLookahead) this.state.startLoc = this.state.curPosition();\n    if (this.state.pos >= this.length) {\n      this.finishToken(tt.eof);\n      return;\n    }\n\n    this.getTokenFromCode(this.codePointAtPos(this.state.pos));\n  }\n\n  // Skips a block comment, whose end is marked by commentEnd.\n  // *-/ is used by the Flow plugin, when parsing block comments nested\n  // inside Flow comments.\n  skipBlockComment(commentEnd: \"*/\" | \"*-/\"): N.CommentBlock | undefined {\n    let startLoc;\n    if (!this.isLookahead) startLoc = this.state.curPosition();\n    const start = this.state.pos;\n    const end = this.input.indexOf(commentEnd, start + 2);\n    if (end === -1) {\n      // We have to call this again here because startLoc may not be set...\n      // This seems to be for performance reasons:\n      // https://github.com/babel/babel/commit/acf2a10899f696a8aaf34df78bf9725b5ea7f2da\n      throw this.raise(Errors.UnterminatedComment, this.state.curPosition());\n    }\n\n    this.state.pos = end + commentEnd.length;\n    lineBreakG.lastIndex = start + 2;\n    while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {\n      ++this.state.curLine;\n      this.state.lineStart = lineBreakG.lastIndex;\n    }\n\n    // If we are doing a lookahead right now we need to advance the position (above code)\n    // but we do not want to push the comment to the state.\n    if (this.isLookahead) return;\n    /*:: invariant(startLoc) */\n\n    const comment: N.CommentBlock = {\n      type: \"CommentBlock\",\n      value: this.input.slice(start + 2, end),\n      start: this.sourceToOffsetPos(start),\n      end: this.sourceToOffsetPos(end + commentEnd.length),\n      loc: new SourceLocation(startLoc, this.state.curPosition()),\n    };\n    if (this.optionFlags & OptionFlags.Tokens) this.pushToken(comment);\n    return comment;\n  }\n\n  skipLineComment(startSkip: number): N.CommentLine | undefined {\n    const start = this.state.pos;\n    let startLoc;\n    if (!this.isLookahead) startLoc = this.state.curPosition();\n    let ch = this.input.charCodeAt((this.state.pos += startSkip));\n    if (this.state.pos < this.length) {\n      while (!isNewLine(ch) && ++this.state.pos < this.length) {\n        ch = this.input.charCodeAt(this.state.pos);\n      }\n    }\n\n    // If we are doing a lookahead right now we need to advance the position (above code)\n    // but we do not want to push the comment to the state.\n    if (this.isLookahead) return;\n\n    const end = this.state.pos;\n    const value = this.input.slice(start + startSkip, end);\n\n    const comment: N.CommentLine = {\n      type: \"CommentLine\",\n      value,\n      start: this.sourceToOffsetPos(start),\n      end: this.sourceToOffsetPos(end),\n      loc: new SourceLocation(startLoc, this.state.curPosition()),\n    };\n    if (this.optionFlags & OptionFlags.Tokens) this.pushToken(comment);\n    return comment;\n  }\n\n  // Called at the start of the parse and after every token. Skips\n  // whitespace and comments, and.\n\n  skipSpace(): void {\n    const spaceStart = this.state.pos;\n    const comments: N.Comment[] =\n      this.optionFlags & OptionFlags.AttachComment ? [] : null;\n    loop: while (this.state.pos < this.length) {\n      const ch = this.input.charCodeAt(this.state.pos);\n      switch (ch) {\n        case charCodes.space:\n        case charCodes.nonBreakingSpace:\n        case charCodes.tab:\n          ++this.state.pos;\n          break;\n        case charCodes.carriageReturn:\n          if (\n            this.input.charCodeAt(this.state.pos + 1) === charCodes.lineFeed\n          ) {\n            ++this.state.pos;\n          }\n        // fall through\n        case charCodes.lineFeed:\n        case charCodes.lineSeparator:\n        case charCodes.paragraphSeparator:\n          ++this.state.pos;\n          ++this.state.curLine;\n          this.state.lineStart = this.state.pos;\n          break;\n\n        case charCodes.slash:\n          switch (this.input.charCodeAt(this.state.pos + 1)) {\n            case charCodes.asterisk: {\n              const comment = this.skipBlockComment(\"*/\");\n              if (comment !== undefined) {\n                this.addComment(comment);\n                comments?.push(comment);\n              }\n              break;\n            }\n\n            case charCodes.slash: {\n              const comment = this.skipLineComment(2);\n              if (comment !== undefined) {\n                this.addComment(comment);\n                comments?.push(comment);\n              }\n              break;\n            }\n\n            default:\n              break loop;\n          }\n          break;\n\n        default:\n          if (isWhitespace(ch)) {\n            ++this.state.pos;\n          } else if (\n            ch === charCodes.dash &&\n            !this.inModule &&\n            this.optionFlags & OptionFlags.AnnexB\n          ) {\n            const pos = this.state.pos;\n            if (\n              this.input.charCodeAt(pos + 1) === charCodes.dash &&\n              this.input.charCodeAt(pos + 2) === charCodes.greaterThan &&\n              (spaceStart === 0 || this.state.lineStart > spaceStart)\n            ) {\n              // A `-->` line comment\n              const comment = this.skipLineComment(3);\n              if (comment !== undefined) {\n                this.addComment(comment);\n                comments?.push(comment);\n              }\n            } else {\n              break loop;\n            }\n          } else if (\n            ch === charCodes.lessThan &&\n            !this.inModule &&\n            this.optionFlags & OptionFlags.AnnexB\n          ) {\n            const pos = this.state.pos;\n            if (\n              this.input.charCodeAt(pos + 1) === charCodes.exclamationMark &&\n              this.input.charCodeAt(pos + 2) === charCodes.dash &&\n              this.input.charCodeAt(pos + 3) === charCodes.dash\n            ) {\n              // `<!--`, an XML-style comment that should be interpreted as a line comment\n              const comment = this.skipLineComment(4);\n              if (comment !== undefined) {\n                this.addComment(comment);\n                comments?.push(comment);\n              }\n            } else {\n              break loop;\n            }\n          } else {\n            break loop;\n          }\n      }\n    }\n\n    if (comments?.length > 0) {\n      const end = this.state.pos;\n      const commentWhitespace: CommentWhitespace = {\n        start: this.sourceToOffsetPos(spaceStart),\n        end: this.sourceToOffsetPos(end),\n        comments,\n        leadingNode: null,\n        trailingNode: null,\n        containingNode: null,\n      };\n      this.state.commentStack.push(commentWhitespace);\n    }\n  }\n\n  // Called at the end of every token. Sets `end`, `val`, and\n  // maintains `context` and `canStartJSXElement`, and skips the space after\n  // the token, so that the next one's `start` will point at the\n  // right position.\n\n  finishToken(type: TokenType, val?: any): void {\n    this.state.end = this.state.pos;\n    this.state.endLoc = this.state.curPosition();\n    const prevType = this.state.type;\n    this.state.type = type;\n    this.state.value = val;\n\n    if (!this.isLookahead) {\n      this.updateContext(prevType);\n    }\n  }\n\n  replaceToken(type: TokenType): void {\n    this.state.type = type;\n    // @ts-expect-error the prevType of updateContext is required\n    // only when the new type is tt.slash/tt.jsxTagEnd\n    this.updateContext();\n  }\n\n  // ### Token reading\n\n  // This is the function that is called to fetch the next token. It\n  // is somewhat obscure, because it works in character codes rather\n  // than characters, and because operator parsing has been inlined\n  // into it.\n  //\n  // All in the name of speed.\n\n  // number sign is \"#\"\n  readToken_numberSign(): void {\n    if (this.state.pos === 0 && this.readToken_interpreter()) {\n      return;\n    }\n\n    const nextPos = this.state.pos + 1;\n    const next = this.codePointAtPos(nextPos);\n    if (next >= charCodes.digit0 && next <= charCodes.digit9) {\n      throw this.raise(\n        Errors.UnexpectedDigitAfterHash,\n        this.state.curPosition(),\n      );\n    }\n\n    if (\n      next === charCodes.leftCurlyBrace ||\n      (next === charCodes.leftSquareBracket && this.hasPlugin(\"recordAndTuple\"))\n    ) {\n      // When we see `#{`, it is likely to be a hash record.\n      // However we don't yell at `#[` since users may intend to use \"computed private fields\",\n      // which is not allowed in the spec. Throwing expecting recordAndTuple is\n      // misleading\n      this.expectPlugin(\"recordAndTuple\");\n      if (\n        !process.env.BABEL_8_BREAKING &&\n        this.getPluginOption(\"recordAndTuple\", \"syntaxType\") === \"bar\"\n      ) {\n        throw this.raise(\n          next === charCodes.leftCurlyBrace\n            ? Errors.RecordExpressionHashIncorrectStartSyntaxType\n            : Errors.TupleExpressionHashIncorrectStartSyntaxType,\n          this.state.curPosition(),\n        );\n      }\n\n      this.state.pos += 2;\n      if (next === charCodes.leftCurlyBrace) {\n        // #{\n        this.finishToken(tt.braceHashL);\n      } else {\n        // #[\n        this.finishToken(tt.bracketHashL);\n      }\n    } else if (isIdentifierStart(next)) {\n      ++this.state.pos;\n      this.finishToken(tt.privateName, this.readWord1(next));\n    } else if (next === charCodes.backslash) {\n      ++this.state.pos;\n      this.finishToken(tt.privateName, this.readWord1());\n    } else {\n      this.finishOp(tt.hash, 1);\n    }\n  }\n\n  readToken_dot(): void {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next >= charCodes.digit0 && next <= charCodes.digit9) {\n      this.readNumber(true);\n      return;\n    }\n\n    if (\n      next === charCodes.dot &&\n      this.input.charCodeAt(this.state.pos + 2) === charCodes.dot\n    ) {\n      this.state.pos += 3;\n      this.finishToken(tt.ellipsis);\n    } else {\n      ++this.state.pos;\n      this.finishToken(tt.dot);\n    }\n  }\n\n  readToken_slash(): void {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === charCodes.equalsTo) {\n      this.finishOp(tt.slashAssign, 2);\n    } else {\n      this.finishOp(tt.slash, 1);\n    }\n  }\n\n  readToken_interpreter(): boolean {\n    if (this.state.pos !== 0 || this.length < 2) return false;\n\n    let ch = this.input.charCodeAt(this.state.pos + 1);\n    if (ch !== charCodes.exclamationMark) return false;\n\n    const start = this.state.pos;\n    this.state.pos += 1;\n\n    while (!isNewLine(ch) && ++this.state.pos < this.length) {\n      ch = this.input.charCodeAt(this.state.pos);\n    }\n\n    const value = this.input.slice(start + 2, this.state.pos);\n\n    this.finishToken(tt.interpreterDirective, value);\n\n    return true;\n  }\n\n  readToken_mult_modulo(code: number): void {\n    // '%' or '*'\n    let type = code === charCodes.asterisk ? tt.star : tt.modulo;\n    let width = 1;\n    let next = this.input.charCodeAt(this.state.pos + 1);\n\n    // Exponentiation operator '**'\n    if (code === charCodes.asterisk && next === charCodes.asterisk) {\n      width++;\n      next = this.input.charCodeAt(this.state.pos + 2);\n      type = tt.exponent;\n    }\n\n    // '%=' or '*='\n    if (next === charCodes.equalsTo && !this.state.inType) {\n      width++;\n      // `tt.moduloAssign` is only needed to support % as a Hack-pipe topic token.\n      // If the proposal ends up choosing a different token,\n      // it can be merged with tt.assign.\n      type = code === charCodes.percentSign ? tt.moduloAssign : tt.assign;\n    }\n\n    this.finishOp(type, width);\n  }\n\n  readToken_pipe_amp(code: number): void {\n    // '||' '&&' '||=' '&&='\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === code) {\n      if (this.input.charCodeAt(this.state.pos + 2) === charCodes.equalsTo) {\n        this.finishOp(tt.assign, 3);\n      } else {\n        this.finishOp(\n          code === charCodes.verticalBar ? tt.logicalOR : tt.logicalAND,\n          2,\n        );\n      }\n      return;\n    }\n\n    if (code === charCodes.verticalBar) {\n      // '|>'\n      if (next === charCodes.greaterThan) {\n        this.finishOp(tt.pipeline, 2);\n        return;\n      }\n      // '|}'\n      if (\n        !process.env.BABEL_8_BREAKING &&\n        this.hasPlugin(\"recordAndTuple\") &&\n        next === charCodes.rightCurlyBrace\n      ) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(\n            Errors.RecordExpressionBarIncorrectEndSyntaxType,\n            this.state.curPosition(),\n          );\n        }\n        this.state.pos += 2;\n        this.finishToken(tt.braceBarR);\n        return;\n      }\n\n      // '|]'\n      if (\n        !process.env.BABEL_8_BREAKING &&\n        this.hasPlugin(\"recordAndTuple\") &&\n        next === charCodes.rightSquareBracket\n      ) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(\n            Errors.TupleExpressionBarIncorrectEndSyntaxType,\n            this.state.curPosition(),\n          );\n        }\n        this.state.pos += 2;\n        this.finishToken(tt.bracketBarR);\n        return;\n      }\n    }\n\n    if (next === charCodes.equalsTo) {\n      this.finishOp(tt.assign, 2);\n      return;\n    }\n\n    this.finishOp(\n      code === charCodes.verticalBar ? tt.bitwiseOR : tt.bitwiseAND,\n      1,\n    );\n  }\n\n  readToken_caret(): void {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    // '^='\n    if (next === charCodes.equalsTo && !this.state.inType) {\n      // `tt.xorAssign` is only needed to support ^ as a Hack-pipe topic token.\n      // If the proposal ends up choosing a different token,\n      // it can be merged with tt.assign.\n      this.finishOp(tt.xorAssign, 2);\n    }\n    // '^^'\n    else if (\n      next === charCodes.caret &&\n      // If the ^^ token is not enabled, we don't throw but parse two single ^s\n      // because it could be a ^ hack token followed by a ^ binary operator.\n      this.hasPlugin([\n        \"pipelineOperator\",\n        { proposal: \"hack\", topicToken: \"^^\" },\n      ])\n    ) {\n      this.finishOp(tt.doubleCaret, 2);\n\n      // `^^^` is forbidden and must be separated by a space.\n      const lookaheadCh = this.input.codePointAt(this.state.pos);\n      if (lookaheadCh === charCodes.caret) {\n        this.unexpected();\n      }\n    }\n    // '^'\n    else {\n      this.finishOp(tt.bitwiseXOR, 1);\n    }\n  }\n\n  readToken_atSign(): void {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    // '@@'\n    if (\n      next === charCodes.atSign &&\n      this.hasPlugin([\n        \"pipelineOperator\",\n        { proposal: \"hack\", topicToken: \"@@\" },\n      ])\n    ) {\n      this.finishOp(tt.doubleAt, 2);\n    }\n    // '@'\n    else {\n      this.finishOp(tt.at, 1);\n    }\n  }\n\n  readToken_plus_min(code: number): void {\n    // '+-'\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === code) {\n      this.finishOp(tt.incDec, 2);\n      return;\n    }\n\n    if (next === charCodes.equalsTo) {\n      this.finishOp(tt.assign, 2);\n    } else {\n      this.finishOp(tt.plusMin, 1);\n    }\n  }\n\n  readToken_lt(): void {\n    // '<'\n    const { pos } = this.state;\n    const next = this.input.charCodeAt(pos + 1);\n\n    if (next === charCodes.lessThan) {\n      if (this.input.charCodeAt(pos + 2) === charCodes.equalsTo) {\n        this.finishOp(tt.assign, 3);\n        return;\n      }\n      this.finishOp(tt.bitShiftL, 2);\n      return;\n    }\n\n    if (next === charCodes.equalsTo) {\n      // <=\n      this.finishOp(tt.relational, 2);\n      return;\n    }\n\n    this.finishOp(tt.lt, 1);\n  }\n\n  readToken_gt(): void {\n    // '>'\n    const { pos } = this.state;\n    const next = this.input.charCodeAt(pos + 1);\n\n    if (next === charCodes.greaterThan) {\n      const size =\n        this.input.charCodeAt(pos + 2) === charCodes.greaterThan ? 3 : 2;\n      if (this.input.charCodeAt(pos + size) === charCodes.equalsTo) {\n        this.finishOp(tt.assign, size + 1);\n        return;\n      }\n      this.finishOp(tt.bitShiftR, size);\n      return;\n    }\n\n    if (next === charCodes.equalsTo) {\n      // <= | >=\n      this.finishOp(tt.relational, 2);\n      return;\n    }\n\n    this.finishOp(tt.gt, 1);\n  }\n\n  readToken_eq_excl(code: number): void {\n    // '=!'\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === charCodes.equalsTo) {\n      this.finishOp(\n        tt.equality,\n        this.input.charCodeAt(this.state.pos + 2) === charCodes.equalsTo\n          ? 3\n          : 2,\n      );\n      return;\n    }\n    if (code === charCodes.equalsTo && next === charCodes.greaterThan) {\n      // '=>'\n      this.state.pos += 2;\n      this.finishToken(tt.arrow);\n      return;\n    }\n    this.finishOp(code === charCodes.equalsTo ? tt.eq : tt.bang, 1);\n  }\n\n  readToken_question(): void {\n    // '?'\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    const next2 = this.input.charCodeAt(this.state.pos + 2);\n    if (next === charCodes.questionMark) {\n      if (next2 === charCodes.equalsTo) {\n        // '??='\n        this.finishOp(tt.assign, 3);\n      } else {\n        // '??'\n        this.finishOp(tt.nullishCoalescing, 2);\n      }\n    } else if (\n      next === charCodes.dot &&\n      !(next2 >= charCodes.digit0 && next2 <= charCodes.digit9)\n    ) {\n      // '.' not followed by a number\n      this.state.pos += 2;\n      this.finishToken(tt.questionDot);\n    } else {\n      ++this.state.pos;\n      this.finishToken(tt.question);\n    }\n  }\n\n  getTokenFromCode(code: number): void {\n    switch (code) {\n      // The interpretation of a dot depends on whether it is followed\n      // by a digit or another two dots.\n\n      case charCodes.dot:\n        this.readToken_dot();\n        return;\n      // Punctuation tokens.\n      case charCodes.leftParenthesis:\n        ++this.state.pos;\n        this.finishToken(tt.parenL);\n        return;\n      case charCodes.rightParenthesis:\n        ++this.state.pos;\n        this.finishToken(tt.parenR);\n        return;\n      case charCodes.semicolon:\n        ++this.state.pos;\n        this.finishToken(tt.semi);\n        return;\n      case charCodes.comma:\n        ++this.state.pos;\n        this.finishToken(tt.comma);\n        return;\n      case charCodes.leftSquareBracket:\n        if (\n          !process.env.BABEL_8_BREAKING &&\n          this.hasPlugin(\"recordAndTuple\") &&\n          this.input.charCodeAt(this.state.pos + 1) === charCodes.verticalBar\n        ) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(\n              Errors.TupleExpressionBarIncorrectStartSyntaxType,\n              this.state.curPosition(),\n            );\n          }\n\n          // [|\n          this.state.pos += 2;\n          this.finishToken(tt.bracketBarL);\n        } else {\n          ++this.state.pos;\n          this.finishToken(tt.bracketL);\n        }\n        return;\n      case charCodes.rightSquareBracket:\n        ++this.state.pos;\n        this.finishToken(tt.bracketR);\n        return;\n      case charCodes.leftCurlyBrace:\n        if (\n          !process.env.BABEL_8_BREAKING &&\n          this.hasPlugin(\"recordAndTuple\") &&\n          this.input.charCodeAt(this.state.pos + 1) === charCodes.verticalBar\n        ) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(\n              Errors.RecordExpressionBarIncorrectStartSyntaxType,\n              this.state.curPosition(),\n            );\n          }\n\n          // {|\n          this.state.pos += 2;\n          this.finishToken(tt.braceBarL);\n        } else {\n          ++this.state.pos;\n          this.finishToken(tt.braceL);\n        }\n        return;\n      case charCodes.rightCurlyBrace:\n        ++this.state.pos;\n        this.finishToken(tt.braceR);\n        return;\n\n      case charCodes.colon:\n        if (\n          this.hasPlugin(\"functionBind\") &&\n          this.input.charCodeAt(this.state.pos + 1) === charCodes.colon\n        ) {\n          this.finishOp(tt.doubleColon, 2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(tt.colon);\n        }\n        return;\n\n      case charCodes.questionMark:\n        this.readToken_question();\n        return;\n\n      case charCodes.graveAccent:\n        this.readTemplateToken();\n        return;\n\n      case charCodes.digit0: {\n        const next = this.input.charCodeAt(this.state.pos + 1);\n        // '0x', '0X' - hex number\n        if (next === charCodes.lowercaseX || next === charCodes.uppercaseX) {\n          this.readRadixNumber(16);\n          return;\n        }\n        // '0o', '0O' - octal number\n        if (next === charCodes.lowercaseO || next === charCodes.uppercaseO) {\n          this.readRadixNumber(8);\n          return;\n        }\n        // '0b', '0B' - binary number\n        if (next === charCodes.lowercaseB || next === charCodes.uppercaseB) {\n          this.readRadixNumber(2);\n          return;\n        }\n      }\n      // Anything else beginning with a digit is an integer, octal\n      // number, or float. (fall through)\n      case charCodes.digit1:\n      case charCodes.digit2:\n      case charCodes.digit3:\n      case charCodes.digit4:\n      case charCodes.digit5:\n      case charCodes.digit6:\n      case charCodes.digit7:\n      case charCodes.digit8:\n      case charCodes.digit9:\n        this.readNumber(false);\n        return;\n\n      // Quotes produce strings.\n      case charCodes.quotationMark:\n      case charCodes.apostrophe:\n        this.readString(code);\n        return;\n\n      // Operators are parsed inline in tiny state machines. '=' (charCodes.equalsTo) is\n      // often referred to. `finishOp` simply skips the amount of\n      // characters it is given as second argument, and returns a token\n      // of the type given by its first argument.\n\n      case charCodes.slash:\n        this.readToken_slash();\n        return;\n\n      case charCodes.percentSign:\n      case charCodes.asterisk:\n        this.readToken_mult_modulo(code);\n        return;\n\n      case charCodes.verticalBar:\n      case charCodes.ampersand:\n        this.readToken_pipe_amp(code);\n        return;\n\n      case charCodes.caret:\n        this.readToken_caret();\n        return;\n\n      case charCodes.plusSign:\n      case charCodes.dash:\n        this.readToken_plus_min(code);\n        return;\n\n      case charCodes.lessThan:\n        this.readToken_lt();\n        return;\n\n      case charCodes.greaterThan:\n        this.readToken_gt();\n        return;\n\n      case charCodes.equalsTo:\n      case charCodes.exclamationMark:\n        this.readToken_eq_excl(code);\n        return;\n\n      case charCodes.tilde:\n        this.finishOp(tt.tilde, 1);\n        return;\n\n      case charCodes.atSign:\n        this.readToken_atSign();\n        return;\n\n      case charCodes.numberSign:\n        this.readToken_numberSign();\n        return;\n\n      case charCodes.backslash:\n        this.readWord();\n        return;\n\n      default:\n        if (isIdentifierStart(code)) {\n          this.readWord(code);\n          return;\n        }\n    }\n\n    throw this.raise(\n      Errors.InvalidOrUnexpectedToken,\n      this.state.curPosition(),\n      {\n        unexpected: String.fromCodePoint(code),\n      },\n    );\n  }\n\n  finishOp(type: TokenType, size: number): void {\n    const str = this.input.slice(this.state.pos, this.state.pos + size);\n    this.state.pos += size;\n    this.finishToken(type, str);\n  }\n\n  readRegexp(): void {\n    const startLoc = this.state.startLoc;\n    const start = this.state.start + 1;\n    let escaped, inClass;\n    let { pos } = this.state;\n    for (; ; ++pos) {\n      if (pos >= this.length) {\n        // FIXME: explain\n        throw this.raise(\n          Errors.UnterminatedRegExp,\n          createPositionWithColumnOffset(startLoc, 1),\n        );\n      }\n      const ch = this.input.charCodeAt(pos);\n      if (isNewLine(ch)) {\n        throw this.raise(\n          Errors.UnterminatedRegExp,\n          createPositionWithColumnOffset(startLoc, 1),\n        );\n      }\n      if (escaped) {\n        escaped = false;\n      } else {\n        if (ch === charCodes.leftSquareBracket) {\n          inClass = true;\n        } else if (ch === charCodes.rightSquareBracket && inClass) {\n          inClass = false;\n        } else if (ch === charCodes.slash && !inClass) {\n          break;\n        }\n        escaped = ch === charCodes.backslash;\n      }\n    }\n    const content = this.input.slice(start, pos);\n    ++pos;\n\n    let mods = \"\";\n\n    const nextPos = () =>\n      // (pos + 1) + 1 - start\n      createPositionWithColumnOffset(startLoc, pos + 2 - start);\n\n    while (pos < this.length) {\n      const cp = this.codePointAtPos(pos);\n      // It doesn't matter if cp > 0xffff, the loop will either throw or break because we check on cp\n      const char = String.fromCharCode(cp);\n\n      // @ts-expect-error VALID_REGEX_FLAGS.has should accept expanded type: number\n      if (VALID_REGEX_FLAGS.has(cp)) {\n        if (cp === charCodes.lowercaseV) {\n          if (mods.includes(\"u\")) {\n            this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());\n          }\n        } else if (cp === charCodes.lowercaseU) {\n          if (mods.includes(\"v\")) {\n            this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());\n          }\n        }\n        if (mods.includes(char)) {\n          this.raise(Errors.DuplicateRegExpFlags, nextPos());\n        }\n      } else if (isIdentifierChar(cp) || cp === charCodes.backslash) {\n        this.raise(Errors.MalformedRegExpFlags, nextPos());\n      } else {\n        break;\n      }\n\n      ++pos;\n      mods += char;\n    }\n    this.state.pos = pos;\n\n    this.finishToken(tt.regexp, {\n      pattern: content,\n      flags: mods,\n    });\n  }\n\n  // Read an integer in the given radix. Return null if zero digits\n  // were read, the integer value otherwise. When `len` is given, this\n  // will return `null` unless the integer has exactly `len` digits.\n  // When `forceLen` is `true`, it means that we already know that in case\n  // of a malformed number we have to skip `len` characters anyway, instead\n  // of bailing out early. For example, in \"\\u{123Z}\" we want to read up to }\n  // anyway, while in \"\\u00Z\" we will stop at Z instead of consuming four\n  // characters (and thus the closing quote).\n\n  readInt(\n    radix: number,\n    len?: number,\n    forceLen: boolean = false,\n    allowNumSeparator: boolean | \"bail\" = true,\n  ): number | null {\n    const { n, pos } = readInt(\n      this.input,\n      this.state.pos,\n      this.state.lineStart,\n      this.state.curLine,\n      radix,\n      len,\n      forceLen,\n      allowNumSeparator,\n      this.errorHandlers_readInt,\n      /* bailOnError */ false,\n    );\n    this.state.pos = pos;\n    return n;\n  }\n\n  readRadixNumber(radix: number): void {\n    const start = this.state.pos;\n    const startLoc = this.state.curPosition();\n    let isBigInt = false;\n\n    this.state.pos += 2; // 0x\n    const val = this.readInt(radix);\n    if (val == null) {\n      this.raise(\n        Errors.InvalidDigit,\n        // Numeric literals can't have newlines, so this is safe to do.\n        createPositionWithColumnOffset(startLoc, 2),\n        {\n          radix,\n        },\n      );\n    }\n    const next = this.input.charCodeAt(this.state.pos);\n\n    if (next === charCodes.lowercaseN) {\n      ++this.state.pos;\n      isBigInt = true;\n    } else if (next === charCodes.lowercaseM) {\n      throw this.raise(Errors.InvalidDecimal, startLoc);\n    }\n\n    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {\n      throw this.raise(Errors.NumberIdentifier, this.state.curPosition());\n    }\n\n    if (isBigInt) {\n      const str = this.input.slice(start, this.state.pos).replace(/[_n]/g, \"\");\n      this.finishToken(tt.bigint, str);\n      return;\n    }\n\n    this.finishToken(tt.num, val);\n  }\n\n  // Read an integer, octal integer, or floating-point number.\n\n  readNumber(startsWithDot: boolean): void {\n    const start = this.state.pos;\n    const startLoc = this.state.curPosition();\n    let isFloat = false;\n    let isBigInt = false;\n    let hasExponent = false;\n    let isOctal = false;\n\n    if (!startsWithDot && this.readInt(10) === null) {\n      this.raise(Errors.InvalidNumber, this.state.curPosition());\n    }\n    const hasLeadingZero =\n      this.state.pos - start >= 2 &&\n      this.input.charCodeAt(start) === charCodes.digit0;\n\n    if (hasLeadingZero) {\n      const integer = this.input.slice(start, this.state.pos);\n      this.recordStrictModeErrors(Errors.StrictOctalLiteral, startLoc);\n      if (!this.state.strict) {\n        // disallow numeric separators in non octal decimals and legacy octal likes\n        const underscorePos = integer.indexOf(\"_\");\n        if (underscorePos > 0) {\n          // Numeric literals can't have newlines, so this is safe to do.\n          this.raise(\n            Errors.ZeroDigitNumericSeparator,\n            createPositionWithColumnOffset(startLoc, underscorePos),\n          );\n        }\n      }\n      isOctal = hasLeadingZero && !/[89]/.test(integer);\n    }\n\n    let next = this.input.charCodeAt(this.state.pos);\n    if (next === charCodes.dot && !isOctal) {\n      ++this.state.pos;\n      this.readInt(10);\n      isFloat = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n\n    if (\n      (next === charCodes.uppercaseE || next === charCodes.lowercaseE) &&\n      !isOctal\n    ) {\n      next = this.input.charCodeAt(++this.state.pos);\n      if (next === charCodes.plusSign || next === charCodes.dash) {\n        ++this.state.pos;\n      }\n      if (this.readInt(10) === null) {\n        this.raise(Errors.InvalidOrMissingExponent, startLoc);\n      }\n      isFloat = true;\n      hasExponent = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n\n    if (next === charCodes.lowercaseN) {\n      // disallow floats, legacy octal syntax and non octal decimals\n      // new style octal (\"0o\") is handled in this.readRadixNumber\n      if (isFloat || hasLeadingZero) {\n        this.raise(Errors.InvalidBigIntLiteral, startLoc);\n      }\n      ++this.state.pos;\n      isBigInt = true;\n    }\n\n    if (!process.env.BABEL_8_BREAKING && next === charCodes.lowercaseM) {\n      this.expectPlugin(\"decimal\", this.state.curPosition());\n      if (hasExponent || hasLeadingZero) {\n        this.raise(Errors.InvalidDecimal, startLoc);\n      }\n      ++this.state.pos;\n      // eslint-disable-next-line no-var\n      var isDecimal = true;\n    }\n\n    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {\n      throw this.raise(Errors.NumberIdentifier, this.state.curPosition());\n    }\n\n    // remove \"_\" for numeric literal separator, and trailing `m` or `n`\n    const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, \"\");\n\n    if (isBigInt) {\n      this.finishToken(tt.bigint, str);\n      return;\n    }\n\n    if (!process.env.BABEL_8_BREAKING && isDecimal) {\n      this.finishToken(tt.decimal, str);\n      return;\n    }\n\n    const val = isOctal ? parseInt(str, 8) : parseFloat(str);\n    this.finishToken(tt.num, val);\n  }\n\n  // Read a string value, interpreting backslash-escapes.\n\n  readCodePoint(throwOnInvalid: boolean): number | null {\n    const { code, pos } = readCodePoint(\n      this.input,\n      this.state.pos,\n      this.state.lineStart,\n      this.state.curLine,\n      throwOnInvalid,\n      this.errorHandlers_readCodePoint,\n    );\n    this.state.pos = pos;\n    return code;\n  }\n\n  readString(quote: number): void {\n    const { str, pos, curLine, lineStart } = readStringContents(\n      quote === charCodes.quotationMark ? \"double\" : \"single\",\n      this.input,\n      this.state.pos + 1, // skip the quote\n      this.state.lineStart,\n      this.state.curLine,\n      this.errorHandlers_readStringContents_string,\n    );\n    this.state.pos = pos + 1; // skip the quote\n    this.state.lineStart = lineStart;\n    this.state.curLine = curLine;\n    this.finishToken(tt.string, str);\n  }\n\n  // Reads template continuation `}...`\n  readTemplateContinuation(): void {\n    if (!this.match(tt.braceR)) {\n      this.unexpected(null, tt.braceR);\n    }\n    // rewind pos to `}`\n    this.state.pos--;\n    this.readTemplateToken();\n  }\n\n  // Reads template string tokens.\n  readTemplateToken(): void {\n    const opening = this.input[this.state.pos];\n    const { str, firstInvalidLoc, pos, curLine, lineStart } =\n      readStringContents(\n        \"template\",\n        this.input,\n        this.state.pos + 1, // skip '`' or `}`\n        this.state.lineStart,\n        this.state.curLine,\n        this.errorHandlers_readStringContents_template,\n      );\n    this.state.pos = pos + 1; // skip '`' or `$`\n    this.state.lineStart = lineStart;\n    this.state.curLine = curLine;\n\n    if (firstInvalidLoc) {\n      this.state.firstInvalidTemplateEscapePos = new Position(\n        firstInvalidLoc.curLine,\n        firstInvalidLoc.pos - firstInvalidLoc.lineStart,\n        this.sourceToOffsetPos(firstInvalidLoc.pos),\n      );\n    }\n\n    if (this.input.codePointAt(pos) === charCodes.graveAccent) {\n      this.finishToken(\n        tt.templateTail,\n        firstInvalidLoc ? null : opening + str + \"`\",\n      );\n    } else {\n      this.state.pos++; // skip '{'\n      this.finishToken(\n        tt.templateNonTail,\n        firstInvalidLoc ? null : opening + str + \"${\",\n      );\n    }\n  }\n\n  recordStrictModeErrors(toParseError: DeferredStrictError, at: Position) {\n    const index = at.index;\n\n    if (this.state.strict && !this.state.strictErrors.has(index)) {\n      this.raise(toParseError, at);\n    } else {\n      this.state.strictErrors.set(index, [toParseError, at]);\n    }\n  }\n\n  // Read an identifier, and return it as a string. Sets `this.state.containsEsc`\n  // to whether the word contained a '\\u' escape.\n  //\n  // Incrementally adds only escaped chars, adding other chunks as-is\n  // as a micro-optimization.\n  //\n  // When `firstCode` is given, it assumes it is always an identifier start and\n  // will skip reading start position again\n\n  readWord1(firstCode?: number): string {\n    this.state.containsEsc = false;\n    let word = \"\";\n    const start = this.state.pos;\n    let chunkStart = this.state.pos;\n    if (firstCode !== undefined) {\n      this.state.pos += firstCode <= 0xffff ? 1 : 2;\n    }\n\n    while (this.state.pos < this.length) {\n      const ch = this.codePointAtPos(this.state.pos);\n      if (isIdentifierChar(ch)) {\n        this.state.pos += ch <= 0xffff ? 1 : 2;\n      } else if (ch === charCodes.backslash) {\n        this.state.containsEsc = true;\n\n        word += this.input.slice(chunkStart, this.state.pos);\n        const escStart = this.state.curPosition();\n        const identifierCheck =\n          this.state.pos === start ? isIdentifierStart : isIdentifierChar;\n\n        if (this.input.charCodeAt(++this.state.pos) !== charCodes.lowercaseU) {\n          this.raise(Errors.MissingUnicodeEscape, this.state.curPosition());\n          chunkStart = this.state.pos - 1;\n          continue;\n        }\n\n        ++this.state.pos;\n        const esc = this.readCodePoint(true);\n        if (esc !== null) {\n          if (!identifierCheck(esc)) {\n            this.raise(Errors.EscapedCharNotAnIdentifier, escStart);\n          }\n\n          word += String.fromCodePoint(esc);\n        }\n        chunkStart = this.state.pos;\n      } else {\n        break;\n      }\n    }\n    return word + this.input.slice(chunkStart, this.state.pos);\n  }\n\n  // Read an identifier or keyword token. Will check for reserved\n  // words when necessary.\n\n  readWord(firstCode?: number): void {\n    const word = this.readWord1(firstCode);\n    const type = keywordTypes.get(word);\n    if (type !== undefined) {\n      // We don't use word as state.value here because word is a dynamic string\n      // while token label is a shared constant string\n      this.finishToken(type, tokenLabelName(type));\n    } else {\n      this.finishToken(tt.name, word);\n    }\n  }\n\n  checkKeywordEscapes(): void {\n    const { type } = this.state;\n    if (tokenIsKeyword(type) && this.state.containsEsc) {\n      this.raise(Errors.InvalidEscapedReservedWord, this.state.startLoc, {\n        reservedWord: tokenLabelName(type),\n      });\n    }\n  }\n\n  /**\n   * Raise a `ParseError` given the appropriate properties. If passed a\n   * `Position` for the `at` property, raises the `ParseError` at that location.\n   * Otherwise, if passed a `Node`, raises the `ParseError` at the start\n   * location of that `Node`.\n   *\n   * If `errorRecovery` is `true`, the error is pushed to the errors array and\n   * returned. If `errorRecovery` is `false`, the error is instead thrown.\n   *\n   * The return type is marked as `never` for simplicity, as error recovery\n   * will create types in an invalid AST shape.\n   */\n  raise<ErrorDetails = object>(\n    toParseError: ParseErrorConstructor<ErrorDetails>,\n    at: Position | Undone<Node>,\n    details: ErrorDetails = {} as ErrorDetails,\n  ): ParseError<ErrorDetails> {\n    const loc = at instanceof Position ? at : at.loc.start;\n    const error = toParseError(loc, details);\n\n    if (!(this.optionFlags & OptionFlags.ErrorRecovery)) throw error;\n    if (!this.isLookahead) this.state.errors.push(error);\n\n    return error;\n  }\n\n  /**\n   * If `errorRecovery` is `false`, this method behaves identically to `raise`.\n   * If `errorRecovery` is `true`, this method will first see if there is\n   * already an error stored at the same `Position`, and replaces it with the\n   * one generated here.\n   */\n  raiseOverwrite<ErrorDetails>(\n    toParseError: ParseErrorConstructor<ErrorDetails>,\n    at: Position | Undone<Node>,\n    details: ErrorDetails = {} as ErrorDetails,\n  ): ParseError<ErrorDetails> | never {\n    const loc = at instanceof Position ? at : at.loc.start;\n    const pos = loc.index;\n    const errors = this.state.errors;\n\n    for (let i = errors.length - 1; i >= 0; i--) {\n      const error = errors[i];\n      if (error.loc.index === pos) {\n        return (errors[i] = toParseError(loc, details));\n      }\n      if (error.loc.index < pos) break;\n    }\n\n    return this.raise(toParseError, at, details);\n  }\n\n  // updateContext is used by the jsx plugin\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  updateContext(prevType: TokenType): void {}\n\n  // Raise an unexpected token error. Can take the expected token type.\n  unexpected(loc?: Position | null, type?: TokenType): void {\n    throw this.raise(\n      Errors.UnexpectedToken,\n      loc != null ? loc : this.state.startLoc,\n      {\n        expected: type ? tokenLabelName(type) : null,\n      },\n    );\n  }\n\n  expectPlugin(pluginName: Plugin, loc?: Position): true {\n    if (this.hasPlugin(pluginName)) {\n      return true;\n    }\n\n    throw this.raise(\n      Errors.MissingPlugin,\n      loc != null ? loc : this.state.startLoc,\n      {\n        missingPlugin: [pluginName],\n      },\n    );\n  }\n\n  expectOnePlugin(pluginNames: Plugin[]): void {\n    if (!pluginNames.some(name => this.hasPlugin(name))) {\n      throw this.raise(Errors.MissingOneOfPlugins, this.state.startLoc, {\n        missingPlugin: pluginNames,\n      });\n    }\n  }\n\n  errorBuilder(error: ParseErrorConstructor<object>) {\n    return (pos: number, lineStart: number, curLine: number) => {\n      this.raise(error, buildPosition(pos, lineStart, curLine));\n    };\n  }\n\n  errorHandlers_readInt: IntErrorHandlers = {\n    invalidDigit: (pos, lineStart, curLine, radix) => {\n      if (!(this.optionFlags & OptionFlags.ErrorRecovery)) return false;\n\n      this.raise(Errors.InvalidDigit, buildPosition(pos, lineStart, curLine), {\n        radix,\n      });\n      // Continue parsing the number as if there was no invalid digit.\n      return true;\n    },\n    numericSeparatorInEscapeSequence: this.errorBuilder(\n      Errors.NumericSeparatorInEscapeSequence,\n    ),\n    unexpectedNumericSeparator: this.errorBuilder(\n      Errors.UnexpectedNumericSeparator,\n    ),\n  };\n\n  errorHandlers_readCodePoint: CodePointErrorHandlers = {\n    ...this.errorHandlers_readInt,\n    invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),\n    invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint),\n  };\n\n  errorHandlers_readStringContents_string: StringContentsErrorHandlers = {\n    ...this.errorHandlers_readCodePoint,\n    strictNumericEscape: (pos, lineStart, curLine) => {\n      this.recordStrictModeErrors(\n        Errors.StrictNumericEscape,\n        buildPosition(pos, lineStart, curLine),\n      );\n    },\n    unterminated: (pos, lineStart, curLine) => {\n      throw this.raise(\n        Errors.UnterminatedString, // Report the error at the string quote\n        buildPosition(pos - 1, lineStart, curLine),\n      );\n    },\n  };\n\n  errorHandlers_readStringContents_template: StringContentsErrorHandlers = {\n    ...this.errorHandlers_readCodePoint,\n    strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),\n    unterminated: (pos, lineStart, curLine) => {\n      throw this.raise(\n        Errors.UnterminatedTemplate,\n        buildPosition(pos, lineStart, curLine),\n      );\n    },\n  };\n}\n"],"mappings":";;;;;;AAEA,IAAAA,QAAA,GAAAC,OAAA;AACA,IAAAC,SAAA,GAAAD,OAAA;AAKA,IAAAE,SAAA,GAAAF,OAAA;AAGA,IAAAG,WAAA,GAAAH,OAAA;AACA,IAAAI,MAAA,GAAAJ,OAAA;AAQA,IAAAK,WAAA,GAAAL,OAAA;AAKA,IAAAM,WAAA,GAAAN,OAAA;AAOA,IAAAO,MAAA,GAAAP,OAAA;AAKA,IAAAQ,mBAAA,GAAAR,OAAA;AAWA,SAASS,aAAaA,CAACC,GAAW,EAAEC,SAAiB,EAAEC,OAAe,EAAE;EACtE,OAAO,IAAIC,kBAAQ,CAACD,OAAO,EAAEF,GAAG,GAAGC,SAAS,EAAED,GAAG,CAAC;AACpD;AAEA,MAAMI,iBAAiB,GAAG,IAAIC,GAAG,CAAC,wCASjC,CAAC;AAMK,MAAMC,KAAK,CAAC;EACjBC,WAAWA,CAACC,KAAY,EAAE;IACxB,MAAMC,UAAU,GAAGD,KAAK,CAACC,UAAU,IAAI,CAAC;IACxC,IAAI,CAACC,IAAI,GAAGF,KAAK,CAACE,IAAI;IACtB,IAAI,CAACC,KAAK,GAAGH,KAAK,CAACG,KAAK;IACxB,IAAI,CAACC,KAAK,GAAGH,UAAU,GAAGD,KAAK,CAACI,KAAK;IACrC,IAAI,CAACC,GAAG,GAAGJ,UAAU,GAAGD,KAAK,CAACK,GAAG;IACjC,IAAI,CAACC,GAAG,GAAG,IAAIC,wBAAc,CAACP,KAAK,CAACQ,QAAQ,EAAER,KAAK,CAACS,MAAM,CAAC;EAC7D;AAOF;AAACC,OAAA,CAAAZ,KAAA,GAAAA,KAAA;AAIc,MAAea,SAAS,SAASC,iBAAc,CAAC;EAC7DC,WAAW;EAGXC,MAAM,GAA6B,EAAE;EAErCf,WAAWA,CAACgB,OAAgB,EAAEC,KAAa,EAAE;IAC3C,KAAK,CAAC,CAAC;IACP,IAAI,CAAChB,KAAK,GAAG,IAAIiB,cAAK,CAAC,CAAC;IACxB,IAAI,CAACjB,KAAK,CAACkB,IAAI,CAACH,OAAO,CAAC;IACxB,IAAI,CAACC,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACG,MAAM,GAAGH,KAAK,CAACG,MAAM;IAC1B,IAAI,CAACC,QAAQ,GAAG,EAAE;IAClB,IAAI,CAACP,WAAW,GAAG,KAAK;EAC1B;EAEAQ,SAASA,CAACC,KAAwB,EAAE;IAGlC,IAAI,CAACR,MAAM,CAACK,MAAM,GAAG,IAAI,CAACnB,KAAK,CAACuB,YAAY;IAC5C,IAAI,CAACT,MAAM,CAACU,IAAI,CAACF,KAAK,CAAC;IACvB,EAAE,IAAI,CAACtB,KAAK,CAACuB,YAAY;EAC3B;EAIAE,IAAIA,CAAA,EAAS;IACX,IAAI,CAACC,mBAAmB,CAAC,CAAC;IAC1B,IAAI,IAAI,CAACC,WAAW,GAAGC,oBAAW,CAACC,MAAM,EAAE;MACzC,IAAI,CAACR,SAAS,CAAC,IAAIvB,KAAK,CAAC,IAAI,CAACE,KAAK,CAAC,CAAC;IACvC;IAEA,IAAI,CAACA,KAAK,CAAC8B,aAAa,GAAG,IAAI,CAAC9B,KAAK,CAACS,MAAM;IAC5C,IAAI,CAACT,KAAK,CAAC+B,eAAe,GAAG,IAAI,CAAC/B,KAAK,CAACQ,QAAQ;IAChD,IAAI,CAACwB,SAAS,CAAC,CAAC;EAClB;EAEAC,GAAGA,CAAC/B,IAAe,EAAW;IAC5B,IAAI,IAAI,CAACgC,KAAK,CAAChC,IAAI,CAAC,EAAE;MACpB,IAAI,CAACuB,IAAI,CAAC,CAAC;MACX,OAAO,IAAI;IACb,CAAC,MAAM;MACL,OAAO,KAAK;IACd;EACF;EAKAS,KAAKA,CAAChC,IAAe,EAAW;IAC9B,OAAO,IAAI,CAACF,KAAK,CAACE,IAAI,KAAKA,IAAI;EACjC;EAKAiC,oBAAoBA,CAACnC,KAAY,EAAkB;IACjD,OAAO;MACLR,GAAG,EAAEQ,KAAK,CAACR,GAAG;MACdW,KAAK,EAAE,IAAI;MACXD,IAAI,EAAEF,KAAK,CAACE,IAAI;MAChBE,KAAK,EAAEJ,KAAK,CAACI,KAAK;MAClBC,GAAG,EAAEL,KAAK,CAACK,GAAG;MACd+B,OAAO,EAAE,CAAC,IAAI,CAACC,UAAU,CAAC,CAAC,CAAC;MAC5BC,MAAM,EAAEtC,KAAK,CAACsC,MAAM;MACpB9B,QAAQ,EAAER,KAAK,CAACQ,QAAQ;MACxBsB,aAAa,EAAE9B,KAAK,CAAC8B,aAAa;MAClCpC,OAAO,EAAEM,KAAK,CAACN,OAAO;MACtBD,SAAS,EAAEO,KAAK,CAACP,SAAS;MAC1B8C,WAAW,EAAEvC,KAAK,CAACuC;IACrB,CAAC;EACH;EAeAC,SAASA,CAAA,EAAmB;IAC1B,MAAMC,GAAG,GAAG,IAAI,CAACzC,KAAK;IAEtB,IAAI,CAACA,KAAK,GAAG,IAAI,CAACmC,oBAAoB,CAACM,GAAG,CAAC;IAE3C,IAAI,CAAC5B,WAAW,GAAG,IAAI;IACvB,IAAI,CAACmB,SAAS,CAAC,CAAC;IAChB,IAAI,CAACnB,WAAW,GAAG,KAAK;IAExB,MAAM6B,IAAI,GAAG,IAAI,CAAC1C,KAAK;IACvB,IAAI,CAACA,KAAK,GAAGyC,GAAG;IAChB,OAAOC,IAAI;EACb;EAEAC,cAAcA,CAAA,EAAW;IACvB,OAAO,IAAI,CAACC,mBAAmB,CAAC,IAAI,CAAC5C,KAAK,CAACR,GAAG,CAAC;EACjD;EAEAoD,mBAAmBA,CAACpD,GAAW,EAAU;IACvCqD,0BAAc,CAACC,SAAS,GAAGtD,GAAG;IAC9B,OAAOqD,0BAAc,CAACE,IAAI,CAAC,IAAI,CAAC/B,KAAK,CAAC,GAAG6B,0BAAc,CAACC,SAAS,GAAGtD,GAAG;EACzE;EAEAwD,iBAAiBA,CAAA,EAAW;IAC1B,OAAO,IAAI,CAAChC,KAAK,CAACiC,UAAU,CAAC,IAAI,CAACN,cAAc,CAAC,CAAC,CAAC;EACrD;EAQAO,oBAAoBA,CAAA,EAAW;IAC7B,OAAO,IAAI,CAACC,yBAAyB,CAAC,IAAI,CAACnD,KAAK,CAACR,GAAG,CAAC;EACvD;EAEA2D,yBAAyBA,CAAC3D,GAAW,EAAU;IAC7C4D,gCAAoB,CAACN,SAAS,GAAGtD,GAAG;IACpC,OAAO4D,gCAAoB,CAACL,IAAI,CAAC,IAAI,CAAC/B,KAAK,CAAC,GACxCoC,gCAAoB,CAACN,SAAS,GAC9BtD,GAAG;EACT;EASA6D,uBAAuBA,CAAA,EAAW;IAChC,OAAO,IAAI,CAACrC,KAAK,CAACiC,UAAU,CAAC,IAAI,CAACC,oBAAoB,CAAC,CAAC,CAAC;EAC3D;EAEAI,cAAcA,CAAC9D,GAAW,EAAU;IAKlC,IAAI+D,EAAE,GAAG,IAAI,CAACvC,KAAK,CAACiC,UAAU,CAACzD,GAAG,CAAC;IACnC,IAAI,CAAC+D,EAAE,GAAG,MAAM,MAAM,MAAM,IAAI,EAAE/D,GAAG,GAAG,IAAI,CAACwB,KAAK,CAACG,MAAM,EAAE;MACzD,MAAMqC,KAAK,GAAG,IAAI,CAACxC,KAAK,CAACiC,UAAU,CAACzD,GAAG,CAAC;MACxC,IAAI,CAACgE,KAAK,GAAG,MAAM,MAAM,MAAM,EAAE;QAC/BD,EAAE,GAAG,OAAO,IAAI,CAACA,EAAE,GAAG,KAAK,KAAK,EAAE,CAAC,IAAIC,KAAK,GAAG,KAAK,CAAC;MACvD;IACF;IACA,OAAOD,EAAE;EACX;EAKAE,SAASA,CAACC,MAAe,EAAQ;IAC/B,IAAI,CAAC1D,KAAK,CAAC0D,MAAM,GAAGA,MAAM;IAC1B,IAAIA,MAAM,EAAE;MAKV,IAAI,CAAC1D,KAAK,CAAC2D,YAAY,CAACC,OAAO,CAAC,CAAC,CAACC,YAAY,EAAEC,EAAE,CAAC,KACjD,IAAI,CAACC,KAAK,CAACF,YAAY,EAAEC,EAAE,CAC7B,CAAC;MACD,IAAI,CAAC9D,KAAK,CAAC2D,YAAY,CAACK,KAAK,CAAC,CAAC;IACjC;EACF;EAEA3B,UAAUA,CAAA,EAAe;IACvB,OAAO,IAAI,CAACrC,KAAK,CAACoC,OAAO,CAAC,IAAI,CAACpC,KAAK,CAACoC,OAAO,CAACjB,MAAM,GAAG,CAAC,CAAC;EAC1D;EAGAa,SAASA,CAAA,EAAS;IAChB,IAAI,CAACiC,SAAS,CAAC,CAAC;IAChB,IAAI,CAACjE,KAAK,CAACI,KAAK,GAAG,IAAI,CAACJ,KAAK,CAACR,GAAG;IACjC,IAAI,CAAC,IAAI,CAACqB,WAAW,EAAE,IAAI,CAACb,KAAK,CAACQ,QAAQ,GAAG,IAAI,CAACR,KAAK,CAACuC,WAAW,CAAC,CAAC;IACrE,IAAI,IAAI,CAACvC,KAAK,CAACR,GAAG,IAAI,IAAI,CAAC2B,MAAM,EAAE;MACjC,IAAI,CAAC+C,WAAW,IAAO,CAAC;MACxB;IACF;IAEA,IAAI,CAACC,gBAAgB,CAAC,IAAI,CAACb,cAAc,CAAC,IAAI,CAACtD,KAAK,CAACR,GAAG,CAAC,CAAC;EAC5D;EAKA4E,gBAAgBA,CAACC,UAAwB,EAA8B;IACrE,IAAI7D,QAAQ;IACZ,IAAI,CAAC,IAAI,CAACK,WAAW,EAAEL,QAAQ,GAAG,IAAI,CAACR,KAAK,CAACuC,WAAW,CAAC,CAAC;IAC1D,MAAMnC,KAAK,GAAG,IAAI,CAACJ,KAAK,CAACR,GAAG;IAC5B,MAAMa,GAAG,GAAG,IAAI,CAACW,KAAK,CAACsD,OAAO,CAACD,UAAU,EAAEjE,KAAK,GAAG,CAAC,CAAC;IACrD,IAAIC,GAAG,KAAK,CAAC,CAAC,EAAE;MAId,MAAM,IAAI,CAAC0D,KAAK,CAACQ,kBAAM,CAACC,mBAAmB,EAAE,IAAI,CAACxE,KAAK,CAACuC,WAAW,CAAC,CAAC,CAAC;IACxE;IAEA,IAAI,CAACvC,KAAK,CAACR,GAAG,GAAGa,GAAG,GAAGgE,UAAU,CAAClD,MAAM;IACxCsD,sBAAU,CAAC3B,SAAS,GAAG1C,KAAK,GAAG,CAAC;IAChC,OAAOqE,sBAAU,CAAC1B,IAAI,CAAC,IAAI,CAAC/B,KAAK,CAAC,IAAIyD,sBAAU,CAAC3B,SAAS,IAAIzC,GAAG,EAAE;MACjE,EAAE,IAAI,CAACL,KAAK,CAACN,OAAO;MACpB,IAAI,CAACM,KAAK,CAACP,SAAS,GAAGgF,sBAAU,CAAC3B,SAAS;IAC7C;IAIA,IAAI,IAAI,CAACjC,WAAW,EAAE;IAGtB,MAAM6D,OAAuB,GAAG;MAC9BxE,IAAI,EAAE,cAAc;MACpBC,KAAK,EAAE,IAAI,CAACa,KAAK,CAAC2D,KAAK,CAACvE,KAAK,GAAG,CAAC,EAAEC,GAAG,CAAC;MACvCD,KAAK,EAAE,IAAI,CAACwE,iBAAiB,CAACxE,KAAK,CAAC;MACpCC,GAAG,EAAE,IAAI,CAACuE,iBAAiB,CAACvE,GAAG,GAAGgE,UAAU,CAAClD,MAAM,CAAC;MACpDb,GAAG,EAAE,IAAIC,wBAAc,CAACC,QAAQ,EAAE,IAAI,CAACR,KAAK,CAACuC,WAAW,CAAC,CAAC;IAC5D,CAAC;IACD,IAAI,IAAI,CAACZ,WAAW,GAAGC,oBAAW,CAACC,MAAM,EAAE,IAAI,CAACR,SAAS,CAACqD,OAAO,CAAC;IAClE,OAAOA,OAAO;EAChB;EAEAG,eAAeA,CAACC,SAAiB,EAA6B;IAC5D,MAAM1E,KAAK,GAAG,IAAI,CAACJ,KAAK,CAACR,GAAG;IAC5B,IAAIgB,QAAQ;IACZ,IAAI,CAAC,IAAI,CAACK,WAAW,EAAEL,QAAQ,GAAG,IAAI,CAACR,KAAK,CAACuC,WAAW,CAAC,CAAC;IAC1D,IAAIwC,EAAE,GAAG,IAAI,CAAC/D,KAAK,CAACiC,UAAU,CAAE,IAAI,CAACjD,KAAK,CAACR,GAAG,IAAIsF,SAAU,CAAC;IAC7D,IAAI,IAAI,CAAC9E,KAAK,CAACR,GAAG,GAAG,IAAI,CAAC2B,MAAM,EAAE;MAChC,OAAO,CAAC,IAAA6D,qBAAS,EAACD,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC/E,KAAK,CAACR,GAAG,GAAG,IAAI,CAAC2B,MAAM,EAAE;QACvD4D,EAAE,GAAG,IAAI,CAAC/D,KAAK,CAACiC,UAAU,CAAC,IAAI,CAACjD,KAAK,CAACR,GAAG,CAAC;MAC5C;IACF;IAIA,IAAI,IAAI,CAACqB,WAAW,EAAE;IAEtB,MAAMR,GAAG,GAAG,IAAI,CAACL,KAAK,CAACR,GAAG;IAC1B,MAAMW,KAAK,GAAG,IAAI,CAACa,KAAK,CAAC2D,KAAK,CAACvE,KAAK,GAAG0E,SAAS,EAAEzE,GAAG,CAAC;IAEtD,MAAMqE,OAAsB,GAAG;MAC7BxE,IAAI,EAAE,aAAa;MACnBC,KAAK;MACLC,KAAK,EAAE,IAAI,CAACwE,iBAAiB,CAACxE,KAAK,CAAC;MACpCC,GAAG,EAAE,IAAI,CAACuE,iBAAiB,CAACvE,GAAG,CAAC;MAChCC,GAAG,EAAE,IAAIC,wBAAc,CAACC,QAAQ,EAAE,IAAI,CAACR,KAAK,CAACuC,WAAW,CAAC,CAAC;IAC5D,CAAC;IACD,IAAI,IAAI,CAACZ,WAAW,GAAGC,oBAAW,CAACC,MAAM,EAAE,IAAI,CAACR,SAAS,CAACqD,OAAO,CAAC;IAClE,OAAOA,OAAO;EAChB;EAKAT,SAASA,CAAA,EAAS;IAChB,MAAMgB,UAAU,GAAG,IAAI,CAACjF,KAAK,CAACR,GAAG;IACjC,MAAM4B,QAAqB,GACzB,IAAI,CAACO,WAAW,GAAGC,oBAAW,CAACsD,aAAa,GAAG,EAAE,GAAG,IAAI;IAC1DC,IAAI,EAAE,OAAO,IAAI,CAACnF,KAAK,CAACR,GAAG,GAAG,IAAI,CAAC2B,MAAM,EAAE;MACzC,MAAM4D,EAAE,GAAG,IAAI,CAAC/D,KAAK,CAACiC,UAAU,CAAC,IAAI,CAACjD,KAAK,CAACR,GAAG,CAAC;MAChD,QAAQuF,EAAE;QACR;QACA;QACA;UACE,EAAE,IAAI,CAAC/E,KAAK,CAACR,GAAG;UAChB;QACF;UACE,IACE,IAAI,CAACwB,KAAK,CAACiC,UAAU,CAAC,IAAI,CAACjD,KAAK,CAACR,GAAG,GAAG,CAAC,CAAC,OAAuB,EAChE;YACA,EAAE,IAAI,CAACQ,KAAK,CAACR,GAAG;UAClB;QAEF;QACA;QACA;UACE,EAAE,IAAI,CAACQ,KAAK,CAACR,GAAG;UAChB,EAAE,IAAI,CAACQ,KAAK,CAACN,OAAO;UACpB,IAAI,CAACM,KAAK,CAACP,SAAS,GAAG,IAAI,CAACO,KAAK,CAACR,GAAG;UACrC;QAEF;UACE,QAAQ,IAAI,CAACwB,KAAK,CAACiC,UAAU,CAAC,IAAI,CAACjD,KAAK,CAACR,GAAG,GAAG,CAAC,CAAC;YAC/C;cAAyB;gBACvB,MAAMkF,OAAO,GAAG,IAAI,CAACN,gBAAgB,CAAC,IAAI,CAAC;gBAC3C,IAAIM,OAAO,KAAKU,SAAS,EAAE;kBACzB,IAAI,CAACC,UAAU,CAACX,OAAO,CAAC;kBACxBtD,QAAQ,EAAEI,IAAI,CAACkD,OAAO,CAAC;gBACzB;gBACA;cACF;YAEA;cAAsB;gBACpB,MAAMA,OAAO,GAAG,IAAI,CAACG,eAAe,CAAC,CAAC,CAAC;gBACvC,IAAIH,OAAO,KAAKU,SAAS,EAAE;kBACzB,IAAI,CAACC,UAAU,CAACX,OAAO,CAAC;kBACxBtD,QAAQ,EAAEI,IAAI,CAACkD,OAAO,CAAC;gBACzB;gBACA;cACF;YAEA;cACE,MAAMS,IAAI;UACd;UACA;QAEF;UACE,IAAI,IAAAG,wBAAY,EAACP,EAAE,CAAC,EAAE;YACpB,EAAE,IAAI,CAAC/E,KAAK,CAACR,GAAG;UAClB,CAAC,MAAM,IACLuF,EAAE,OAAmB,IACrB,CAAC,IAAI,CAACQ,QAAQ,IACd,IAAI,CAAC5D,WAAW,GAAGC,oBAAW,CAAC4D,MAAM,EACrC;YACA,MAAMhG,GAAG,GAAG,IAAI,CAACQ,KAAK,CAACR,GAAG;YAC1B,IACE,IAAI,CAACwB,KAAK,CAACiC,UAAU,CAACzD,GAAG,GAAG,CAAC,CAAC,OAAmB,IACjD,IAAI,CAACwB,KAAK,CAACiC,UAAU,CAACzD,GAAG,GAAG,CAAC,CAAC,OAA0B,KACvDyF,UAAU,KAAK,CAAC,IAAI,IAAI,CAACjF,KAAK,CAACP,SAAS,GAAGwF,UAAU,CAAC,EACvD;cAEA,MAAMP,OAAO,GAAG,IAAI,CAACG,eAAe,CAAC,CAAC,CAAC;cACvC,IAAIH,OAAO,KAAKU,SAAS,EAAE;gBACzB,IAAI,CAACC,UAAU,CAACX,OAAO,CAAC;gBACxBtD,QAAQ,EAAEI,IAAI,CAACkD,OAAO,CAAC;cACzB;YACF,CAAC,MAAM;cACL,MAAMS,IAAI;YACZ;UACF,CAAC,MAAM,IACLJ,EAAE,OAAuB,IACzB,CAAC,IAAI,CAACQ,QAAQ,IACd,IAAI,CAAC5D,WAAW,GAAGC,oBAAW,CAAC4D,MAAM,EACrC;YACA,MAAMhG,GAAG,GAAG,IAAI,CAACQ,KAAK,CAACR,GAAG;YAC1B,IACE,IAAI,CAACwB,KAAK,CAACiC,UAAU,CAACzD,GAAG,GAAG,CAAC,CAAC,OAA8B,IAC5D,IAAI,CAACwB,KAAK,CAACiC,UAAU,CAACzD,GAAG,GAAG,CAAC,CAAC,OAAmB,IACjD,IAAI,CAACwB,KAAK,CAACiC,UAAU,CAACzD,GAAG,GAAG,CAAC,CAAC,OAAmB,EACjD;cAEA,MAAMkF,OAAO,GAAG,IAAI,CAACG,eAAe,CAAC,CAAC,CAAC;cACvC,IAAIH,OAAO,KAAKU,SAAS,EAAE;gBACzB,IAAI,CAACC,UAAU,CAACX,OAAO,CAAC;gBACxBtD,QAAQ,EAAEI,IAAI,CAACkD,OAAO,CAAC;cACzB;YACF,CAAC,MAAM;cACL,MAAMS,IAAI;YACZ;UACF,CAAC,MAAM;YACL,MAAMA,IAAI;UACZ;MACJ;IACF;IAEA,IAAI/D,QAAQ,EAAED,MAAM,GAAG,CAAC,EAAE;MACxB,MAAMd,GAAG,GAAG,IAAI,CAACL,KAAK,CAACR,GAAG;MAC1B,MAAMiG,iBAAoC,GAAG;QAC3CrF,KAAK,EAAE,IAAI,CAACwE,iBAAiB,CAACK,UAAU,CAAC;QACzC5E,GAAG,EAAE,IAAI,CAACuE,iBAAiB,CAACvE,GAAG,CAAC;QAChCe,QAAQ;QACRsE,WAAW,EAAE,IAAI;QACjBC,YAAY,EAAE,IAAI;QAClBC,cAAc,EAAE;MAClB,CAAC;MACD,IAAI,CAAC5F,KAAK,CAAC6F,YAAY,CAACrE,IAAI,CAACiE,iBAAiB,CAAC;IACjD;EACF;EAOAvB,WAAWA,CAAChE,IAAe,EAAE4F,GAAS,EAAQ;IAC5C,IAAI,CAAC9F,KAAK,CAACK,GAAG,GAAG,IAAI,CAACL,KAAK,CAACR,GAAG;IAC/B,IAAI,CAACQ,KAAK,CAACS,MAAM,GAAG,IAAI,CAACT,KAAK,CAACuC,WAAW,CAAC,CAAC;IAC5C,MAAMwD,QAAQ,GAAG,IAAI,CAAC/F,KAAK,CAACE,IAAI;IAChC,IAAI,CAACF,KAAK,CAACE,IAAI,GAAGA,IAAI;IACtB,IAAI,CAACF,KAAK,CAACG,KAAK,GAAG2F,GAAG;IAEtB,IAAI,CAAC,IAAI,CAACjF,WAAW,EAAE;MACrB,IAAI,CAACmF,aAAa,CAACD,QAAQ,CAAC;IAC9B;EACF;EAEAE,YAAYA,CAAC/F,IAAe,EAAQ;IAClC,IAAI,CAACF,KAAK,CAACE,IAAI,GAAGA,IAAI;IAGtB,IAAI,CAAC8F,aAAa,CAAC,CAAC;EACtB;EAYAE,oBAAoBA,CAAA,EAAS;IAC3B,IAAI,IAAI,CAAClG,KAAK,CAACR,GAAG,KAAK,CAAC,IAAI,IAAI,CAAC2G,qBAAqB,CAAC,CAAC,EAAE;MACxD;IACF;IAEA,MAAMC,OAAO,GAAG,IAAI,CAACpG,KAAK,CAACR,GAAG,GAAG,CAAC;IAClC,MAAMiC,IAAI,GAAG,IAAI,CAAC6B,cAAc,CAAC8C,OAAO,CAAC;IACzC,IAAI3E,IAAI,MAAoB,IAAIA,IAAI,MAAoB,EAAE;MACxD,MAAM,IAAI,CAACsC,KAAK,CACdQ,kBAAM,CAAC8B,wBAAwB,EAC/B,IAAI,CAACrG,KAAK,CAACuC,WAAW,CAAC,CACzB,CAAC;IACH;IAEA,IACEd,IAAI,QAA6B,IAChCA,IAAI,OAAgC,IAAI,IAAI,CAAC6E,SAAS,CAAC,gBAAgB,CAAE,EAC1E;MAKA,IAAI,CAACC,YAAY,CAAC,gBAAgB,CAAC;MACnC,IACE,CAACC,OAAO,CAACC,GAAG,CAACC,gBAAgB,IAC7B,IAAI,CAACC,eAAe,CAAC,gBAAgB,EAAE,YAAY,CAAC,KAAK,KAAK,EAC9D;QACA,MAAM,IAAI,CAAC5C,KAAK,CACdtC,IAAI,QAA6B,GAC7B8C,kBAAM,CAACqC,4CAA4C,GACnDrC,kBAAM,CAACsC,2CAA2C,EACtD,IAAI,CAAC7G,KAAK,CAACuC,WAAW,CAAC,CACzB,CAAC;MACH;MAEA,IAAI,CAACvC,KAAK,CAACR,GAAG,IAAI,CAAC;MACnB,IAAIiC,IAAI,QAA6B,EAAE;QAErC,IAAI,CAACyC,WAAW,EAAc,CAAC;MACjC,CAAC,MAAM;QAEL,IAAI,CAACA,WAAW,EAAgB,CAAC;MACnC;IACF,CAAC,MAAM,IAAI,IAAA4C,6BAAiB,EAACrF,IAAI,CAAC,EAAE;MAClC,EAAE,IAAI,CAACzB,KAAK,CAACR,GAAG;MAChB,IAAI,CAAC0E,WAAW,MAAiB,IAAI,CAAC6C,SAAS,CAACtF,IAAI,CAAC,CAAC;IACxD,CAAC,MAAM,IAAIA,IAAI,OAAwB,EAAE;MACvC,EAAE,IAAI,CAACzB,KAAK,CAACR,GAAG;MAChB,IAAI,CAAC0E,WAAW,MAAiB,IAAI,CAAC6C,SAAS,CAAC,CAAC,CAAC;IACpD,CAAC,MAAM;MACL,IAAI,CAACC,QAAQ,KAAU,CAAC,CAAC;IAC3B;EACF;EAEAC,aAAaA,CAAA,EAAS;IACpB,MAAMxF,IAAI,GAAG,IAAI,CAACT,KAAK,CAACiC,UAAU,CAAC,IAAI,CAACjD,KAAK,CAACR,GAAG,GAAG,CAAC,CAAC;IACtD,IAAIiC,IAAI,MAAoB,IAAIA,IAAI,MAAoB,EAAE;MACxD,IAAI,CAACyF,UAAU,CAAC,IAAI,CAAC;MACrB;IACF;IAEA,IACEzF,IAAI,OAAkB,IACtB,IAAI,CAACT,KAAK,CAACiC,UAAU,CAAC,IAAI,CAACjD,KAAK,CAACR,GAAG,GAAG,CAAC,CAAC,OAAkB,EAC3D;MACA,IAAI,CAACQ,KAAK,CAACR,GAAG,IAAI,CAAC;MACnB,IAAI,CAAC0E,WAAW,GAAY,CAAC;IAC/B,CAAC,MAAM;MACL,EAAE,IAAI,CAAClE,KAAK,CAACR,GAAG;MAChB,IAAI,CAAC0E,WAAW,GAAO,CAAC;IAC1B;EACF;EAEAiD,eAAeA,CAAA,EAAS;IACtB,MAAM1F,IAAI,GAAG,IAAI,CAACT,KAAK,CAACiC,UAAU,CAAC,IAAI,CAACjD,KAAK,CAACR,GAAG,GAAG,CAAC,CAAC;IACtD,IAAIiC,IAAI,OAAuB,EAAE;MAC/B,IAAI,CAACuF,QAAQ,KAAiB,CAAC,CAAC;IAClC,CAAC,MAAM;MACL,IAAI,CAACA,QAAQ,KAAW,CAAC,CAAC;IAC5B;EACF;EAEAb,qBAAqBA,CAAA,EAAY;IAC/B,IAAI,IAAI,CAACnG,KAAK,CAACR,GAAG,KAAK,CAAC,IAAI,IAAI,CAAC2B,MAAM,GAAG,CAAC,EAAE,OAAO,KAAK;IAEzD,IAAI4D,EAAE,GAAG,IAAI,CAAC/D,KAAK,CAACiC,UAAU,CAAC,IAAI,CAACjD,KAAK,CAACR,GAAG,GAAG,CAAC,CAAC;IAClD,IAAIuF,EAAE,OAA8B,EAAE,OAAO,KAAK;IAElD,MAAM3E,KAAK,GAAG,IAAI,CAACJ,KAAK,CAACR,GAAG;IAC5B,IAAI,CAACQ,KAAK,CAACR,GAAG,IAAI,CAAC;IAEnB,OAAO,CAAC,IAAAwF,qBAAS,EAACD,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC/E,KAAK,CAACR,GAAG,GAAG,IAAI,CAAC2B,MAAM,EAAE;MACvD4D,EAAE,GAAG,IAAI,CAAC/D,KAAK,CAACiC,UAAU,CAAC,IAAI,CAACjD,KAAK,CAACR,GAAG,CAAC;IAC5C;IAEA,MAAMW,KAAK,GAAG,IAAI,CAACa,KAAK,CAAC2D,KAAK,CAACvE,KAAK,GAAG,CAAC,EAAE,IAAI,CAACJ,KAAK,CAACR,GAAG,CAAC;IAEzD,IAAI,CAAC0E,WAAW,KAA0B/D,KAAK,CAAC;IAEhD,OAAO,IAAI;EACb;EAEAiH,qBAAqBA,CAACC,IAAY,EAAQ;IAExC,IAAInH,IAAI,GAAGmH,IAAI,OAAuB,UAAsB;IAC5D,IAAIC,KAAK,GAAG,CAAC;IACb,IAAI7F,IAAI,GAAG,IAAI,CAACT,KAAK,CAACiC,UAAU,CAAC,IAAI,CAACjD,KAAK,CAACR,GAAG,GAAG,CAAC,CAAC;IAGpD,IAAI6H,IAAI,OAAuB,IAAI5F,IAAI,OAAuB,EAAE;MAC9D6F,KAAK,EAAE;MACP7F,IAAI,GAAG,IAAI,CAACT,KAAK,CAACiC,UAAU,CAAC,IAAI,CAACjD,KAAK,CAACR,GAAG,GAAG,CAAC,CAAC;MAChDU,IAAI,KAAc;IACpB;IAGA,IAAIuB,IAAI,OAAuB,IAAI,CAAC,IAAI,CAACzB,KAAK,CAACsC,MAAM,EAAE;MACrDgF,KAAK,EAAE;MAIPpH,IAAI,GAAGmH,IAAI,OAA0B,UAA8B;IACrE;IAEA,IAAI,CAACL,QAAQ,CAAC9G,IAAI,EAAEoH,KAAK,CAAC;EAC5B;EAEAC,kBAAkBA,CAACF,IAAY,EAAQ;IAErC,MAAM5F,IAAI,GAAG,IAAI,CAACT,KAAK,CAACiC,UAAU,CAAC,IAAI,CAACjD,KAAK,CAACR,GAAG,GAAG,CAAC,CAAC;IAEtD,IAAIiC,IAAI,KAAK4F,IAAI,EAAE;MACjB,IAAI,IAAI,CAACrG,KAAK,CAACiC,UAAU,CAAC,IAAI,CAACjD,KAAK,CAACR,GAAG,GAAG,CAAC,CAAC,OAAuB,EAAE;QACpE,IAAI,CAACwH,QAAQ,KAAY,CAAC,CAAC;MAC7B,CAAC,MAAM;QACL,IAAI,CAACA,QAAQ,CACXK,IAAI,QAA0B,UAA+B,EAC7D,CACF,CAAC;MACH;MACA;IACF;IAEA,IAAIA,IAAI,QAA0B,EAAE;MAElC,IAAI5F,IAAI,OAA0B,EAAE;QAClC,IAAI,CAACuF,QAAQ,KAAc,CAAC,CAAC;QAC7B;MACF;MAEA,IACE,CAACR,OAAO,CAACC,GAAG,CAACC,gBAAgB,IAC7B,IAAI,CAACJ,SAAS,CAAC,gBAAgB,CAAC,IAChC7E,IAAI,QAA8B,EAClC;QACA,IAAI,IAAI,CAACkF,eAAe,CAAC,gBAAgB,EAAE,YAAY,CAAC,KAAK,KAAK,EAAE;UAClE,MAAM,IAAI,CAAC5C,KAAK,CACdQ,kBAAM,CAACiD,yCAAyC,EAChD,IAAI,CAACxH,KAAK,CAACuC,WAAW,CAAC,CACzB,CAAC;QACH;QACA,IAAI,CAACvC,KAAK,CAACR,GAAG,IAAI,CAAC;QACnB,IAAI,CAAC0E,WAAW,EAAa,CAAC;QAC9B;MACF;MAGA,IACE,CAACsC,OAAO,CAACC,GAAG,CAACC,gBAAgB,IAC7B,IAAI,CAACJ,SAAS,CAAC,gBAAgB,CAAC,IAChC7E,IAAI,OAAiC,EACrC;QACA,IAAI,IAAI,CAACkF,eAAe,CAAC,gBAAgB,EAAE,YAAY,CAAC,KAAK,KAAK,EAAE;UAClE,MAAM,IAAI,CAAC5C,KAAK,CACdQ,kBAAM,CAACkD,wCAAwC,EAC/C,IAAI,CAACzH,KAAK,CAACuC,WAAW,CAAC,CACzB,CAAC;QACH;QACA,IAAI,CAACvC,KAAK,CAACR,GAAG,IAAI,CAAC;QACnB,IAAI,CAAC0E,WAAW,EAAe,CAAC;QAChC;MACF;IACF;IAEA,IAAIzC,IAAI,OAAuB,EAAE;MAC/B,IAAI,CAACuF,QAAQ,KAAY,CAAC,CAAC;MAC3B;IACF;IAEA,IAAI,CAACA,QAAQ,CACXK,IAAI,QAA0B,UAA+B,EAC7D,CACF,CAAC;EACH;EAEAK,eAAeA,CAAA,EAAS;IACtB,MAAMjG,IAAI,GAAG,IAAI,CAACT,KAAK,CAACiC,UAAU,CAAC,IAAI,CAACjD,KAAK,CAACR,GAAG,GAAG,CAAC,CAAC;IAGtD,IAAIiC,IAAI,OAAuB,IAAI,CAAC,IAAI,CAACzB,KAAK,CAACsC,MAAM,EAAE;MAIrD,IAAI,CAAC0E,QAAQ,KAAe,CAAC,CAAC;IAChC,CAAC,MAEI,IACHvF,IAAI,OAAoB,IAGxB,IAAI,CAAC6E,SAAS,CAAC,CACb,kBAAkB,EAClB;MAAEqB,QAAQ,EAAE,MAAM;MAAEC,UAAU,EAAE;IAAK,CAAC,CACvC,CAAC,EACF;MACA,IAAI,CAACZ,QAAQ,KAAiB,CAAC,CAAC;MAGhC,MAAMa,WAAW,GAAG,IAAI,CAAC7G,KAAK,CAAC8G,WAAW,CAAC,IAAI,CAAC9H,KAAK,CAACR,GAAG,CAAC;MAC1D,IAAIqI,WAAW,OAAoB,EAAE;QACnC,IAAI,CAACE,UAAU,CAAC,CAAC;MACnB;IACF,CAAC,MAEI;MACH,IAAI,CAACf,QAAQ,KAAgB,CAAC,CAAC;IACjC;EACF;EAEAgB,gBAAgBA,CAAA,EAAS;IACvB,MAAMvG,IAAI,GAAG,IAAI,CAACT,KAAK,CAACiC,UAAU,CAAC,IAAI,CAACjD,KAAK,CAACR,GAAG,GAAG,CAAC,CAAC;IAGtD,IACEiC,IAAI,OAAqB,IACzB,IAAI,CAAC6E,SAAS,CAAC,CACb,kBAAkB,EAClB;MAAEqB,QAAQ,EAAE,MAAM;MAAEC,UAAU,EAAE;IAAK,CAAC,CACvC,CAAC,EACF;MACA,IAAI,CAACZ,QAAQ,KAAc,CAAC,CAAC;IAC/B,CAAC,MAEI;MACH,IAAI,CAACA,QAAQ,KAAQ,CAAC,CAAC;IACzB;EACF;EAEAiB,kBAAkBA,CAACZ,IAAY,EAAQ;IAErC,MAAM5F,IAAI,GAAG,IAAI,CAACT,KAAK,CAACiC,UAAU,CAAC,IAAI,CAACjD,KAAK,CAACR,GAAG,GAAG,CAAC,CAAC;IAEtD,IAAIiC,IAAI,KAAK4F,IAAI,EAAE;MACjB,IAAI,CAACL,QAAQ,KAAY,CAAC,CAAC;MAC3B;IACF;IAEA,IAAIvF,IAAI,OAAuB,EAAE;MAC/B,IAAI,CAACuF,QAAQ,KAAY,CAAC,CAAC;IAC7B,CAAC,MAAM;MACL,IAAI,CAACA,QAAQ,KAAa,CAAC,CAAC;IAC9B;EACF;EAEAkB,YAAYA,CAAA,EAAS;IAEnB,MAAM;MAAE1I;IAAI,CAAC,GAAG,IAAI,CAACQ,KAAK;IAC1B,MAAMyB,IAAI,GAAG,IAAI,CAACT,KAAK,CAACiC,UAAU,CAACzD,GAAG,GAAG,CAAC,CAAC;IAE3C,IAAIiC,IAAI,OAAuB,EAAE;MAC/B,IAAI,IAAI,CAACT,KAAK,CAACiC,UAAU,CAACzD,GAAG,GAAG,CAAC,CAAC,OAAuB,EAAE;QACzD,IAAI,CAACwH,QAAQ,KAAY,CAAC,CAAC;QAC3B;MACF;MACA,IAAI,CAACA,QAAQ,KAAe,CAAC,CAAC;MAC9B;IACF;IAEA,IAAIvF,IAAI,OAAuB,EAAE;MAE/B,IAAI,CAACuF,QAAQ,KAAgB,CAAC,CAAC;MAC/B;IACF;IAEA,IAAI,CAACA,QAAQ,KAAQ,CAAC,CAAC;EACzB;EAEAmB,YAAYA,CAAA,EAAS;IAEnB,MAAM;MAAE3I;IAAI,CAAC,GAAG,IAAI,CAACQ,KAAK;IAC1B,MAAMyB,IAAI,GAAG,IAAI,CAACT,KAAK,CAACiC,UAAU,CAACzD,GAAG,GAAG,CAAC,CAAC;IAE3C,IAAIiC,IAAI,OAA0B,EAAE;MAClC,MAAM2G,IAAI,GACR,IAAI,CAACpH,KAAK,CAACiC,UAAU,CAACzD,GAAG,GAAG,CAAC,CAAC,OAA0B,GAAG,CAAC,GAAG,CAAC;MAClE,IAAI,IAAI,CAACwB,KAAK,CAACiC,UAAU,CAACzD,GAAG,GAAG4I,IAAI,CAAC,OAAuB,EAAE;QAC5D,IAAI,CAACpB,QAAQ,KAAYoB,IAAI,GAAG,CAAC,CAAC;QAClC;MACF;MACA,IAAI,CAACpB,QAAQ,KAAeoB,IAAI,CAAC;MACjC;IACF;IAEA,IAAI3G,IAAI,OAAuB,EAAE;MAE/B,IAAI,CAACuF,QAAQ,KAAgB,CAAC,CAAC;MAC/B;IACF;IAEA,IAAI,CAACA,QAAQ,KAAQ,CAAC,CAAC;EACzB;EAEAqB,iBAAiBA,CAAChB,IAAY,EAAQ;IAEpC,MAAM5F,IAAI,GAAG,IAAI,CAACT,KAAK,CAACiC,UAAU,CAAC,IAAI,CAACjD,KAAK,CAACR,GAAG,GAAG,CAAC,CAAC;IACtD,IAAIiC,IAAI,OAAuB,EAAE;MAC/B,IAAI,CAACuF,QAAQ,KAEX,IAAI,CAAChG,KAAK,CAACiC,UAAU,CAAC,IAAI,CAACjD,KAAK,CAACR,GAAG,GAAG,CAAC,CAAC,OAAuB,GAC5D,CAAC,GACD,CACN,CAAC;MACD;IACF;IACA,IAAI6H,IAAI,OAAuB,IAAI5F,IAAI,OAA0B,EAAE;MAEjE,IAAI,CAACzB,KAAK,CAACR,GAAG,IAAI,CAAC;MACnB,IAAI,CAAC0E,WAAW,GAAS,CAAC;MAC1B;IACF;IACA,IAAI,CAAC8C,QAAQ,CAACK,IAAI,OAAuB,UAAkB,EAAE,CAAC,CAAC;EACjE;EAEAiB,kBAAkBA,CAAA,EAAS;IAEzB,MAAM7G,IAAI,GAAG,IAAI,CAACT,KAAK,CAACiC,UAAU,CAAC,IAAI,CAACjD,KAAK,CAACR,GAAG,GAAG,CAAC,CAAC;IACtD,MAAM+I,KAAK,GAAG,IAAI,CAACvH,KAAK,CAACiC,UAAU,CAAC,IAAI,CAACjD,KAAK,CAACR,GAAG,GAAG,CAAC,CAAC;IACvD,IAAIiC,IAAI,OAA2B,EAAE;MACnC,IAAI8G,KAAK,OAAuB,EAAE;QAEhC,IAAI,CAACvB,QAAQ,KAAY,CAAC,CAAC;MAC7B,CAAC,MAAM;QAEL,IAAI,CAACA,QAAQ,KAAuB,CAAC,CAAC;MACxC;IACF,CAAC,MAAM,IACLvF,IAAI,OAAkB,IACtB,EAAE8G,KAAK,MAAoB,IAAIA,KAAK,MAAoB,CAAC,EACzD;MAEA,IAAI,CAACvI,KAAK,CAACR,GAAG,IAAI,CAAC;MACnB,IAAI,CAAC0E,WAAW,GAAe,CAAC;IAClC,CAAC,MAAM;MACL,EAAE,IAAI,CAAClE,KAAK,CAACR,GAAG;MAChB,IAAI,CAAC0E,WAAW,GAAY,CAAC;IAC/B;EACF;EAEAC,gBAAgBA,CAACkD,IAAY,EAAQ;IACnC,QAAQA,IAAI;MAIV;QACE,IAAI,CAACJ,aAAa,CAAC,CAAC;QACpB;MAEF;QACE,EAAE,IAAI,CAACjH,KAAK,CAACR,GAAG;QAChB,IAAI,CAAC0E,WAAW,GAAU,CAAC;QAC3B;MACF;QACE,EAAE,IAAI,CAAClE,KAAK,CAACR,GAAG;QAChB,IAAI,CAAC0E,WAAW,GAAU,CAAC;QAC3B;MACF;QACE,EAAE,IAAI,CAAClE,KAAK,CAACR,GAAG;QAChB,IAAI,CAAC0E,WAAW,GAAQ,CAAC;QACzB;MACF;QACE,EAAE,IAAI,CAAClE,KAAK,CAACR,GAAG;QAChB,IAAI,CAAC0E,WAAW,GAAS,CAAC;QAC1B;MACF;QACE,IACE,CAACsC,OAAO,CAACC,GAAG,CAACC,gBAAgB,IAC7B,IAAI,CAACJ,SAAS,CAAC,gBAAgB,CAAC,IAChC,IAAI,CAACtF,KAAK,CAACiC,UAAU,CAAC,IAAI,CAACjD,KAAK,CAACR,GAAG,GAAG,CAAC,CAAC,QAA0B,EACnE;UACA,IAAI,IAAI,CAACmH,eAAe,CAAC,gBAAgB,EAAE,YAAY,CAAC,KAAK,KAAK,EAAE;YAClE,MAAM,IAAI,CAAC5C,KAAK,CACdQ,kBAAM,CAACiE,0CAA0C,EACjD,IAAI,CAACxI,KAAK,CAACuC,WAAW,CAAC,CACzB,CAAC;UACH;UAGA,IAAI,CAACvC,KAAK,CAACR,GAAG,IAAI,CAAC;UACnB,IAAI,CAAC0E,WAAW,EAAe,CAAC;QAClC,CAAC,MAAM;UACL,EAAE,IAAI,CAAClE,KAAK,CAACR,GAAG;UAChB,IAAI,CAAC0E,WAAW,EAAY,CAAC;QAC/B;QACA;MACF;QACE,EAAE,IAAI,CAAClE,KAAK,CAACR,GAAG;QAChB,IAAI,CAAC0E,WAAW,EAAY,CAAC;QAC7B;MACF;QACE,IACE,CAACsC,OAAO,CAACC,GAAG,CAACC,gBAAgB,IAC7B,IAAI,CAACJ,SAAS,CAAC,gBAAgB,CAAC,IAChC,IAAI,CAACtF,KAAK,CAACiC,UAAU,CAAC,IAAI,CAACjD,KAAK,CAACR,GAAG,GAAG,CAAC,CAAC,QAA0B,EACnE;UACA,IAAI,IAAI,CAACmH,eAAe,CAAC,gBAAgB,EAAE,YAAY,CAAC,KAAK,KAAK,EAAE;YAClE,MAAM,IAAI,CAAC5C,KAAK,CACdQ,kBAAM,CAACkE,2CAA2C,EAClD,IAAI,CAACzI,KAAK,CAACuC,WAAW,CAAC,CACzB,CAAC;UACH;UAGA,IAAI,CAACvC,KAAK,CAACR,GAAG,IAAI,CAAC;UACnB,IAAI,CAAC0E,WAAW,EAAa,CAAC;QAChC,CAAC,MAAM;UACL,EAAE,IAAI,CAAClE,KAAK,CAACR,GAAG;UAChB,IAAI,CAAC0E,WAAW,EAAU,CAAC;QAC7B;QACA;MACF;QACE,EAAE,IAAI,CAAClE,KAAK,CAACR,GAAG;QAChB,IAAI,CAAC0E,WAAW,EAAU,CAAC;QAC3B;MAEF;QACE,IACE,IAAI,CAACoC,SAAS,CAAC,cAAc,CAAC,IAC9B,IAAI,CAACtF,KAAK,CAACiC,UAAU,CAAC,IAAI,CAACjD,KAAK,CAACR,GAAG,GAAG,CAAC,CAAC,OAAoB,EAC7D;UACA,IAAI,CAACwH,QAAQ,KAAiB,CAAC,CAAC;QAClC,CAAC,MAAM;UACL,EAAE,IAAI,CAAChH,KAAK,CAACR,GAAG;UAChB,IAAI,CAAC0E,WAAW,GAAS,CAAC;QAC5B;QACA;MAEF;QACE,IAAI,CAACoE,kBAAkB,CAAC,CAAC;QACzB;MAEF;QACE,IAAI,CAACI,iBAAiB,CAAC,CAAC;QACxB;MAEF;QAAuB;UACrB,MAAMjH,IAAI,GAAG,IAAI,CAACT,KAAK,CAACiC,UAAU,CAAC,IAAI,CAACjD,KAAK,CAACR,GAAG,GAAG,CAAC,CAAC;UAEtD,IAAIiC,IAAI,QAAyB,IAAIA,IAAI,OAAyB,EAAE;YAClE,IAAI,CAACkH,eAAe,CAAC,EAAE,CAAC;YACxB;UACF;UAEA,IAAIlH,IAAI,QAAyB,IAAIA,IAAI,OAAyB,EAAE;YAClE,IAAI,CAACkH,eAAe,CAAC,CAAC,CAAC;YACvB;UACF;UAEA,IAAIlH,IAAI,OAAyB,IAAIA,IAAI,OAAyB,EAAE;YAClE,IAAI,CAACkH,eAAe,CAAC,CAAC,CAAC;YACvB;UACF;QACF;MAGA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;QACE,IAAI,CAACzB,UAAU,CAAC,KAAK,CAAC;QACtB;MAGF;MACA;QACE,IAAI,CAAC0B,UAAU,CAACvB,IAAI,CAAC;QACrB;MAOF;QACE,IAAI,CAACF,eAAe,CAAC,CAAC;QACtB;MAEF;MACA;QACE,IAAI,CAACC,qBAAqB,CAACC,IAAI,CAAC;QAChC;MAEF;MACA;QACE,IAAI,CAACE,kBAAkB,CAACF,IAAI,CAAC;QAC7B;MAEF;QACE,IAAI,CAACK,eAAe,CAAC,CAAC;QACtB;MAEF;MACA;QACE,IAAI,CAACO,kBAAkB,CAACZ,IAAI,CAAC;QAC7B;MAEF;QACE,IAAI,CAACa,YAAY,CAAC,CAAC;QACnB;MAEF;QACE,IAAI,CAACC,YAAY,CAAC,CAAC;QACnB;MAEF;MACA;QACE,IAAI,CAACE,iBAAiB,CAAChB,IAAI,CAAC;QAC5B;MAEF;QACE,IAAI,CAACL,QAAQ,KAAW,CAAC,CAAC;QAC1B;MAEF;QACE,IAAI,CAACgB,gBAAgB,CAAC,CAAC;QACvB;MAEF;QACE,IAAI,CAAC9B,oBAAoB,CAAC,CAAC;QAC3B;MAEF;QACE,IAAI,CAAC2C,QAAQ,CAAC,CAAC;QACf;MAEF;QACE,IAAI,IAAA/B,6BAAiB,EAACO,IAAI,CAAC,EAAE;UAC3B,IAAI,CAACwB,QAAQ,CAACxB,IAAI,CAAC;UACnB;QACF;IACJ;IAEA,MAAM,IAAI,CAACtD,KAAK,CACdQ,kBAAM,CAACuE,wBAAwB,EAC/B,IAAI,CAAC9I,KAAK,CAACuC,WAAW,CAAC,CAAC,EACxB;MACEwF,UAAU,EAAEgB,MAAM,CAACC,aAAa,CAAC3B,IAAI;IACvC,CACF,CAAC;EACH;EAEAL,QAAQA,CAAC9G,IAAe,EAAEkI,IAAY,EAAQ;IAC5C,MAAMa,GAAG,GAAG,IAAI,CAACjI,KAAK,CAAC2D,KAAK,CAAC,IAAI,CAAC3E,KAAK,CAACR,GAAG,EAAE,IAAI,CAACQ,KAAK,CAACR,GAAG,GAAG4I,IAAI,CAAC;IACnE,IAAI,CAACpI,KAAK,CAACR,GAAG,IAAI4I,IAAI;IACtB,IAAI,CAAClE,WAAW,CAAChE,IAAI,EAAE+I,GAAG,CAAC;EAC7B;EAEAC,UAAUA,CAAA,EAAS;IACjB,MAAM1I,QAAQ,GAAG,IAAI,CAACR,KAAK,CAACQ,QAAQ;IACpC,MAAMJ,KAAK,GAAG,IAAI,CAACJ,KAAK,CAACI,KAAK,GAAG,CAAC;IAClC,IAAI+I,OAAO,EAAEC,OAAO;IACpB,IAAI;MAAE5J;IAAI,CAAC,GAAG,IAAI,CAACQ,KAAK;IACxB,QAAS,EAAER,GAAG,EAAE;MACd,IAAIA,GAAG,IAAI,IAAI,CAAC2B,MAAM,EAAE;QAEtB,MAAM,IAAI,CAAC4C,KAAK,CACdQ,kBAAM,CAAC8E,kBAAkB,EACzB,IAAAC,wCAA8B,EAAC9I,QAAQ,EAAE,CAAC,CAC5C,CAAC;MACH;MACA,MAAMuE,EAAE,GAAG,IAAI,CAAC/D,KAAK,CAACiC,UAAU,CAACzD,GAAG,CAAC;MACrC,IAAI,IAAAwF,qBAAS,EAACD,EAAE,CAAC,EAAE;QACjB,MAAM,IAAI,CAAChB,KAAK,CACdQ,kBAAM,CAAC8E,kBAAkB,EACzB,IAAAC,wCAA8B,EAAC9I,QAAQ,EAAE,CAAC,CAC5C,CAAC;MACH;MACA,IAAI2I,OAAO,EAAE;QACXA,OAAO,GAAG,KAAK;MACjB,CAAC,MAAM;QACL,IAAIpE,EAAE,OAAgC,EAAE;UACtCqE,OAAO,GAAG,IAAI;QAChB,CAAC,MAAM,IAAIrE,EAAE,OAAiC,IAAIqE,OAAO,EAAE;UACzDA,OAAO,GAAG,KAAK;QACjB,CAAC,MAAM,IAAIrE,EAAE,OAAoB,IAAI,CAACqE,OAAO,EAAE;UAC7C;QACF;QACAD,OAAO,GAAGpE,EAAE,OAAwB;MACtC;IACF;IACA,MAAMwE,OAAO,GAAG,IAAI,CAACvI,KAAK,CAAC2D,KAAK,CAACvE,KAAK,EAAEZ,GAAG,CAAC;IAC5C,EAAEA,GAAG;IAEL,IAAIgK,IAAI,GAAG,EAAE;IAEb,MAAMpD,OAAO,GAAGA,CAAA,KAEd,IAAAkD,wCAA8B,EAAC9I,QAAQ,EAAEhB,GAAG,GAAG,CAAC,GAAGY,KAAK,CAAC;IAE3D,OAAOZ,GAAG,GAAG,IAAI,CAAC2B,MAAM,EAAE;MACxB,MAAMoC,EAAE,GAAG,IAAI,CAACD,cAAc,CAAC9D,GAAG,CAAC;MAEnC,MAAMiK,IAAI,GAAGV,MAAM,CAACW,YAAY,CAACnG,EAAE,CAAC;MAGpC,IAAI3D,iBAAiB,CAAC+J,GAAG,CAACpG,EAAE,CAAC,EAAE;QAC7B,IAAIA,EAAE,QAAyB,EAAE;UAC/B,IAAIiG,IAAI,CAACI,QAAQ,CAAC,GAAG,CAAC,EAAE;YACtB,IAAI,CAAC7F,KAAK,CAACQ,kBAAM,CAACsF,yBAAyB,EAAEzD,OAAO,CAAC,CAAC,CAAC;UACzD;QACF,CAAC,MAAM,IAAI7C,EAAE,QAAyB,EAAE;UACtC,IAAIiG,IAAI,CAACI,QAAQ,CAAC,GAAG,CAAC,EAAE;YACtB,IAAI,CAAC7F,KAAK,CAACQ,kBAAM,CAACsF,yBAAyB,EAAEzD,OAAO,CAAC,CAAC,CAAC;UACzD;QACF;QACA,IAAIoD,IAAI,CAACI,QAAQ,CAACH,IAAI,CAAC,EAAE;UACvB,IAAI,CAAC1F,KAAK,CAACQ,kBAAM,CAACuF,oBAAoB,EAAE1D,OAAO,CAAC,CAAC,CAAC;QACpD;MACF,CAAC,MAAM,IAAI,IAAA2D,4BAAgB,EAACxG,EAAE,CAAC,IAAIA,EAAE,OAAwB,EAAE;QAC7D,IAAI,CAACQ,KAAK,CAACQ,kBAAM,CAACyF,oBAAoB,EAAE5D,OAAO,CAAC,CAAC,CAAC;MACpD,CAAC,MAAM;QACL;MACF;MAEA,EAAE5G,GAAG;MACLgK,IAAI,IAAIC,IAAI;IACd;IACA,IAAI,CAACzJ,KAAK,CAACR,GAAG,GAAGA,GAAG;IAEpB,IAAI,CAAC0E,WAAW,MAAY;MAC1B+F,OAAO,EAAEV,OAAO;MAChBW,KAAK,EAAEV;IACT,CAAC,CAAC;EACJ;EAWAW,OAAOA,CACLC,KAAa,EACbC,GAAY,EACZC,QAAiB,GAAG,KAAK,EACzBC,iBAAmC,GAAG,IAAI,EAC3B;IACf,MAAM;MAAEC,CAAC;MAAEhL;IAAI,CAAC,GAAG,IAAA2K,2BAAO,EACxB,IAAI,CAACnJ,KAAK,EACV,IAAI,CAAChB,KAAK,CAACR,GAAG,EACd,IAAI,CAACQ,KAAK,CAACP,SAAS,EACpB,IAAI,CAACO,KAAK,CAACN,OAAO,EAClB0K,KAAK,EACLC,GAAG,EACHC,QAAQ,EACRC,iBAAiB,EACjB,IAAI,CAACE,qBAAqB,EACR,KACpB,CAAC;IACD,IAAI,CAACzK,KAAK,CAACR,GAAG,GAAGA,GAAG;IACpB,OAAOgL,CAAC;EACV;EAEA7B,eAAeA,CAACyB,KAAa,EAAQ;IACnC,MAAMhK,KAAK,GAAG,IAAI,CAACJ,KAAK,CAACR,GAAG;IAC5B,MAAMgB,QAAQ,GAAG,IAAI,CAACR,KAAK,CAACuC,WAAW,CAAC,CAAC;IACzC,IAAImI,QAAQ,GAAG,KAAK;IAEpB,IAAI,CAAC1K,KAAK,CAACR,GAAG,IAAI,CAAC;IACnB,MAAMsG,GAAG,GAAG,IAAI,CAACqE,OAAO,CAACC,KAAK,CAAC;IAC/B,IAAItE,GAAG,IAAI,IAAI,EAAE;MACf,IAAI,CAAC/B,KAAK,CACRQ,kBAAM,CAACoG,YAAY,EAEnB,IAAArB,wCAA8B,EAAC9I,QAAQ,EAAE,CAAC,CAAC,EAC3C;QACE4J;MACF,CACF,CAAC;IACH;IACA,MAAM3I,IAAI,GAAG,IAAI,CAACT,KAAK,CAACiC,UAAU,CAAC,IAAI,CAACjD,KAAK,CAACR,GAAG,CAAC;IAElD,IAAIiC,IAAI,QAAyB,EAAE;MACjC,EAAE,IAAI,CAACzB,KAAK,CAACR,GAAG;MAChBkL,QAAQ,GAAG,IAAI;IACjB,CAAC,MAAM,IAAIjJ,IAAI,QAAyB,EAAE;MACxC,MAAM,IAAI,CAACsC,KAAK,CAACQ,kBAAM,CAACqG,cAAc,EAAEpK,QAAQ,CAAC;IACnD;IAEA,IAAI,IAAAsG,6BAAiB,EAAC,IAAI,CAACxD,cAAc,CAAC,IAAI,CAACtD,KAAK,CAACR,GAAG,CAAC,CAAC,EAAE;MAC1D,MAAM,IAAI,CAACuE,KAAK,CAACQ,kBAAM,CAACsG,gBAAgB,EAAE,IAAI,CAAC7K,KAAK,CAACuC,WAAW,CAAC,CAAC,CAAC;IACrE;IAEA,IAAImI,QAAQ,EAAE;MACZ,MAAMzB,GAAG,GAAG,IAAI,CAACjI,KAAK,CAAC2D,KAAK,CAACvE,KAAK,EAAE,IAAI,CAACJ,KAAK,CAACR,GAAG,CAAC,CAACsL,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC;MACxE,IAAI,CAAC5G,WAAW,MAAY+E,GAAG,CAAC;MAChC;IACF;IAEA,IAAI,CAAC/E,WAAW,MAAS4B,GAAG,CAAC;EAC/B;EAIAoB,UAAUA,CAAC6D,aAAsB,EAAQ;IACvC,MAAM3K,KAAK,GAAG,IAAI,CAACJ,KAAK,CAACR,GAAG;IAC5B,MAAMgB,QAAQ,GAAG,IAAI,CAACR,KAAK,CAACuC,WAAW,CAAC,CAAC;IACzC,IAAIyI,OAAO,GAAG,KAAK;IACnB,IAAIN,QAAQ,GAAG,KAAK;IACpB,IAAIO,WAAW,GAAG,KAAK;IACvB,IAAIC,OAAO,GAAG,KAAK;IAEnB,IAAI,CAACH,aAAa,IAAI,IAAI,CAACZ,OAAO,CAAC,EAAE,CAAC,KAAK,IAAI,EAAE;MAC/C,IAAI,CAACpG,KAAK,CAACQ,kBAAM,CAAC4G,aAAa,EAAE,IAAI,CAACnL,KAAK,CAACuC,WAAW,CAAC,CAAC,CAAC;IAC5D;IACA,MAAM6I,cAAc,GAClB,IAAI,CAACpL,KAAK,CAACR,GAAG,GAAGY,KAAK,IAAI,CAAC,IAC3B,IAAI,CAACY,KAAK,CAACiC,UAAU,CAAC7C,KAAK,CAAC,OAAqB;IAEnD,IAAIgL,cAAc,EAAE;MAClB,MAAMC,OAAO,GAAG,IAAI,CAACrK,KAAK,CAAC2D,KAAK,CAACvE,KAAK,EAAE,IAAI,CAACJ,KAAK,CAACR,GAAG,CAAC;MACvD,IAAI,CAAC8L,sBAAsB,CAAC/G,kBAAM,CAACgH,kBAAkB,EAAE/K,QAAQ,CAAC;MAChE,IAAI,CAAC,IAAI,CAACR,KAAK,CAAC0D,MAAM,EAAE;QAEtB,MAAM8H,aAAa,GAAGH,OAAO,CAAC/G,OAAO,CAAC,GAAG,CAAC;QAC1C,IAAIkH,aAAa,GAAG,CAAC,EAAE;UAErB,IAAI,CAACzH,KAAK,CACRQ,kBAAM,CAACkH,yBAAyB,EAChC,IAAAnC,wCAA8B,EAAC9I,QAAQ,EAAEgL,aAAa,CACxD,CAAC;QACH;MACF;MACAN,OAAO,GAAGE,cAAc,IAAI,CAAC,MAAM,CAACrI,IAAI,CAACsI,OAAO,CAAC;IACnD;IAEA,IAAI5J,IAAI,GAAG,IAAI,CAACT,KAAK,CAACiC,UAAU,CAAC,IAAI,CAACjD,KAAK,CAACR,GAAG,CAAC;IAChD,IAAIiC,IAAI,OAAkB,IAAI,CAACyJ,OAAO,EAAE;MACtC,EAAE,IAAI,CAAClL,KAAK,CAACR,GAAG;MAChB,IAAI,CAAC2K,OAAO,CAAC,EAAE,CAAC;MAChBa,OAAO,GAAG,IAAI;MACdvJ,IAAI,GAAG,IAAI,CAACT,KAAK,CAACiC,UAAU,CAAC,IAAI,CAACjD,KAAK,CAACR,GAAG,CAAC;IAC9C;IAEA,IACE,CAACiC,IAAI,OAAyB,IAAIA,IAAI,QAAyB,KAC/D,CAACyJ,OAAO,EACR;MACAzJ,IAAI,GAAG,IAAI,CAACT,KAAK,CAACiC,UAAU,CAAC,EAAE,IAAI,CAACjD,KAAK,CAACR,GAAG,CAAC;MAC9C,IAAIiC,IAAI,OAAuB,IAAIA,IAAI,OAAmB,EAAE;QAC1D,EAAE,IAAI,CAACzB,KAAK,CAACR,GAAG;MAClB;MACA,IAAI,IAAI,CAAC2K,OAAO,CAAC,EAAE,CAAC,KAAK,IAAI,EAAE;QAC7B,IAAI,CAACpG,KAAK,CAACQ,kBAAM,CAACmH,wBAAwB,EAAElL,QAAQ,CAAC;MACvD;MACAwK,OAAO,GAAG,IAAI;MACdC,WAAW,GAAG,IAAI;MAClBxJ,IAAI,GAAG,IAAI,CAACT,KAAK,CAACiC,UAAU,CAAC,IAAI,CAACjD,KAAK,CAACR,GAAG,CAAC;IAC9C;IAEA,IAAIiC,IAAI,QAAyB,EAAE;MAGjC,IAAIuJ,OAAO,IAAII,cAAc,EAAE;QAC7B,IAAI,CAACrH,KAAK,CAACQ,kBAAM,CAACoH,oBAAoB,EAAEnL,QAAQ,CAAC;MACnD;MACA,EAAE,IAAI,CAACR,KAAK,CAACR,GAAG;MAChBkL,QAAQ,GAAG,IAAI;IACjB;IAEA,IAAI,CAAClE,OAAO,CAACC,GAAG,CAACC,gBAAgB,IAAIjF,IAAI,QAAyB,EAAE;MAClE,IAAI,CAAC8E,YAAY,CAAC,SAAS,EAAE,IAAI,CAACvG,KAAK,CAACuC,WAAW,CAAC,CAAC,CAAC;MACtD,IAAI0I,WAAW,IAAIG,cAAc,EAAE;QACjC,IAAI,CAACrH,KAAK,CAACQ,kBAAM,CAACqG,cAAc,EAAEpK,QAAQ,CAAC;MAC7C;MACA,EAAE,IAAI,CAACR,KAAK,CAACR,GAAG;MAEhB,IAAIoM,SAAS,GAAG,IAAI;IACtB;IAEA,IAAI,IAAA9E,6BAAiB,EAAC,IAAI,CAACxD,cAAc,CAAC,IAAI,CAACtD,KAAK,CAACR,GAAG,CAAC,CAAC,EAAE;MAC1D,MAAM,IAAI,CAACuE,KAAK,CAACQ,kBAAM,CAACsG,gBAAgB,EAAE,IAAI,CAAC7K,KAAK,CAACuC,WAAW,CAAC,CAAC,CAAC;IACrE;IAGA,MAAM0G,GAAG,GAAG,IAAI,CAACjI,KAAK,CAAC2D,KAAK,CAACvE,KAAK,EAAE,IAAI,CAACJ,KAAK,CAACR,GAAG,CAAC,CAACsL,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC;IAEzE,IAAIJ,QAAQ,EAAE;MACZ,IAAI,CAACxG,WAAW,MAAY+E,GAAG,CAAC;MAChC;IACF;IAEA,IAAI,CAACzC,OAAO,CAACC,GAAG,CAACC,gBAAgB,IAAIkF,SAAS,EAAE;MAC9C,IAAI,CAAC1H,WAAW,MAAa+E,GAAG,CAAC;MACjC;IACF;IAEA,MAAMnD,GAAG,GAAGoF,OAAO,GAAGW,QAAQ,CAAC5C,GAAG,EAAE,CAAC,CAAC,GAAG6C,UAAU,CAAC7C,GAAG,CAAC;IACxD,IAAI,CAAC/E,WAAW,MAAS4B,GAAG,CAAC;EAC/B;EAIAiG,aAAaA,CAACC,cAAuB,EAAiB;IACpD,MAAM;MAAE3E,IAAI;MAAE7H;IAAI,CAAC,GAAG,IAAAuM,iCAAa,EACjC,IAAI,CAAC/K,KAAK,EACV,IAAI,CAAChB,KAAK,CAACR,GAAG,EACd,IAAI,CAACQ,KAAK,CAACP,SAAS,EACpB,IAAI,CAACO,KAAK,CAACN,OAAO,EAClBsM,cAAc,EACd,IAAI,CAACC,2BACP,CAAC;IACD,IAAI,CAACjM,KAAK,CAACR,GAAG,GAAGA,GAAG;IACpB,OAAO6H,IAAI;EACb;EAEAuB,UAAUA,CAACsD,KAAa,EAAQ;IAC9B,MAAM;MAAEjD,GAAG;MAAEzJ,GAAG;MAAEE,OAAO;MAAED;IAAU,CAAC,GAAG,IAAA0M,sCAAkB,EACzDD,KAAK,OAA4B,GAAG,QAAQ,GAAG,QAAQ,EACvD,IAAI,CAAClL,KAAK,EACV,IAAI,CAAChB,KAAK,CAACR,GAAG,GAAG,CAAC,EAClB,IAAI,CAACQ,KAAK,CAACP,SAAS,EACpB,IAAI,CAACO,KAAK,CAACN,OAAO,EAClB,IAAI,CAAC0M,uCACP,CAAC;IACD,IAAI,CAACpM,KAAK,CAACR,GAAG,GAAGA,GAAG,GAAG,CAAC;IACxB,IAAI,CAACQ,KAAK,CAACP,SAAS,GAAGA,SAAS;IAChC,IAAI,CAACO,KAAK,CAACN,OAAO,GAAGA,OAAO;IAC5B,IAAI,CAACwE,WAAW,MAAY+E,GAAG,CAAC;EAClC;EAGAoD,wBAAwBA,CAAA,EAAS;IAC/B,IAAI,CAAC,IAAI,CAACnK,KAAK,EAAU,CAAC,EAAE;MAC1B,IAAI,CAAC6F,UAAU,CAAC,IAAI,GAAW,CAAC;IAClC;IAEA,IAAI,CAAC/H,KAAK,CAACR,GAAG,EAAE;IAChB,IAAI,CAACkJ,iBAAiB,CAAC,CAAC;EAC1B;EAGAA,iBAAiBA,CAAA,EAAS;IACxB,MAAM4D,OAAO,GAAG,IAAI,CAACtL,KAAK,CAAC,IAAI,CAAChB,KAAK,CAACR,GAAG,CAAC;IAC1C,MAAM;MAAEyJ,GAAG;MAAEsD,eAAe;MAAE/M,GAAG;MAAEE,OAAO;MAAED;IAAU,CAAC,GACrD,IAAA0M,sCAAkB,EAChB,UAAU,EACV,IAAI,CAACnL,KAAK,EACV,IAAI,CAAChB,KAAK,CAACR,GAAG,GAAG,CAAC,EAClB,IAAI,CAACQ,KAAK,CAACP,SAAS,EACpB,IAAI,CAACO,KAAK,CAACN,OAAO,EAClB,IAAI,CAAC8M,yCACP,CAAC;IACH,IAAI,CAACxM,KAAK,CAACR,GAAG,GAAGA,GAAG,GAAG,CAAC;IACxB,IAAI,CAACQ,KAAK,CAACP,SAAS,GAAGA,SAAS;IAChC,IAAI,CAACO,KAAK,CAACN,OAAO,GAAGA,OAAO;IAE5B,IAAI6M,eAAe,EAAE;MACnB,IAAI,CAACvM,KAAK,CAACyM,6BAA6B,GAAG,IAAI9M,kBAAQ,CACrD4M,eAAe,CAAC7M,OAAO,EACvB6M,eAAe,CAAC/M,GAAG,GAAG+M,eAAe,CAAC9M,SAAS,EAC/C,IAAI,CAACmF,iBAAiB,CAAC2H,eAAe,CAAC/M,GAAG,CAC5C,CAAC;IACH;IAEA,IAAI,IAAI,CAACwB,KAAK,CAAC8G,WAAW,CAACtI,GAAG,CAAC,OAA0B,EAAE;MACzD,IAAI,CAAC0E,WAAW,KAEdqI,eAAe,GAAG,IAAI,GAAGD,OAAO,GAAGrD,GAAG,GAAG,GAC3C,CAAC;IACH,CAAC,MAAM;MACL,IAAI,CAACjJ,KAAK,CAACR,GAAG,EAAE;MAChB,IAAI,CAAC0E,WAAW,KAEdqI,eAAe,GAAG,IAAI,GAAGD,OAAO,GAAGrD,GAAG,GAAG,IAC3C,CAAC;IACH;EACF;EAEAqC,sBAAsBA,CAACzH,YAAiC,EAAEC,EAAY,EAAE;IACtE,MAAM4I,KAAK,GAAG5I,EAAE,CAAC4I,KAAK;IAEtB,IAAI,IAAI,CAAC1M,KAAK,CAAC0D,MAAM,IAAI,CAAC,IAAI,CAAC1D,KAAK,CAAC2D,YAAY,CAACgG,GAAG,CAAC+C,KAAK,CAAC,EAAE;MAC5D,IAAI,CAAC3I,KAAK,CAACF,YAAY,EAAEC,EAAE,CAAC;IAC9B,CAAC,MAAM;MACL,IAAI,CAAC9D,KAAK,CAAC2D,YAAY,CAACgJ,GAAG,CAACD,KAAK,EAAE,CAAC7I,YAAY,EAAEC,EAAE,CAAC,CAAC;IACxD;EACF;EAWAiD,SAASA,CAAC6F,SAAkB,EAAU;IACpC,IAAI,CAAC5M,KAAK,CAAC6M,WAAW,GAAG,KAAK;IAC9B,IAAIC,IAAI,GAAG,EAAE;IACb,MAAM1M,KAAK,GAAG,IAAI,CAACJ,KAAK,CAACR,GAAG;IAC5B,IAAIuN,UAAU,GAAG,IAAI,CAAC/M,KAAK,CAACR,GAAG;IAC/B,IAAIoN,SAAS,KAAKxH,SAAS,EAAE;MAC3B,IAAI,CAACpF,KAAK,CAACR,GAAG,IAAIoN,SAAS,IAAI,MAAM,GAAG,CAAC,GAAG,CAAC;IAC/C;IAEA,OAAO,IAAI,CAAC5M,KAAK,CAACR,GAAG,GAAG,IAAI,CAAC2B,MAAM,EAAE;MACnC,MAAM4D,EAAE,GAAG,IAAI,CAACzB,cAAc,CAAC,IAAI,CAACtD,KAAK,CAACR,GAAG,CAAC;MAC9C,IAAI,IAAAuK,4BAAgB,EAAChF,EAAE,CAAC,EAAE;QACxB,IAAI,CAAC/E,KAAK,CAACR,GAAG,IAAIuF,EAAE,IAAI,MAAM,GAAG,CAAC,GAAG,CAAC;MACxC,CAAC,MAAM,IAAIA,EAAE,OAAwB,EAAE;QACrC,IAAI,CAAC/E,KAAK,CAAC6M,WAAW,GAAG,IAAI;QAE7BC,IAAI,IAAI,IAAI,CAAC9L,KAAK,CAAC2D,KAAK,CAACoI,UAAU,EAAE,IAAI,CAAC/M,KAAK,CAACR,GAAG,CAAC;QACpD,MAAMwN,QAAQ,GAAG,IAAI,CAAChN,KAAK,CAACuC,WAAW,CAAC,CAAC;QACzC,MAAM0K,eAAe,GACnB,IAAI,CAACjN,KAAK,CAACR,GAAG,KAAKY,KAAK,GAAG0G,6BAAiB,GAAGiD,4BAAgB;QAEjE,IAAI,IAAI,CAAC/I,KAAK,CAACiC,UAAU,CAAC,EAAE,IAAI,CAACjD,KAAK,CAACR,GAAG,CAAC,QAAyB,EAAE;UACpE,IAAI,CAACuE,KAAK,CAACQ,kBAAM,CAAC2I,oBAAoB,EAAE,IAAI,CAAClN,KAAK,CAACuC,WAAW,CAAC,CAAC,CAAC;UACjEwK,UAAU,GAAG,IAAI,CAAC/M,KAAK,CAACR,GAAG,GAAG,CAAC;UAC/B;QACF;QAEA,EAAE,IAAI,CAACQ,KAAK,CAACR,GAAG;QAChB,MAAM2N,GAAG,GAAG,IAAI,CAACpB,aAAa,CAAC,IAAI,CAAC;QACpC,IAAIoB,GAAG,KAAK,IAAI,EAAE;UAChB,IAAI,CAACF,eAAe,CAACE,GAAG,CAAC,EAAE;YACzB,IAAI,CAACpJ,KAAK,CAACQ,kBAAM,CAAC6I,0BAA0B,EAAEJ,QAAQ,CAAC;UACzD;UAEAF,IAAI,IAAI/D,MAAM,CAACC,aAAa,CAACmE,GAAG,CAAC;QACnC;QACAJ,UAAU,GAAG,IAAI,CAAC/M,KAAK,CAACR,GAAG;MAC7B,CAAC,MAAM;QACL;MACF;IACF;IACA,OAAOsN,IAAI,GAAG,IAAI,CAAC9L,KAAK,CAAC2D,KAAK,CAACoI,UAAU,EAAE,IAAI,CAAC/M,KAAK,CAACR,GAAG,CAAC;EAC5D;EAKAqJ,QAAQA,CAAC+D,SAAkB,EAAQ;IACjC,MAAME,IAAI,GAAG,IAAI,CAAC/F,SAAS,CAAC6F,SAAS,CAAC;IACtC,MAAM1M,IAAI,GAAGmN,eAAY,CAACC,GAAG,CAACR,IAAI,CAAC;IACnC,IAAI5M,IAAI,KAAKkF,SAAS,EAAE;MAGtB,IAAI,CAAClB,WAAW,CAAChE,IAAI,EAAE,IAAAqN,qBAAc,EAACrN,IAAI,CAAC,CAAC;IAC9C,CAAC,MAAM;MACL,IAAI,CAACgE,WAAW,MAAU4I,IAAI,CAAC;IACjC;EACF;EAEApL,mBAAmBA,CAAA,EAAS;IAC1B,MAAM;MAAExB;IAAK,CAAC,GAAG,IAAI,CAACF,KAAK;IAC3B,IAAI,IAAAwN,qBAAc,EAACtN,IAAI,CAAC,IAAI,IAAI,CAACF,KAAK,CAAC6M,WAAW,EAAE;MAClD,IAAI,CAAC9I,KAAK,CAACQ,kBAAM,CAACkJ,0BAA0B,EAAE,IAAI,CAACzN,KAAK,CAACQ,QAAQ,EAAE;QACjEkN,YAAY,EAAE,IAAAH,qBAAc,EAACrN,IAAI;MACnC,CAAC,CAAC;IACJ;EACF;EAcA6D,KAAKA,CACHF,YAAiD,EACjDC,EAA2B,EAC3B6J,OAAqB,GAAG,CAAC,CAAiB,EAChB;IAC1B,MAAMrN,GAAG,GAAGwD,EAAE,YAAYnE,kBAAQ,GAAGmE,EAAE,GAAGA,EAAE,CAACxD,GAAG,CAACF,KAAK;IACtD,MAAMwN,KAAK,GAAG/J,YAAY,CAACvD,GAAG,EAAEqN,OAAO,CAAC;IAExC,IAAI,EAAE,IAAI,CAAChM,WAAW,GAAGC,oBAAW,CAACiM,aAAa,CAAC,EAAE,MAAMD,KAAK;IAChE,IAAI,CAAC,IAAI,CAAC/M,WAAW,EAAE,IAAI,CAACb,KAAK,CAAC8N,MAAM,CAACtM,IAAI,CAACoM,KAAK,CAAC;IAEpD,OAAOA,KAAK;EACd;EAQAG,cAAcA,CACZlK,YAAiD,EACjDC,EAA2B,EAC3B6J,OAAqB,GAAG,CAAC,CAAiB,EACR;IAClC,MAAMrN,GAAG,GAAGwD,EAAE,YAAYnE,kBAAQ,GAAGmE,EAAE,GAAGA,EAAE,CAACxD,GAAG,CAACF,KAAK;IACtD,MAAMZ,GAAG,GAAGc,GAAG,CAACoM,KAAK;IACrB,MAAMoB,MAAM,GAAG,IAAI,CAAC9N,KAAK,CAAC8N,MAAM;IAEhC,KAAK,IAAIE,CAAC,GAAGF,MAAM,CAAC3M,MAAM,GAAG,CAAC,EAAE6M,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MAC3C,MAAMJ,KAAK,GAAGE,MAAM,CAACE,CAAC,CAAC;MACvB,IAAIJ,KAAK,CAACtN,GAAG,CAACoM,KAAK,KAAKlN,GAAG,EAAE;QAC3B,OAAQsO,MAAM,CAACE,CAAC,CAAC,GAAGnK,YAAY,CAACvD,GAAG,EAAEqN,OAAO,CAAC;MAChD;MACA,IAAIC,KAAK,CAACtN,GAAG,CAACoM,KAAK,GAAGlN,GAAG,EAAE;IAC7B;IAEA,OAAO,IAAI,CAACuE,KAAK,CAACF,YAAY,EAAEC,EAAE,EAAE6J,OAAO,CAAC;EAC9C;EAIA3H,aAAaA,CAACD,QAAmB,EAAQ,CAAC;EAG1CgC,UAAUA,CAACzH,GAAqB,EAAEJ,IAAgB,EAAQ;IACxD,MAAM,IAAI,CAAC6D,KAAK,CACdQ,kBAAM,CAAC0J,eAAe,EACtB3N,GAAG,IAAI,IAAI,GAAGA,GAAG,GAAG,IAAI,CAACN,KAAK,CAACQ,QAAQ,EACvC;MACE0N,QAAQ,EAAEhO,IAAI,GAAG,IAAAqN,qBAAc,EAACrN,IAAI,CAAC,GAAG;IAC1C,CACF,CAAC;EACH;EAEAqG,YAAYA,CAAC4H,UAAkB,EAAE7N,GAAc,EAAQ;IACrD,IAAI,IAAI,CAACgG,SAAS,CAAC6H,UAAU,CAAC,EAAE;MAC9B,OAAO,IAAI;IACb;IAEA,MAAM,IAAI,CAACpK,KAAK,CACdQ,kBAAM,CAAC6J,aAAa,EACpB9N,GAAG,IAAI,IAAI,GAAGA,GAAG,GAAG,IAAI,CAACN,KAAK,CAACQ,QAAQ,EACvC;MACE6N,aAAa,EAAE,CAACF,UAAU;IAC5B,CACF,CAAC;EACH;EAEAG,eAAeA,CAACC,WAAqB,EAAQ;IAC3C,IAAI,CAACA,WAAW,CAACC,IAAI,CAACC,IAAI,IAAI,IAAI,CAACnI,SAAS,CAACmI,IAAI,CAAC,CAAC,EAAE;MACnD,MAAM,IAAI,CAAC1K,KAAK,CAACQ,kBAAM,CAACmK,mBAAmB,EAAE,IAAI,CAAC1O,KAAK,CAACQ,QAAQ,EAAE;QAChE6N,aAAa,EAAEE;MACjB,CAAC,CAAC;IACJ;EACF;EAEAI,YAAYA,CAACf,KAAoC,EAAE;IACjD,OAAO,CAACpO,GAAW,EAAEC,SAAiB,EAAEC,OAAe,KAAK;MAC1D,IAAI,CAACqE,KAAK,CAAC6J,KAAK,EAAErO,aAAa,CAACC,GAAG,EAAEC,SAAS,EAAEC,OAAO,CAAC,CAAC;IAC3D,CAAC;EACH;EAEA+K,qBAAqB,GAAqB;IACxCmE,YAAY,EAAEA,CAACpP,GAAG,EAAEC,SAAS,EAAEC,OAAO,EAAE0K,KAAK,KAAK;MAChD,IAAI,EAAE,IAAI,CAACzI,WAAW,GAAGC,oBAAW,CAACiM,aAAa,CAAC,EAAE,OAAO,KAAK;MAEjE,IAAI,CAAC9J,KAAK,CAACQ,kBAAM,CAACoG,YAAY,EAAEpL,aAAa,CAACC,GAAG,EAAEC,SAAS,EAAEC,OAAO,CAAC,EAAE;QACtE0K;MACF,CAAC,CAAC;MAEF,OAAO,IAAI;IACb,CAAC;IACDyE,gCAAgC,EAAE,IAAI,CAACF,YAAY,CACjDpK,kBAAM,CAACuK,gCACT,CAAC;IACDC,0BAA0B,EAAE,IAAI,CAACJ,YAAY,CAC3CpK,kBAAM,CAACyK,0BACT;EACF,CAAC;EAED/C,2BAA2B,GAAAgD,MAAA,CAAAC,MAAA,KACtB,IAAI,CAACzE,qBAAqB;IAC7B0E,qBAAqB,EAAE,IAAI,CAACR,YAAY,CAACpK,kBAAM,CAAC6K,qBAAqB,CAAC;IACtEC,gBAAgB,EAAE,IAAI,CAACV,YAAY,CAACpK,kBAAM,CAAC+K,gBAAgB;EAAC;EAG9DlD,uCAAuC,GAAA6C,MAAA,CAAAC,MAAA,KAClC,IAAI,CAACjD,2BAA2B;IACnCsD,mBAAmB,EAAEA,CAAC/P,GAAG,EAAEC,SAAS,EAAEC,OAAO,KAAK;MAChD,IAAI,CAAC4L,sBAAsB,CACzB/G,kBAAM,CAACiL,mBAAmB,EAC1BjQ,aAAa,CAACC,GAAG,EAAEC,SAAS,EAAEC,OAAO,CACvC,CAAC;IACH,CAAC;IACD+P,YAAY,EAAEA,CAACjQ,GAAG,EAAEC,SAAS,EAAEC,OAAO,KAAK;MACzC,MAAM,IAAI,CAACqE,KAAK,CACdQ,kBAAM,CAACmL,kBAAkB,EACzBnQ,aAAa,CAACC,GAAG,GAAG,CAAC,EAAEC,SAAS,EAAEC,OAAO,CAC3C,CAAC;IACH;EAAC;EAGH8M,yCAAyC,GAAAyC,MAAA,CAAAC,MAAA,KACpC,IAAI,CAACjD,2BAA2B;IACnCsD,mBAAmB,EAAE,IAAI,CAACZ,YAAY,CAACpK,kBAAM,CAACiL,mBAAmB,CAAC;IAClEC,YAAY,EAAEA,CAACjQ,GAAG,EAAEC,SAAS,EAAEC,OAAO,KAAK;MACzC,MAAM,IAAI,CAACqE,KAAK,CACdQ,kBAAM,CAACoL,oBAAoB,EAC3BpQ,aAAa,CAACC,GAAG,EAAEC,SAAS,EAAEC,OAAO,CACvC,CAAC;IACH;EAAC;AAEL;AAACgB,OAAA,CAAAkP,OAAA,GAAAjP,SAAA","ignoreList":[]}