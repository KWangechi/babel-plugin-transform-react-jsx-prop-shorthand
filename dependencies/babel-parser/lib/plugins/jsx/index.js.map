{"version":3,"names":["_xhtml","require","_types","_context","_identifier","_whitespace","_parseError","JsxErrors","ParseErrorEnum","AttributeIsEmpty","MissingClosingTagElement","openingTagName","MissingClosingTagFragment","UnexpectedSequenceExpression","UnexpectedToken","unexpected","HTMLEntity","UnsupportedJsxValue","UnterminatedJsxContent","UnwrappedAdjacentJSXElements","isFragment","object","type","getQualifiedJSXName","name","namespace","property","Error","_default","superClass","JSXParserMixin","jsxReadToken","out","chunkStart","state","pos","length","raise","startLoc","ch","input","charCodeAt","start","canStartJSXElement","finishToken","getTokenFromCode","slice","jsxReadEntity","process","env","BABEL_8_BREAKING","curPosition","isNewLine","jsxReadNewLine","normalizeCRLF","String","fromCharCode","curLine","lineStart","jsxReadString","quote","Errors","UnterminatedString","startPos","codePointAtPos","radix","codePoint","readInt","undefined","fromCodePoint","count","semi","desc","entity","XHTMLEntities","jsxReadWord","isIdentifierChar","jsxParseIdentifier","node","startNode","match","value","tokenIsKeyword","tokenLabelName","next","finishNode","jsxParsePropShorthand","expect","jsxParseNamespacedName","eat","startNodeAt","jsxParseElementName","newNode","jsxParseAttributeValue","setContext","tc","brace","jsxParseExpressionContainer","j_oTag","expression","parseExprAtom","jsxParseEmptyExpression","lastTokEndLoc","finishNodeAt","jsxParseSpreadChild","parseExpression","j_expr","previousContext","extra","parenthesized","expressions","jsxParseAttribute","argument","parseMaybeAssignAllowIn","jsxParseOpeningElementAt","jsxParseOpeningElementAfterName","attributes","push","selfClosing","jsxParseClosingElementAt","jsxParseElementAt","children","openingElement","closingElement","contents","parseLiteral","openingFragment","closingFragment","jsxParseElement","newContext","context","refExpressionErrors","replaceToken","skipSpace","curContext","preserveSpace","code","j_cTag","isIdentifierStart","finishOp","updateContext","prevType","splice","pop","tokenComesBeforeExpression","exports","default"],"sources":["../../../src/plugins/jsx/index.ts"],"sourcesContent":["import * as charCodes from \"charcodes\";\n\nimport XHTMLEntities from \"./xhtml.ts\";\nimport type Parser from \"../../parser/index.ts\";\nimport type { ExpressionErrors } from \"../../parser/util.ts\";\nimport {\n  tokenComesBeforeExpression,\n  tokenIsKeyword,\n  tokenLabelName,\n  type TokenType,\n  tt,\n} from \"../../tokenizer/types.ts\";\nimport type { TokContext } from \"../../tokenizer/context.ts\";\nimport { types as tc } from \"../../tokenizer/context.ts\";\nimport type * as N from \"../../types.ts\";\nimport { isIdentifierChar, isIdentifierStart } from \"../../util/identifier.ts\";\nimport type { Position } from \"../../util/location.ts\";\nimport { isNewLine } from \"../../util/whitespace.ts\";\nimport { Errors, ParseErrorEnum } from \"../../parse-error.ts\";\nimport type { Undone } from \"../../parser/node.ts\";\n\n/* eslint sort-keys: \"error\" */\nconst JsxErrors = ParseErrorEnum`jsx`({\n  AttributeIsEmpty:\n    \"JSX attributes must only be assigned a non-empty expression.\",\n  MissingClosingTagElement: ({ openingTagName }: { openingTagName: string }) =>\n    `Expected corresponding JSX closing tag for <${openingTagName}>.`,\n  MissingClosingTagFragment: \"Expected corresponding JSX closing tag for <>.\",\n  UnexpectedSequenceExpression:\n    \"Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?\",\n  // FIXME: Unify with Errors.UnexpectedToken\n  UnexpectedToken: ({\n    unexpected,\n    HTMLEntity,\n  }: {\n    unexpected: string;\n    HTMLEntity: string;\n  }) =>\n    `Unexpected token \\`${unexpected}\\`. Did you mean \\`${HTMLEntity}\\` or \\`{'${unexpected}'}\\`?`,\n  UnsupportedJsxValue:\n    \"JSX value should be either an expression or a quoted JSX text.\",\n  UnterminatedJsxContent: \"Unterminated JSX contents.\",\n  UnwrappedAdjacentJSXElements:\n    \"Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?\",\n});\n\n/* eslint-disable sort-keys */\n\nfunction isFragment(object?: N.JSXTag | null): object is N.JSXFragmentTag {\n  return object\n    ? object.type === \"JSXOpeningFragment\" ||\n        object.type === \"JSXClosingFragment\"\n    : false;\n}\n\n// Transforms JSX element name to string.\n\nfunction getQualifiedJSXName(\n  object: N.JSXIdentifier | N.JSXNamespacedName | N.JSXMemberExpression,\n): string {\n  if (object.type === \"JSXIdentifier\") {\n    return object.name;\n  }\n\n  if (object.type === \"JSXNamespacedName\") {\n    return object.namespace.name + \":\" + object.name.name;\n  }\n\n  if (object.type === \"JSXMemberExpression\") {\n    return (\n      getQualifiedJSXName(object.object) +\n      \".\" +\n      getQualifiedJSXName(object.property)\n    );\n  }\n\n  // istanbul ignore next\n  // @ts-expect-error - object is 'never'\n  throw new Error(\"Node had unexpected type: \" + object.type);\n}\n\nexport interface IJSXParserMixin {\n  jsxParseOpeningElementAfterName(\n    node: N.JSXOpeningElement,\n  ): N.JSXOpeningElement;\n}\n\nexport type ClassWithMixin<\n  T extends new (...args: any) => any,\n  M extends object,\n> = T extends new (...args: infer P) => infer I\n  ? new (...args: P) => I & M\n  : never;\n\nexport default (superClass: typeof Parser) =>\n  class JSXParserMixin extends superClass implements Parser, IJSXParserMixin {\n    // Reads inline JSX contents token.\n\n    jsxReadToken(): void {\n      let out = \"\";\n      let chunkStart = this.state.pos;\n      for (;;) {\n        if (this.state.pos >= this.length) {\n          throw this.raise(\n            JsxErrors.UnterminatedJsxContent,\n            this.state.startLoc,\n          );\n        }\n\n        const ch = this.input.charCodeAt(this.state.pos);\n\n        switch (ch) {\n          case charCodes.lessThan:\n          case charCodes.leftCurlyBrace:\n            if (this.state.pos === this.state.start) {\n              if (ch === charCodes.lessThan && this.state.canStartJSXElement) {\n                ++this.state.pos;\n                this.finishToken(tt.jsxTagStart);\n              } else {\n                super.getTokenFromCode(ch);\n              }\n              return;\n            }\n            out += this.input.slice(chunkStart, this.state.pos);\n            this.finishToken(tt.jsxText, out);\n            return;\n\n          case charCodes.ampersand:\n            out += this.input.slice(chunkStart, this.state.pos);\n            out += this.jsxReadEntity();\n            chunkStart = this.state.pos;\n            break;\n\n          case charCodes.greaterThan:\n          case charCodes.rightCurlyBrace:\n            if (process.env.BABEL_8_BREAKING) {\n              this.raise(JsxErrors.UnexpectedToken, this.state.curPosition(), {\n                unexpected: this.input[this.state.pos],\n                HTMLEntity:\n                  ch === charCodes.rightCurlyBrace ? \"&rbrace;\" : \"&gt;\",\n              });\n            }\n          /* falls through */\n\n          default:\n            if (isNewLine(ch)) {\n              out += this.input.slice(chunkStart, this.state.pos);\n              out += this.jsxReadNewLine(true);\n              chunkStart = this.state.pos;\n            } else {\n              ++this.state.pos;\n            }\n        }\n      }\n    }\n\n    jsxReadNewLine(normalizeCRLF: boolean): string {\n      const ch = this.input.charCodeAt(this.state.pos);\n      let out;\n      ++this.state.pos;\n      if (\n        ch === charCodes.carriageReturn &&\n        this.input.charCodeAt(this.state.pos) === charCodes.lineFeed\n      ) {\n        ++this.state.pos;\n        out = normalizeCRLF ? \"\\n\" : \"\\r\\n\";\n      } else {\n        out = String.fromCharCode(ch);\n      }\n      ++this.state.curLine;\n      this.state.lineStart = this.state.pos;\n\n      return out;\n    }\n\n    jsxReadString(quote: number): void {\n      let out = \"\";\n      let chunkStart = ++this.state.pos;\n      for (;;) {\n        if (this.state.pos >= this.length) {\n          throw this.raise(Errors.UnterminatedString, this.state.startLoc);\n        }\n\n        const ch = this.input.charCodeAt(this.state.pos);\n        if (ch === quote) break;\n        if (ch === charCodes.ampersand) {\n          out += this.input.slice(chunkStart, this.state.pos);\n          out += this.jsxReadEntity();\n          chunkStart = this.state.pos;\n        } else if (isNewLine(ch)) {\n          out += this.input.slice(chunkStart, this.state.pos);\n          out += this.jsxReadNewLine(false);\n          chunkStart = this.state.pos;\n        } else {\n          ++this.state.pos;\n        }\n      }\n      out += this.input.slice(chunkStart, this.state.pos++);\n      this.finishToken(tt.string, out);\n    }\n\n    jsxReadEntity(): string {\n      const startPos = ++this.state.pos;\n      if (this.codePointAtPos(this.state.pos) === charCodes.numberSign) {\n        ++this.state.pos;\n\n        let radix = 10;\n        if (this.codePointAtPos(this.state.pos) === charCodes.lowercaseX) {\n          radix = 16;\n          ++this.state.pos;\n        }\n\n        const codePoint = this.readInt(\n          radix,\n          /* len */ undefined,\n          /* forceLen */ false,\n          /* allowNumSeparator */ \"bail\",\n        );\n        if (\n          codePoint !== null &&\n          this.codePointAtPos(this.state.pos) === charCodes.semicolon\n        ) {\n          ++this.state.pos;\n          return String.fromCodePoint(codePoint);\n        }\n      } else {\n        let count = 0;\n        let semi = false;\n        while (\n          count++ < 10 &&\n          this.state.pos < this.length &&\n          !(semi = this.codePointAtPos(this.state.pos) === charCodes.semicolon)\n        ) {\n          ++this.state.pos;\n        }\n\n        if (semi) {\n          const desc = this.input.slice(startPos, this.state.pos);\n          const entity = XHTMLEntities[desc];\n          ++this.state.pos;\n\n          if (entity) {\n            return entity;\n          }\n        }\n      }\n\n      // Not a valid entity\n      this.state.pos = startPos;\n      return \"&\";\n    }\n\n    // Read a JSX identifier (valid tag or attribute name).\n    //\n    // Optimized version since JSX identifiers can\"t contain\n    // escape characters and so can be read as single slice.\n    // Also assumes that first character was already checked\n    // by isIdentifierStart in readToken.\n\n    jsxReadWord(): void {\n      let ch;\n      const start = this.state.pos;\n\n      do {\n        ch = this.input.charCodeAt(++this.state.pos);\n      } while (isIdentifierChar(ch) || ch === charCodes.dash);\n      this.finishToken(tt.jsxName, this.input.slice(start, this.state.pos));\n    }\n\n    // Parse next token as JSX identifier\n\n    jsxParseIdentifier(): N.JSXIdentifier {\n      const node = this.startNode<N.JSXIdentifier>();\n\n      if (this.match(tt.jsxName)) {\n        node.name = this.state.value;\n      } else if (tokenIsKeyword(this.state.type)) {\n        node.name = tokenLabelName(this.state.type);\n      } else {\n        this.unexpected();\n      }\n      this.next();\n      return this.finishNode(node, \"JSXIdentifier\");\n    }\n\n    // Parse double colon token as a JSXPropShorthandAttribute\n    jsxParsePropShorthand(): N.JSXPropShorthandAttribute {\n      const node = this.startNode<N.JSXPropShorthandAttribute>();\n      this.expect(tt.doubleColon);\n      this.next();\n\n      this.expect(tt.jsxName);\n\n      node.name = this.state.value;\n      this.next();\n\n      return this.finishNode(node, \"JSXPropShorthandAttribute\");\n    }\n\n    // Parse namespaced identifier.\n\n    jsxParseNamespacedName():\n      | N.JSXNamespacedName\n      | N.JSXIdentifier\n      | N.JSXPropShorthandAttribute {\n      const startLoc = this.state.startLoc;\n      const name = this.jsxParseIdentifier();\n      if (!this.eat(tt.colon)) return name;\n\n      const node = this.startNodeAt<N.JSXNamespacedName>(startLoc);\n      node.namespace = name;\n      node.name = this.jsxParseIdentifier();\n      return this.finishNode(node, \"JSXNamespacedName\");\n    }\n\n    // Parses element name in any form - namespaced, member\n    // or single identifier.\n\n    jsxParseElementName():\n      | N.JSXIdentifier\n      | N.JSXNamespacedName\n      | N.JSXMemberExpression\n      | N.JSXPropShorthandAttribute {\n      const startLoc = this.state.startLoc;\n      let node:\n        | N.JSXIdentifier\n        | N.JSXNamespacedName\n        | N.JSXMemberExpression\n        | N.JSXPropShorthandAttribute = this.jsxParseNamespacedName();\n      if (\n        node.type === \"JSXNamespacedName\" ||\n        node.type === \"JSXPropShorthandAttribute\"\n      ) {\n        return node;\n      }\n      while (this.eat(tt.dot)) {\n        const newNode = this.startNodeAt<N.JSXMemberExpression>(startLoc);\n        newNode.object = node;\n        newNode.property = this.jsxParseIdentifier();\n        node = this.finishNode(newNode, \"JSXMemberExpression\");\n      }\n      return node;\n    }\n\n    // Parses any type of JSX attribute value.\n\n    jsxParseAttributeValue():\n      | N.JSXExpressionContainer\n      | N.JSXElement\n      | N.StringLiteral {\n      let node;\n      switch (this.state.type) {\n        case tt.braceL:\n          node = this.startNode();\n          this.setContext(tc.brace);\n          this.next();\n          node = this.jsxParseExpressionContainer(node, tc.j_oTag);\n          if (node.expression.type === \"JSXEmptyExpression\") {\n            this.raise(JsxErrors.AttributeIsEmpty, node);\n          }\n          return node;\n\n        case tt.jsxTagStart:\n        case tt.string:\n          return this.parseExprAtom() as N.JSXElement | N.StringLiteral;\n\n        default:\n          throw this.raise(JsxErrors.UnsupportedJsxValue, this.state.startLoc);\n      }\n    }\n\n    // JSXEmptyExpression is unique type since it doesn't actually parse anything,\n    // and so it should start at the end of last read token (left brace) and finish\n    // at the beginning of the next one (right brace).\n\n    jsxParseEmptyExpression(): N.JSXEmptyExpression {\n      const node = this.startNodeAt(this.state.lastTokEndLoc);\n      return this.finishNodeAt(node, \"JSXEmptyExpression\", this.state.startLoc);\n    }\n\n    // Parse JSX spread child\n\n    jsxParseSpreadChild(node: Undone<N.JSXSpreadChild>): N.JSXSpreadChild {\n      this.next(); // ellipsis\n      node.expression = this.parseExpression();\n      this.setContext(tc.j_expr);\n      this.state.canStartJSXElement = true;\n      this.expect(tt.braceR);\n\n      return this.finishNode(node, \"JSXSpreadChild\");\n    }\n\n    // Parses JSX expression enclosed into curly brackets.\n\n    jsxParseExpressionContainer(\n      node: Undone<N.JSXExpressionContainer>,\n      previousContext: TokContext,\n    ): N.JSXExpressionContainer {\n      if (this.match(tt.braceR)) {\n        node.expression = this.jsxParseEmptyExpression();\n      } else {\n        const expression = this.parseExpression();\n\n        if (process.env.BABEL_8_BREAKING) {\n          if (\n            expression.type === \"SequenceExpression\" &&\n            !expression.extra?.parenthesized\n          ) {\n            this.raise(\n              JsxErrors.UnexpectedSequenceExpression,\n              expression.expressions[1],\n            );\n          }\n        }\n\n        node.expression = expression;\n      }\n      this.setContext(previousContext);\n      this.state.canStartJSXElement = true;\n      this.expect(tt.braceR);\n\n      return this.finishNode(node, \"JSXExpressionContainer\");\n    }\n\n    // Parses following JSX attribute name-value pair.\n\n    jsxParseAttribute():\n      | N.JSXAttribute\n      | N.JSXSpreadAttribute\n      | N.JSXPropShorthandAttribute {\n      const node = this.startNode<\n        N.JSXAttribute | N.JSXSpreadAttribute | N.JSXPropShorthandAttribute\n      >();\n      if (this.match(tt.braceL)) {\n        this.setContext(tc.brace);\n        this.next();\n        this.expect(tt.ellipsis);\n        node.argument = this.parseMaybeAssignAllowIn();\n        this.setContext(tc.j_oTag);\n        this.state.canStartJSXElement = true;\n        this.expect(tt.braceR);\n        return this.finishNode(node, \"JSXSpreadAttribute\");\n      }\n\n      if (this.match(tt.doubleColon)) {\n        this.next();\n        node.name = this.jsxParseIdentifier();\n        return this.finishNode(node, \"JSXPropShorthandAttribute\");\n      }\n\n      node.name = this.jsxParseNamespacedName();\n      node.value = this.eat(tt.eq) ? this.jsxParseAttributeValue() : null;\n      return this.finishNode(node, \"JSXAttribute\");\n    }\n\n    // Parses JSX opening tag starting after \"<\".\n\n    jsxParseOpeningElementAt(\n      startLoc: Position,\n    ): N.JSXOpeningElement | N.JSXOpeningFragment {\n      const node = this.startNodeAt<N.JSXOpeningElement | N.JSXOpeningFragment>(\n        startLoc,\n      );\n      if (this.eat(tt.jsxTagEnd)) {\n        return this.finishNode(node, \"JSXOpeningFragment\");\n      }\n      node.name = this.jsxParseElementName();\n      return this.jsxParseOpeningElementAfterName(\n        node as Undone<N.JSXOpeningElement>,\n      );\n    }\n\n    jsxParseOpeningElementAfterName(\n      node: Undone<N.JSXOpeningElement>,\n    ): N.JSXOpeningElement {\n      const attributes: (\n        | N.JSXAttribute\n        | N.JSXSpreadAttribute\n        | N.JSXPropShorthandAttribute\n      )[] = [];\n      while (!this.match(tt.slash) && !this.match(tt.jsxTagEnd)) {\n        attributes.push(this.jsxParseAttribute());\n      }\n      node.attributes = attributes;\n      node.selfClosing = this.eat(tt.slash);\n      this.expect(tt.jsxTagEnd);\n      return this.finishNode(node, \"JSXOpeningElement\");\n    }\n\n    // Parses JSX closing tag starting after \"</\".\n\n    jsxParseClosingElementAt(\n      startLoc: Position,\n    ): N.JSXClosingElement | N.JSXClosingFragment {\n      const node = this.startNodeAt<N.JSXClosingFragment | N.JSXClosingElement>(\n        startLoc,\n      );\n      if (this.eat(tt.jsxTagEnd)) {\n        return this.finishNode(node, \"JSXClosingFragment\");\n      }\n      node.name = this.jsxParseElementName();\n      this.expect(tt.jsxTagEnd);\n      return this.finishNode(node, \"JSXClosingElement\");\n    }\n\n    // Parses entire JSX element, including it\"s opening tag\n    // (starting after \"<\"), attributes, contents and closing tag.\n\n    jsxParseElementAt(startLoc: Position): N.JSXElement | N.JSXFragment {\n      const node = this.startNodeAt<N.JSXElement | N.JSXFragment>(startLoc);\n      const children = [];\n      const openingElement = this.jsxParseOpeningElementAt(startLoc);\n      let closingElement = null;\n\n      if (!openingElement.selfClosing) {\n        contents: for (;;) {\n          switch (this.state.type) {\n            case tt.jsxTagStart:\n              startLoc = this.state.startLoc;\n              this.next();\n              if (this.eat(tt.slash)) {\n                closingElement = this.jsxParseClosingElementAt(startLoc);\n                break contents;\n              }\n              children.push(this.jsxParseElementAt(startLoc));\n              break;\n\n            case tt.jsxText:\n              children.push(this.parseLiteral(this.state.value, \"JSXText\"));\n              break;\n\n            case tt.braceL: {\n              const node = this.startNode<\n                N.JSXSpreadChild | N.JSXExpressionContainer\n              >();\n              this.setContext(tc.brace);\n              this.next();\n              if (this.match(tt.ellipsis)) {\n                children.push(this.jsxParseSpreadChild(node));\n              } else {\n                children.push(\n                  this.jsxParseExpressionContainer(node, tc.j_expr),\n                );\n              }\n\n              break;\n            }\n            // istanbul ignore next - should never happen\n            default:\n              this.unexpected();\n          }\n        }\n\n        if (\n          isFragment(openingElement) &&\n          !isFragment(closingElement) &&\n          closingElement !== null\n        ) {\n          this.raise(JsxErrors.MissingClosingTagFragment, closingElement);\n        } else if (!isFragment(openingElement) && isFragment(closingElement)) {\n          this.raise(JsxErrors.MissingClosingTagElement, closingElement, {\n            openingTagName: getQualifiedJSXName(openingElement.name),\n          });\n        } else if (!isFragment(openingElement) && !isFragment(closingElement)) {\n          if (\n            getQualifiedJSXName(closingElement.name) !==\n            getQualifiedJSXName(openingElement.name)\n          ) {\n            this.raise(JsxErrors.MissingClosingTagElement, closingElement, {\n              openingTagName: getQualifiedJSXName(openingElement.name),\n            });\n          }\n        }\n      }\n\n      if (isFragment(openingElement)) {\n        node.openingFragment = openingElement;\n        node.closingFragment = closingElement;\n      } else {\n        node.openingElement = openingElement;\n        node.closingElement = closingElement;\n      }\n      node.children = children;\n      if (this.match(tt.lt)) {\n        throw this.raise(\n          JsxErrors.UnwrappedAdjacentJSXElements,\n          this.state.startLoc,\n        );\n      }\n\n      return isFragment(openingElement)\n        ? this.finishNode(node, \"JSXFragment\")\n        : this.finishNode(node, \"JSXElement\");\n    }\n\n    // Parses entire JSX element from current position.\n\n    jsxParseElement(): N.JSXElement | N.JSXFragment {\n      const startLoc = this.state.startLoc;\n      this.next();\n      return this.jsxParseElementAt(startLoc);\n    }\n\n    setContext(newContext: TokContext) {\n      const { context } = this.state;\n      context[context.length - 1] = newContext;\n    }\n\n    // ==================================\n    // Overrides\n    // ==================================\n\n    parseExprAtom(refExpressionErrors?: ExpressionErrors | null): N.Expression {\n      if (this.match(tt.jsxTagStart)) {\n        return this.jsxParseElement();\n      } else if (\n        this.match(tt.lt) &&\n        this.input.charCodeAt(this.state.pos) !== charCodes.exclamationMark\n      ) {\n        // In case we encounter an lt token here it will always be the start of\n        // jsx as the lt sign is not allowed in places that expect an expression\n        this.replaceToken(tt.jsxTagStart);\n        return this.jsxParseElement();\n      } else {\n        return super.parseExprAtom(refExpressionErrors);\n      }\n    }\n\n    skipSpace() {\n      const curContext = this.curContext();\n      if (!curContext.preserveSpace) super.skipSpace();\n    }\n\n    getTokenFromCode(code: number): void {\n      const context = this.curContext();\n\n      if (context === tc.j_expr) {\n        this.jsxReadToken();\n        return;\n      }\n\n      if (context === tc.j_oTag || context === tc.j_cTag) {\n        if (isIdentifierStart(code)) {\n          this.jsxReadWord();\n          return;\n        }\n\n        if (code === charCodes.greaterThan) {\n          ++this.state.pos;\n          this.finishToken(tt.jsxTagEnd);\n          return;\n        }\n\n        // Proposal for tokenizing a JSXPropShorthandAttribute\n        if (\n          code === charCodes.colon &&\n          this.input.charCodeAt(this.state.pos + 1) === charCodes.colon\n        ) {\n          this.finishOp(tt.doubleColon, 2);\n          this.finishToken(tt.doubleColon);\n          return;\n        }\n\n        if (\n          (code === charCodes.quotationMark || code === charCodes.apostrophe) &&\n          context === tc.j_oTag\n        ) {\n          this.jsxReadString(code);\n          return;\n        }\n      }\n\n      if (\n        code === charCodes.lessThan &&\n        this.state.canStartJSXElement &&\n        this.input.charCodeAt(this.state.pos + 1) !== charCodes.exclamationMark\n      ) {\n        ++this.state.pos;\n        this.finishToken(tt.jsxTagStart);\n        return;\n      }\n\n      super.getTokenFromCode(code);\n    }\n\n    updateContext(prevType: TokenType): void {\n      const { context, type } = this.state;\n      if (type === tt.slash && prevType === tt.jsxTagStart) {\n        // do not consider JSX expr -> JSX open tag -> ... anymore\n        // reconsider as closing tag context\n        context.splice(-2, 2, tc.j_cTag);\n        this.state.canStartJSXElement = false;\n      } else if (type === tt.jsxTagStart) {\n        // start opening tag context\n        context.push(tc.j_oTag);\n      } else if (type === tt.jsxTagEnd) {\n        const out = context[context.length - 1];\n        if ((out === tc.j_oTag && prevType === tt.slash) || out === tc.j_cTag) {\n          context.pop();\n          this.state.canStartJSXElement =\n            context[context.length - 1] === tc.j_expr;\n        } else {\n          this.setContext(tc.j_expr);\n          this.state.canStartJSXElement = true;\n        }\n      } else {\n        this.state.canStartJSXElement = tokenComesBeforeExpression(type);\n      }\n    }\n  };\n"],"mappings":"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","ignoreList":[]}